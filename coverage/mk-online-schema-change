---------------------------- ------ ------ ------ ------ ------ ------ ------
File                           stmt   bran   cond    sub    pod   time  total
---------------------------- ------ ------ ------ ------ ------ ------ ------
...e/mk-online-schema-change   49.8   29.7   26.7   62.1    n/a  100.0   43.0
Total                          49.8   29.7   26.7   62.1    n/a  100.0   43.0
---------------------------- ------ ------ ------ ------ ------ ------ ------


Run:          -e
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Mar 17 19:24:44 2011
Finish:       Thu Mar 17 19:24:44 2011

Run:          ./001_checks.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Mar 17 19:24:46 2011
Finish:       Thu Mar 17 19:24:46 2011

Run:          ./101_basics.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Mar 17 19:24:50 2011
Finish:       Thu Mar 17 19:24:51 2011

Run:          ./102_alter_active_table.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Mar 17 19:24:55 2011
Finish:       Thu Mar 17 19:25:09 2011

/home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change

line  err   stmt   bran   cond    sub    pod   time   code
1                                                     #!/usr/bin/env perl
2                                                     # This program is copyright 2011-@CURRENTYEAR@ Percona Inc.
3                                                     # Feedback and improvements are welcome.
4                                                     #
5                                                     # THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
6                                                     # WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
7                                                     # MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
8                                                     #
9                                                     # This program is free software; you can redistribute it and/or modify it under
10                                                    # the terms of the GNU General Public License as published by the Free Software
11                                                    # Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
12                                                    # systems, you can issue `man perlgpl' or `man perlartistic' to read these
13                                                    # licenses.
14                                                    #
15                                                    # You should have received a copy of the GNU General Public License along with
16                                                    # this program; if not, write to the Free Software Foundation, Inc., 59 Temple
17                                                    # Place, Suite 330, Boston, MA  02111-1307  USA.
18                                                    
19             3                    3            25   use strict;
               3                                 13   
               3                                 25   
20             3                    3            18   use warnings FATAL => 'all';
               3                                  7   
               3                                 22   
21                                                    
22                                                    our $VERSION = '@VERSION@';
23                                                    our $DISTRIB = '@DISTRIB@';
24                                                    our $SVN_REV = sprintf("%d", (q$Revision: 7322 $ =~ m/(\d+)/g, 0));
25                                                    
26                                                    # ###########################################################################
27                                                    # OptionParser package 7102
28                                                    # This package is a copy without comments from the original.  The original
29                                                    # with comments and its test file can be found in the SVN repository at,
30                                                    #   trunk/common/OptionParser.pm
31                                                    #   trunk/common/t/OptionParser.t
32                                                    # See http://code.google.com/p/maatkit/wiki/Developers for more information.
33                                                    # ###########################################################################
34                                                    
35                                                    package OptionParser;
36                                                    
37             3                    3            19   use strict;
               3                                  6   
               3                                 15   
38             3                    3            18   use warnings FATAL => 'all';
               3                                  7   
               3                                 13   
39             3                    3            20   use List::Util qw(max);
               3                                  9   
               3                                 35   
40             3                    3            23   use English qw(-no_match_vars);
               3                                  7   
               3                                 20   
41    ***      3            50      3            19   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               3                                  6   
               3                                 52   
42                                                    
43             3                    3            36   use Getopt::Long;
               3                                 10   
               3                                 20   
44                                                    
45                                                    my $POD_link_re = '[LC]<"?([^">]+)"?>';
46                                                    
47                                                    sub new {
48            12                   12           114      my ( $class, %args ) = @_;
49            12                                 54      my @required_args = qw();
50            12                                 57      foreach my $arg ( @required_args ) {
51    ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
52                                                       }
53                                                    
54            12                                167      my ($program_name) = $PROGRAM_NAME =~ m/([.A-Za-z-]+)$/;
55    ***     12            50                   56      $program_name ||= $PROGRAM_NAME;
56    ***     12            33                  108      my $home = $ENV{HOME} || $ENV{HOMEPATH} || $ENV{USERPROFILE} || '.';
      ***                   33                        
      ***                   50                        
57                                                    
58            12                                114      my %attributes = (
59                                                          'type'       => 1,
60                                                          'short form' => 1,
61                                                          'group'      => 1,
62                                                          'default'    => 1,
63                                                          'cumulative' => 1,
64                                                          'negatable'  => 1,
65                                                       );
66                                                    
67            12                                567      my $self = {
68                                                          head1             => 'OPTIONS',        # These args are used internally
69                                                          skip_rules        => 0,                # to instantiate another Option-
70                                                          item              => '--(.*)',         # Parser obj that parses the
71                                                          attributes        => \%attributes,     # DSN OPTIONS section.  Tools
72                                                          parse_attributes  => \&_parse_attribs, # don't tinker with these args.
73                                                    
74                                                          %args,
75                                                    
76                                                          strict            => 1,  # disabled by a special rule
77                                                          program_name      => $program_name,
78                                                          opts              => {},
79                                                          got_opts          => 0,
80                                                          short_opts        => {},
81                                                          defaults          => {},
82                                                          groups            => {},
83                                                          allowed_groups    => {},
84                                                          errors            => [],
85                                                          rules             => [],  # desc of rules for --help
86                                                          mutex             => [],  # rule: opts are mutually exclusive
87                                                          atleast1          => [],  # rule: at least one opt is required
88                                                          disables          => {},  # rule: opt disables other opts 
89                                                          defaults_to       => {},  # rule: opt defaults to value of other opt
90                                                          DSNParser         => undef,
91                                                          default_files     => [
92                                                             "/etc/maatkit/maatkit.conf",
93                                                             "/etc/maatkit/$program_name.conf",
94                                                             "$home/.maatkit.conf",
95                                                             "$home/.$program_name.conf",
96                                                          ],
97                                                          types             => {
98                                                             string => 's', # standard Getopt type
99                                                             int    => 'i', # standard Getopt type
100                                                            float  => 'f', # standard Getopt type
101                                                            Hash   => 'H', # hash, formed from a comma-separated list
102                                                            hash   => 'h', # hash as above, but only if a value is given
103                                                            Array  => 'A', # array, similar to Hash
104                                                            array  => 'a', # array, similar to hash
105                                                            DSN    => 'd', # DSN
106                                                            size   => 'z', # size with kMG suffix (powers of 2^10)
107                                                            time   => 'm', # time, with an optional suffix of s/h/m/d
108                                                         },
109                                                      };
110                                                   
111           12                                123      return bless $self, $class;
112                                                   }
113                                                   
114                                                   sub get_specs {
115            6                    6            30      my ( $self, $file ) = @_;
116   ***      6            50                   86      $file ||= $self->{file} || __FILE__;
                           100                        
117            6                                 52      my @specs = $self->_pod_to_specs($file);
118            6                                145      $self->_parse_specs(@specs);
119                                                   
120   ***      6     50                         199      open my $fh, "<", $file or die "Cannot open $file: $OS_ERROR";
121            6                                 18      my $contents = do { local $/ = undef; <$fh> };
               6                                 36   
               6                               1660   
122            6                                 49      close $fh;
123   ***      6     50                         353      if ( $contents =~ m/^=head1 DSN OPTIONS/m ) {
124            6                                 20         MKDEBUG && _d('Parsing DSN OPTIONS');
125            6                                742         my $dsn_attribs = {
126                                                            dsn  => 1,
127                                                            copy => 1,
128                                                         };
129                                                         my $parse_dsn_attribs = sub {
130           54                   54           345            my ( $self, $option, $attribs ) = @_;
131          108                                336            map {
132           54                                240               my $val = $attribs->{$_};
133   ***    108     50                         467               if ( $val ) {
134          108    100                         451                  $val    = $val eq 'yes' ? 1
                    100                               
135                                                                          : $val eq 'no'  ? 0
136                                                                          :                 $val;
137          108                                663                  $attribs->{$_} = $val;
138                                                               }
139                                                            } keys %$attribs;
140                                                            return {
141           54                                617               key => $option,
142                                                               %$attribs,
143                                                            };
144            6                                 73         };
145            6                                 69         my $dsn_o = new OptionParser(
146                                                            description       => 'DSN OPTIONS',
147                                                            head1             => 'DSN OPTIONS',
148                                                            dsn               => 0,         # XXX don't infinitely recurse!
149                                                            item              => '\* (.)',  # key opts are a single character
150                                                            skip_rules        => 1,         # no rules before opts
151                                                            attributes        => $dsn_attribs,
152                                                            parse_attributes  => $parse_dsn_attribs,
153                                                         );
154           54                                505         my @dsn_opts = map {
155            6                                 37            my $opts = {
156                                                               key  => $_->{spec}->{key},
157                                                               dsn  => $_->{spec}->{dsn},
158                                                               copy => $_->{spec}->{copy},
159                                                               desc => $_->{desc},
160                                                            };
161           54                                198            $opts;
162                                                         } $dsn_o->_pod_to_specs($file);
163            6                                133         $self->{DSNParser} = DSNParser->new(opts => \@dsn_opts);
164                                                      }
165                                                   
166            6                                 15      return;
167                                                   }
168                                                   
169                                                   sub DSNParser {
170            5                    5            21      my ( $self ) = @_;
171            5                                 25      return $self->{DSNParser};
172                                                   };
173                                                   
174                                                   sub get_defaults_files {
175            6                    6            24      my ( $self ) = @_;
176            6                                 19      return @{$self->{default_files}};
               6                                 68   
177                                                   }
178                                                   
179                                                   sub _pod_to_specs {
180           12                   12            57      my ( $self, $file ) = @_;
181   ***     12             0                   54      $file ||= $self->{file} || __FILE__;
      ***                   50                        
182   ***     12     50                         461      open my $fh, '<', $file or die "Cannot open $file: $OS_ERROR";
183                                                   
184           12                                 45      my @specs = ();
185           12                                 40      my @rules = ();
186           12                                 33      my $para;
187                                                   
188           12                                 92      local $INPUT_RECORD_SEPARATOR = '';
189           12                                250      while ( $para = <$fh> ) {
190         7860    100                       60024         next unless $para =~ m/^=head1 $self->{head1}/;
191           12                                 44         last;
192                                                      }
193                                                   
194           12                                 77      while ( $para = <$fh> ) {
195           24    100                         120         last if $para =~ m/^=over/;
196           12    100                          73         next if $self->{skip_rules};
197            6                                 24         chomp $para;
198            6                                 69         $para =~ s/\s+/ /g;
199            6                                167         $para =~ s/$POD_link_re/$1/go;
200            6                                 17         MKDEBUG && _d('Option rule:', $para);
201            6                                 52         push @rules, $para;
202                                                      }
203                                                   
204   ***     12     50                          55      die "POD has no $self->{head1} section" unless $para;
205                                                   
206           12                                 36      do {
207          252    100                        2127         if ( my ($option) = $para =~ m/^=item $self->{item}/ ) {
208          240                                674            chomp $para;
209          240                                522            MKDEBUG && _d($para);
210          240                                579            my %attribs;
211                                                   
212          240                                851            $para = <$fh>; # read next paragraph, possibly attributes
213                                                   
214          240    100                         917            if ( $para =~ m/: / ) { # attributes
215          192                                934               $para =~ s/\s+\Z//g;
216          318                               1451               %attribs = map {
217          192                                848                     my ( $attrib, $val) = split(/: /, $_);
218   ***    318     50                        1901                     die "Unrecognized attribute for --$option: $attrib"
219                                                                        unless $self->{attributes}->{$attrib};
220          318                               1572                     ($attrib, $val);
221                                                                  } split(/; /, $para);
222          192    100                         845               if ( $attribs{'short form'} ) {
223           54                                244                  $attribs{'short form'} =~ s/-//;
224                                                               }
225          192                                819               $para = <$fh>; # read next paragraph, probably short help desc
226                                                            }
227                                                            else {
228           48                                122               MKDEBUG && _d('Option has no attributes');
229                                                            }
230                                                   
231          240                               1388            $para =~ s/\s+\Z//g;
232          240                               1318            $para =~ s/\s+/ /g;
233          240                                910            $para =~ s/$POD_link_re/$1/go;
234                                                   
235          240                                904            $para =~ s/\.(?:\n.*| [A-Z].*|\Z)//s;
236          240                                532            MKDEBUG && _d('Short help:', $para);
237                                                   
238   ***    240     50                         919            die "No description after option spec $option" if $para =~ m/^=item/;
239                                                   
240          240    100                        1106            if ( my ($base_option) =  $option =~ m/^\[no\](.*)/ ) {
241           24                                 65               $option = $base_option;
242           24                                 87               $attribs{'negatable'} = 1;
243                                                            }
244                                                   
245          240    100                        1384            push @specs, {
      ***            50                               
246                                                               spec  => $self->{parse_attributes}->($self, $option, \%attribs), 
247                                                               desc  => $para
248                                                                  . (defined $attribs{default} ? " (default $attribs{default})" : ''),
249                                                               group => ($attribs{'group'} ? $attribs{'group'} : 'default'),
250                                                            };
251                                                         }
252          252                               1676         while ( $para = <$fh> ) {
253   ***    270     50                         893            last unless $para;
254          270    100                        1055            if ( $para =~ m/^=head1/ ) {
255           12                                 39               $para = undef; # Can't 'last' out of a do {} block.
256           12                                 60               last;
257                                                            }
258          258    100                        1597            last if $para =~ m/^=item /;
259                                                         }
260                                                      } while ( $para );
261                                                   
262   ***     12     50                          53      die "No valid specs in $self->{head1}" unless @specs;
263                                                   
264           12                                144      close $fh;
265           12                                 43      return @specs, @rules;
266                                                   }
267                                                   
268                                                   sub _parse_specs {
269            6                    6            51      my ( $self, @specs ) = @_;
270            6                                 26      my %disables; # special rule that requires deferred checking
271                                                   
272            6                                 30      foreach my $opt ( @specs ) {
273          192    100                         664         if ( ref $opt ) { # It's an option spec, not a rule.
274                                                            MKDEBUG && _d('Parsing opt spec:',
275          186                                408               map { ($_, '=>', $opt->{$_}) } keys %$opt);
276                                                   
277          186                               1199            my ( $long, $short ) = $opt->{spec} =~ m/^([\w-]+)(?:\|([^!+=]*))?/;
278   ***    186     50                         739            if ( !$long ) {
279   ***      0                                  0               die "Cannot parse long option from spec $opt->{spec}";
280                                                            }
281          186                                630            $opt->{long} = $long;
282                                                   
283   ***    186     50                         797            die "Duplicate long option --$long" if exists $self->{opts}->{$long};
284          186                                792            $self->{opts}->{$long} = $opt;
285                                                   
286   ***    186     50                         695            if ( length $long == 1 ) {
287   ***      0                                  0               MKDEBUG && _d('Long opt', $long, 'looks like short opt');
288   ***      0                                  0               $self->{short_opts}->{$long} = $long;
289                                                            }
290                                                   
291          186    100                         592            if ( $short ) {
292   ***     54     50                         227               die "Duplicate short option -$short"
293                                                                  if exists $self->{short_opts}->{$short};
294           54                                261               $self->{short_opts}->{$short} = $long;
295           54                                180               $opt->{short} = $short;
296                                                            }
297                                                            else {
298          132                                444               $opt->{short} = undef;
299                                                            }
300                                                   
301          186    100                         952            $opt->{is_negatable}  = $opt->{spec} =~ m/!/        ? 1 : 0;
302   ***    186     50                         859            $opt->{is_cumulative} = $opt->{spec} =~ m/\+/       ? 1 : 0;
303   ***    186     50                        1020            $opt->{is_required}   = $opt->{desc} =~ m/required/ ? 1 : 0;
304                                                   
305   ***    186            50                  709            $opt->{group} ||= 'default';
306          186                                835            $self->{groups}->{ $opt->{group} }->{$long} = 1;
307                                                   
308          186                                563            $opt->{value} = undef;
309          186                                574            $opt->{got}   = 0;
310                                                   
311          186                                889            my ( $type ) = $opt->{spec} =~ m/=(.)/;
312          186                                644            $opt->{type} = $type;
313          186                                411            MKDEBUG && _d($long, 'type:', $type);
314                                                   
315                                                   
316          186    100    100                 1265            $opt->{spec} =~ s/=./=s/ if ( $type && $type =~ m/[HhAadzm]/ );
317                                                   
318          186    100                        1068            if ( (my ($def) = $opt->{desc} =~ m/default\b(?: ([^)]+))?/) ) {
319   ***     48     50                         253               $self->{defaults}->{$long} = defined $def ? $def : 1;
320           48                                115               MKDEBUG && _d($long, 'default:', $def);
321                                                            }
322                                                   
323          186    100                         703            if ( $long eq 'config' ) {
324            6                                 37               $self->{defaults}->{$long} = join(',', $self->get_defaults_files());
325                                                            }
326                                                   
327   ***    186     50                         883            if ( (my ($dis) = $opt->{desc} =~ m/(disables .*)/) ) {
328   ***      0                                  0               $disables{$long} = $dis;
329   ***      0                                  0               MKDEBUG && _d('Deferring check of disables rule for', $opt, $dis);
330                                                            }
331                                                   
332          186                                830            $self->{opts}->{$long} = $opt;
333                                                         }
334                                                         else { # It's an option rule, not a spec.
335            6                                 16            MKDEBUG && _d('Parsing rule:', $opt); 
336            6                                 18            push @{$self->{rules}}, $opt;
               6                                 30   
337            6                                 39            my @participants = $self->_get_participants($opt);
338            6                                 20            my $rule_ok = 0;
339                                                   
340   ***      6     50                          63            if ( $opt =~ m/mutually exclusive|one and only one/ ) {
341   ***      0                                  0               $rule_ok = 1;
342   ***      0                                  0               push @{$self->{mutex}}, \@participants;
      ***      0                                  0   
343   ***      0                                  0               MKDEBUG && _d(@participants, 'are mutually exclusive');
344                                                            }
345   ***      6     50                          51            if ( $opt =~ m/at least one|one and only one/ ) {
346   ***      0                                  0               $rule_ok = 1;
347   ***      0                                  0               push @{$self->{atleast1}}, \@participants;
      ***      0                                  0   
348   ***      0                                  0               MKDEBUG && _d(@participants, 'require at least one');
349                                                            }
350   ***      6     50                          32            if ( $opt =~ m/default to/ ) {
351   ***      0                                  0               $rule_ok = 1;
352   ***      0                                  0               $self->{defaults_to}->{$participants[0]} = $participants[1];
353   ***      0                                  0               MKDEBUG && _d($participants[0], 'defaults to', $participants[1]);
354                                                            }
355   ***      6     50                          92            if ( $opt =~ m/restricted to option groups/ ) {
356   ***      0                                  0               $rule_ok = 1;
357   ***      0                                  0               my ($groups) = $opt =~ m/groups ([\w\s\,]+)/;
358   ***      0                                  0               my @groups = split(',', $groups);
359   ***      0                                  0               %{$self->{allowed_groups}->{$participants[0]}} = map {
      ***      0                                  0   
360   ***      0                                  0                  s/\s+//;
361   ***      0                                  0                  $_ => 1;
362                                                               } @groups;
363                                                            }
364   ***      6     50                          49            if( $opt =~ m/accepts additional command-line arguments/ ) {
365            6                                 20               $rule_ok = 1;
366            6                                 30               $self->{strict} = 0;
367            6                                 18               MKDEBUG && _d("Strict mode disabled by rule");
368                                                            }
369                                                   
370   ***      6     50                          36            die "Unrecognized option rule: $opt" unless $rule_ok;
371                                                         }
372                                                      }
373                                                   
374            6                                 34      foreach my $long ( keys %disables ) {
375   ***      0                                  0         my @participants = $self->_get_participants($disables{$long});
376   ***      0                                  0         $self->{disables}->{$long} = \@participants;
377   ***      0                                  0         MKDEBUG && _d('Option', $long, 'disables', @participants);
378                                                      }
379                                                   
380            6                                 32      return; 
381                                                   }
382                                                   
383                                                   sub _get_participants {
384            6                    6            37      my ( $self, $str ) = @_;
385            6                                 22      my @participants;
386            6                                 40      foreach my $long ( $str =~ m/--(?:\[no\])?([\w-]+)/g ) {
387   ***      0      0                           0         die "Option --$long does not exist while processing rule $str"
388                                                            unless exists $self->{opts}->{$long};
389   ***      0                                  0         push @participants, $long;
390                                                      }
391            6                                 20      MKDEBUG && _d('Participants for', $str, ':', @participants);
392            6                                 24      return @participants;
393                                                   }
394                                                   
395                                                   sub opts {
396   ***      0                    0             0      my ( $self ) = @_;
397   ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
398   ***      0                                  0      return %opts;
399                                                   }
400                                                   
401                                                   sub short_opts {
402   ***      0                    0             0      my ( $self ) = @_;
403   ***      0                                  0      my %short_opts = %{$self->{short_opts}};
      ***      0                                  0   
404   ***      0                                  0      return %short_opts;
405                                                   }
406                                                   
407                                                   sub set_defaults {
408   ***      0                    0             0      my ( $self, %defaults ) = @_;
409   ***      0                                  0      $self->{defaults} = {};
410   ***      0                                  0      foreach my $long ( keys %defaults ) {
411   ***      0      0                           0         die "Cannot set default for nonexistent option $long"
412                                                            unless exists $self->{opts}->{$long};
413   ***      0                                  0         $self->{defaults}->{$long} = $defaults{$long};
414   ***      0                                  0         MKDEBUG && _d('Default val for', $long, ':', $defaults{$long});
415                                                      }
416   ***      0                                  0      return;
417                                                   }
418                                                   
419                                                   sub get_defaults {
420   ***      0                    0             0      my ( $self ) = @_;
421   ***      0                                  0      return $self->{defaults};
422                                                   }
423                                                   
424                                                   sub get_groups {
425   ***      0                    0             0      my ( $self ) = @_;
426   ***      0                                  0      return $self->{groups};
427                                                   }
428                                                   
429                                                   sub _set_option {
430           15                   15            66      my ( $self, $opt, $val ) = @_;
431   ***     15      0                          36      my $long = exists $self->{opts}->{$opt}       ? $opt
      ***            50                               
432                                                               : exists $self->{short_opts}->{$opt} ? $self->{short_opts}->{$opt}
433                                                               : die "Getopt::Long gave a nonexistent option: $opt";
434                                                   
435           15                                 28      $opt = $self->{opts}->{$long};
436   ***     15     50                          85      if ( $opt->{is_cumulative} ) {
437   ***      0                                  0         $opt->{value}++;
438                                                      }
439                                                      else {
440           15                                 58         $opt->{value} = $val;
441                                                      }
442           15                                 48      $opt->{got} = 1;
443           15                                 58      MKDEBUG && _d('Got option', $long, '=', $val);
444                                                   }
445                                                   
446                                                   sub get_opts {
447            7                    7            71      my ( $self ) = @_; 
448                                                   
449            7                                 21      foreach my $long ( keys %{$self->{opts}} ) {
               7                                123   
450          217                                866         $self->{opts}->{$long}->{got} = 0;
451   ***    217     50                        1666         $self->{opts}->{$long}->{value}
                    100                               
452                                                            = exists $self->{defaults}->{$long}       ? $self->{defaults}->{$long}
453                                                            : $self->{opts}->{$long}->{is_cumulative} ? 0
454                                                            : undef;
455                                                      }
456            7                                 40      $self->{got_opts} = 0;
457                                                   
458            7                                 30      $self->{errors} = [];
459                                                   
460   ***      7     50     66                   89      if ( @ARGV && $ARGV[0] eq "--config" ) {
461   ***      0                                  0         shift @ARGV;
462   ***      0                                  0         $self->_set_option('config', shift @ARGV);
463                                                      }
464   ***      7     50                          49      if ( $self->has('config') ) {
465            7                                 21         my @extra_args;
466            7                                 51         foreach my $filename ( split(',', $self->get('config')) ) {
467           28                                 77            eval {
468           28                                141               push @extra_args, $self->_read_config_file($filename);
469                                                            };
470   ***     28     50                         136            if ( $EVAL_ERROR ) {
471   ***     28     50                         121               if ( $self->got('config') ) {
472   ***      0                                  0                  die $EVAL_ERROR;
473                                                               }
474                                                               elsif ( MKDEBUG ) {
475                                                                  _d($EVAL_ERROR);
476                                                               }
477                                                            }
478                                                         }
479            7                                 36         unshift @ARGV, @extra_args;
480                                                      }
481                                                   
482            7                                 68      Getopt::Long::Configure('no_ignore_case', 'bundling');
483                                                      GetOptions(
484          210                   15          1383         map    { $_->{spec} => sub { $self->_set_option(@_); } }
              15                                 80   
             217                                831   
485            7                                 46         grep   { $_->{long} ne 'config' } # --config is handled specially above.
486   ***      7     50                          25         values %{$self->{opts}}
487                                                      ) or $self->save_error('Error parsing options');
488                                                   
489   ***      7     50     33                  363      if ( exists $self->{opts}->{version} && $self->{opts}->{version}->{got} ) {
490   ***      0      0                           0         printf("%s  Ver %s Distrib %s Changeset %s\n",
491                                                            $self->{program_name}, $main::VERSION, $main::DISTRIB, $main::SVN_REV)
492                                                               or die "Cannot print: $OS_ERROR";
493   ***      0                                  0         exit 0;
494                                                      }
495                                                   
496   ***      7     50     66                   63      if ( @ARGV && $self->{strict} ) {
497   ***      0                                  0         $self->save_error("Unrecognized command-line options @ARGV");
498                                                      }
499                                                   
500            7                                 24      foreach my $mutex ( @{$self->{mutex}} ) {
               7                                 40   
501   ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$mutex;
      ***      0                                  0   
502   ***      0      0                           0         if ( @set > 1 ) {
503   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
504   ***      0                                  0                         @{$mutex}[ 0 .. scalar(@$mutex) - 2] )
505                                                                    . ' and --'.$self->{opts}->{$mutex->[-1]}->{long}
506                                                                    . ' are mutually exclusive.';
507   ***      0                                  0            $self->save_error($err);
508                                                         }
509                                                      }
510                                                   
511            7                                 22      foreach my $required ( @{$self->{atleast1}} ) {
               7                                 34   
512   ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$required;
      ***      0                                  0   
513   ***      0      0                           0         if ( @set == 0 ) {
514   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
515   ***      0                                  0                         @{$required}[ 0 .. scalar(@$required) - 2] )
516                                                                    .' or --'.$self->{opts}->{$required->[-1]}->{long};
517   ***      0                                  0            $self->save_error("Specify at least one of $err");
518                                                         }
519                                                      }
520                                                   
521            7                                 23      $self->_check_opts( keys %{$self->{opts}} );
               7                                 88   
522            7                                 43      $self->{got_opts} = 1;
523            7                                 25      return;
524                                                   }
525                                                   
526                                                   sub _check_opts {
527            7                    7            83      my ( $self, @long ) = @_;
528            7                                 34      my $long_last = scalar @long;
529            7                                 31      while ( @long ) {
530            7                                 61         foreach my $i ( 0..$#long ) {
531          217                                760            my $long = $long[$i];
532   ***    217     50                         719            next unless $long;
533          217                                797            my $opt  = $self->{opts}->{$long};
534          217    100                        1135            if ( $opt->{got} ) {
      ***            50                               
535   ***     15     50                          71               if ( exists $self->{disables}->{$long} ) {
536   ***      0                                  0                  my @disable_opts = @{$self->{disables}->{$long}};
      ***      0                                  0   
537   ***      0                                  0                  map { $self->{opts}->{$_}->{value} = undef; } @disable_opts;
      ***      0                                  0   
538   ***      0                                  0                  MKDEBUG && _d('Unset options', @disable_opts,
539                                                                     'because', $long,'disables them');
540                                                               }
541                                                   
542   ***     15     50                          73               if ( exists $self->{allowed_groups}->{$long} ) {
543                                                   
544   ***      0                                  0                  my @restricted_groups = grep {
545   ***      0                                  0                     !exists $self->{allowed_groups}->{$long}->{$_}
546   ***      0                                  0                  } keys %{$self->{groups}};
547                                                   
548   ***      0                                  0                  my @restricted_opts;
549   ***      0                                  0                  foreach my $restricted_group ( @restricted_groups ) {
550   ***      0                                  0                     RESTRICTED_OPT:
551   ***      0                                  0                     foreach my $restricted_opt (
552                                                                        keys %{$self->{groups}->{$restricted_group}} )
553                                                                     {
554   ***      0      0                           0                        next RESTRICTED_OPT if $restricted_opt eq $long;
555   ***      0      0                           0                        push @restricted_opts, $restricted_opt
556                                                                           if $self->{opts}->{$restricted_opt}->{got};
557                                                                     }
558                                                                  }
559                                                   
560   ***      0      0                           0                  if ( @restricted_opts ) {
561   ***      0                                  0                     my $err;
562   ***      0      0                           0                     if ( @restricted_opts == 1 ) {
563   ***      0                                  0                        $err = "--$restricted_opts[0]";
564                                                                     }
565                                                                     else {
566   ***      0                                  0                        $err = join(', ',
567   ***      0                                  0                                  map { "--$self->{opts}->{$_}->{long}" }
568   ***      0                                  0                                  grep { $_ } 
569                                                                                  @restricted_opts[0..scalar(@restricted_opts) - 2]
570                                                                               )
571                                                                             . ' or --'.$self->{opts}->{$restricted_opts[-1]}->{long};
572                                                                     }
573   ***      0                                  0                     $self->save_error("--$long is not allowed with $err");
574                                                                  }
575                                                               }
576                                                   
577                                                            }
578                                                            elsif ( $opt->{is_required} ) { 
579   ***      0                                  0               $self->save_error("Required option --$long must be specified");
580                                                            }
581                                                   
582          217                                778            $self->_validate_type($opt);
583   ***    217     50                         755            if ( $opt->{parsed} ) {
584          217                               1101               delete $long[$i];
585                                                            }
586                                                            else {
587   ***      0                                  0               MKDEBUG && _d('Temporarily failed to parse', $long);
588                                                            }
589                                                         }
590                                                   
591   ***      7     50                          39         die "Failed to parse options, possibly due to circular dependencies"
592                                                            if @long == $long_last;
593            7                                 36         $long_last = @long;
594                                                      }
595                                                   
596            7                                 33      return;
597                                                   }
598                                                   
599                                                   sub _validate_type {
600          217                  217          1000      my ( $self, $opt ) = @_;
601   ***    217     50                         782      return unless $opt;
602                                                   
603          217    100                         910      if ( !$opt->{type} ) {
604           91                                303         $opt->{parsed} = 1;
605           91                                253         return;
606                                                      }
607                                                   
608          126                                401      my $val = $opt->{value};
609                                                   
610   ***    126     50     66                 3484      if ( $val && $opt->{type} eq 'm' ) {  # type time
      ***            50     66                        
                    100    100                        
      ***            50     66                        
      ***           100     33                        
                           100                        
                           100                        
611   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a time value');
612   ***      0                                  0         my ( $prefix, $num, $suffix ) = $val =~ m/([+-]?)(\d+)([a-z])?$/;
613   ***      0      0                           0         if ( !$suffix ) {
614   ***      0                                  0            my ( $s ) = $opt->{desc} =~ m/\(suffix (.)\)/;
615   ***      0             0                    0            $suffix = $s || 's';
616   ***      0                                  0            MKDEBUG && _d('No suffix given; using', $suffix, 'for',
617                                                               $opt->{long}, '(value:', $val, ')');
618                                                         }
619   ***      0      0                           0         if ( $suffix =~ m/[smhd]/ ) {
620   ***      0      0                           0            $val = $suffix eq 's' ? $num            # Seconds
      ***             0                               
      ***             0                               
621                                                                 : $suffix eq 'm' ? $num * 60       # Minutes
622                                                                 : $suffix eq 'h' ? $num * 3600     # Hours
623                                                                 :                  $num * 86400;   # Days
624   ***      0             0                    0            $opt->{value} = ($prefix || '') . $val;
625   ***      0                                  0            MKDEBUG && _d('Setting option', $opt->{long}, 'to', $val);
626                                                         }
627                                                         else {
628   ***      0                                  0            $self->save_error("Invalid time suffix for --$opt->{long}");
629                                                         }
630                                                      }
631                                                      elsif ( $val && $opt->{type} eq 'd' ) {  # type DSN
632   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a DSN');
633   ***      0                                  0         my $prev = {};
634   ***      0                                  0         my $from_key = $self->{defaults_to}->{ $opt->{long} };
635   ***      0      0                           0         if ( $from_key ) {
636   ***      0                                  0            MKDEBUG && _d($opt->{long}, 'DSN copies from', $from_key, 'DSN');
637   ***      0      0                           0            if ( $self->{opts}->{$from_key}->{parsed} ) {
638   ***      0                                  0               $prev = $self->{opts}->{$from_key}->{value};
639                                                            }
640                                                            else {
641   ***      0                                  0               MKDEBUG && _d('Cannot parse', $opt->{long}, 'until',
642                                                                  $from_key, 'parsed');
643   ***      0                                  0               return;
644                                                            }
645                                                         }
646   ***      0                                  0         my $defaults = $self->{DSNParser}->parse_options($self);
647   ***      0                                  0         $opt->{value} = $self->{DSNParser}->parse($val, $prev, $defaults);
648                                                      }
649                                                      elsif ( $val && $opt->{type} eq 'z' ) {  # type size
650            7                                 16         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a size value');
651            7                                 54         $self->_parse_size($opt, $val);
652                                                      }
653                                                      elsif ( $opt->{type} eq 'H' || (defined $val && $opt->{type} eq 'h') ) {
654   ***      0             0                    0         $opt->{value} = { map { $_ => 1 } split(/(?<!\\),\s*/, ($val || '')) };
      ***      0                                  0   
655                                                      }
656                                                      elsif ( $opt->{type} eq 'A' || (defined $val && $opt->{type} eq 'a') ) {
657   ***     14            50                  180         $opt->{value} = [ split(/(?<!\\),\s*/, ($val || '')) ];
658                                                      }
659                                                      else {
660          105                                261         MKDEBUG && _d('Nothing to validate for option',
661                                                            $opt->{long}, 'type', $opt->{type}, 'value', $val);
662                                                      }
663                                                   
664          126                                407      $opt->{parsed} = 1;
665          126                                351      return;
666                                                   }
667                                                   
668                                                   sub get {
669          185                  185           795      my ( $self, $opt ) = @_;
670          185    100                         864      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
671   ***    185     50     33                 1747      die "Option $opt does not exist"
672                                                         unless $long && exists $self->{opts}->{$long};
673          185                             967417      return $self->{opts}->{$long}->{value};
674                                                   }
675                                                   
676                                                   sub got {
677           28                   28           118      my ( $self, $opt ) = @_;
678   ***     28     50                         122      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
679   ***     28     50     33                  244      die "Option $opt does not exist"
680                                                         unless $long && exists $self->{opts}->{$long};
681           28                                172      return $self->{opts}->{$long}->{got};
682                                                   }
683                                                   
684                                                   sub has {
685           52                   52           191      my ( $self, $opt ) = @_;
686           52    100                         286      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
687           52    100                         544      return defined $long ? exists $self->{opts}->{$long} : 0;
688                                                   }
689                                                   
690                                                   sub set {
691   ***      0                    0             0      my ( $self, $opt, $val ) = @_;
692   ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
693   ***      0      0      0                    0      die "Option $opt does not exist"
694                                                         unless $long && exists $self->{opts}->{$long};
695   ***      0                                  0      $self->{opts}->{$long}->{value} = $val;
696   ***      0                                  0      return;
697                                                   }
698                                                   
699                                                   sub save_error {
700   ***      0                    0             0      my ( $self, $error ) = @_;
701   ***      0                                  0      push @{$self->{errors}}, $error;
      ***      0                                  0   
702   ***      0                                  0      return;
703                                                   }
704                                                   
705                                                   sub errors {
706   ***      0                    0             0      my ( $self ) = @_;
707   ***      0                                  0      return $self->{errors};
708                                                   }
709                                                   
710                                                   sub usage {
711   ***      0                    0             0      my ( $self ) = @_;
712   ***      0      0                           0      warn "No usage string is set" unless $self->{usage}; # XXX
713   ***      0             0                    0      return "Usage: " . ($self->{usage} || '') . "\n";
714                                                   }
715                                                   
716                                                   sub descr {
717   ***      0                    0             0      my ( $self ) = @_;
718   ***      0      0                           0      warn "No description string is set" unless $self->{description}; # XXX
719   ***      0             0                    0      my $descr  = ($self->{description} || $self->{program_name} || '')
      ***                    0                        
720                                                                 . "  For more details, please use the --help option, "
721                                                                 . "or try 'perldoc $PROGRAM_NAME' "
722                                                                 . "for complete documentation.";
723   ***      0      0                           0      $descr = join("\n", $descr =~ m/(.{0,80})(?:\s+|$)/g)
724                                                         unless $ENV{DONT_BREAK_LINES};
725   ***      0                                  0      $descr =~ s/ +$//mg;
726   ***      0                                  0      return $descr;
727                                                   }
728                                                   
729                                                   sub usage_or_errors {
730            5                    5            24      my ( $self, $file, $return ) = @_;
731   ***      5            50                   63      $file ||= $self->{file} || __FILE__;
      ***                   33                        
732                                                   
733   ***      5     50     33                   33      if ( !$self->{description} || !$self->{usage} ) {
734            5                                 11         MKDEBUG && _d("Getting description and usage from SYNOPSIS in", $file);
735            5                                 31         my %synop = $self->_parse_synopsis($file);
736   ***      5            33                   88         $self->{description} ||= $synop{description};
737   ***      5            33                   28         $self->{usage}       ||= $synop{usage};
738            5                                 18         MKDEBUG && _d("Description:", $self->{description},
739                                                            "\nUsage:", $self->{usage});
740                                                      }
741                                                   
742   ***      5     50                          33      if ( $self->{opts}->{help}->{got} ) {
      ***      5     50                          28   
743   ***      0      0                           0         print $self->print_usage() or die "Cannot print usage: $OS_ERROR";
744   ***      0      0                           0         exit 0 unless $return;
745                                                      }
746                                                      elsif ( scalar @{$self->{errors}} ) {
747   ***      0      0                           0         print $self->print_errors() or die "Cannot print errors: $OS_ERROR";
748   ***      0      0                           0         exit 0 unless $return;
749                                                      }
750                                                   
751            5                                 16      return;
752                                                   }
753                                                   
754                                                   sub print_errors {
755   ***      0                    0             0      my ( $self ) = @_;
756   ***      0                                  0      my $usage = $self->usage() . "\n";
757   ***      0      0                           0      if ( (my @errors = @{$self->{errors}}) ) {
      ***      0                                  0   
758   ***      0                                  0         $usage .= join("\n  * ", 'Errors in command-line arguments:', @errors)
759                                                                 . "\n";
760                                                      }
761   ***      0                                  0      return $usage . "\n" . $self->descr();
762                                                   }
763                                                   
764                                                   sub print_usage {
765   ***      0                    0             0      my ( $self ) = @_;
766   ***      0      0                           0      die "Run get_opts() before print_usage()" unless $self->{got_opts};
767   ***      0                                  0      my @opts = values %{$self->{opts}};
      ***      0                                  0   
768                                                   
769   ***      0      0                           0      my $maxl = max(
      ***             0                               
770                                                         map {
771   ***      0                                  0            length($_->{long})               # option long name
772                                                            + ($_->{is_negatable} ? 4 : 0)   # "[no]" if opt is negatable
773                                                            + ($_->{type} ? 2 : 0)           # "=x" where x is the opt type
774                                                         }
775                                                         @opts);
776                                                   
777   ***      0      0                           0      my $maxs = max(0,
      ***             0                               
778                                                         map {
779   ***      0                                  0            length($_)
780                                                            + ($self->{opts}->{$_}->{is_negatable} ? 4 : 0)
781                                                            + ($self->{opts}->{$_}->{type} ? 2 : 0)
782                                                         }
783   ***      0                                  0         values %{$self->{short_opts}});
784                                                   
785   ***      0                                  0      my $lcol = max($maxl, ($maxs + 3));
786   ***      0                                  0      my $rcol = 80 - $lcol - 6;
787   ***      0                                  0      my $rpad = ' ' x ( 80 - $rcol );
788                                                   
789   ***      0                                  0      $maxs = max($lcol - 3, $maxs);
790                                                   
791   ***      0                                  0      my $usage = $self->descr() . "\n" . $self->usage();
792                                                   
793   ***      0                                  0      my @groups = reverse sort grep { $_ ne 'default'; } keys %{$self->{groups}};
      ***      0                                  0   
      ***      0                                  0   
794   ***      0                                  0      push @groups, 'default';
795                                                   
796   ***      0                                  0      foreach my $group ( reverse @groups ) {
797   ***      0      0                           0         $usage .= "\n".($group eq 'default' ? 'Options' : $group).":\n\n";
798   ***      0                                  0         foreach my $opt (
      ***      0                                  0   
799   ***      0                                  0            sort { $a->{long} cmp $b->{long} }
800                                                            grep { $_->{group} eq $group }
801                                                            @opts )
802                                                         {
803   ***      0      0                           0            my $long  = $opt->{is_negatable} ? "[no]$opt->{long}" : $opt->{long};
804   ***      0                                  0            my $short = $opt->{short};
805   ***      0                                  0            my $desc  = $opt->{desc};
806                                                   
807   ***      0      0                           0            $long .= $opt->{type} ? "=$opt->{type}" : "";
808                                                   
809   ***      0      0      0                    0            if ( $opt->{type} && $opt->{type} eq 'm' ) {
810   ***      0                                  0               my ($s) = $desc =~ m/\(suffix (.)\)/;
811   ***      0             0                    0               $s    ||= 's';
812   ***      0                                  0               $desc =~ s/\s+\(suffix .\)//;
813   ***      0                                  0               $desc .= ".  Optional suffix s=seconds, m=minutes, h=hours, "
814                                                                      . "d=days; if no suffix, $s is used.";
815                                                            }
816   ***      0                                  0            $desc = join("\n$rpad", grep { $_ } $desc =~ m/(.{0,$rcol})(?:\s+|$)/g);
      ***      0                                  0   
817   ***      0                                  0            $desc =~ s/ +$//mg;
818   ***      0      0                           0            if ( $short ) {
819   ***      0                                  0               $usage .= sprintf("  --%-${maxs}s -%s  %s\n", $long, $short, $desc);
820                                                            }
821                                                            else {
822   ***      0                                  0               $usage .= sprintf("  --%-${lcol}s  %s\n", $long, $desc);
823                                                            }
824                                                         }
825                                                      }
826                                                   
827   ***      0                                  0      $usage .= "\nOption types: s=string, i=integer, f=float, h/H/a/A=comma-separated list, d=DSN, z=size, m=time\n";
828                                                   
829   ***      0      0                           0      if ( (my @rules = @{$self->{rules}}) ) {
      ***      0                                  0   
830   ***      0                                  0         $usage .= "\nRules:\n\n";
831   ***      0                                  0         $usage .= join("\n", map { "  $_" } @rules) . "\n";
      ***      0                                  0   
832                                                      }
833   ***      0      0                           0      if ( $self->{DSNParser} ) {
834   ***      0                                  0         $usage .= "\n" . $self->{DSNParser}->usage();
835                                                      }
836   ***      0                                  0      $usage .= "\nOptions and values after processing arguments:\n\n";
837   ***      0                                  0      foreach my $opt ( sort { $a->{long} cmp $b->{long} } @opts ) {
      ***      0                                  0   
838   ***      0                                  0         my $val   = $opt->{value};
839   ***      0             0                    0         my $type  = $opt->{type} || '';
840   ***      0                                  0         my $bool  = $opt->{spec} =~ m/^[\w-]+(?:\|[\w-])?!?$/;
841   ***      0      0                           0         $val      = $bool              ? ( $val ? 'TRUE' : 'FALSE' )
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
842                                                                   : !defined $val      ? '(No value)'
843                                                                   : $type eq 'd'       ? $self->{DSNParser}->as_string($val)
844                                                                   : $type =~ m/H|h/    ? join(',', sort keys %$val)
845                                                                   : $type =~ m/A|a/    ? join(',', @$val)
846                                                                   :                    $val;
847   ***      0                                  0         $usage .= sprintf("  --%-${lcol}s  %s\n", $opt->{long}, $val);
848                                                      }
849   ***      0                                  0      return $usage;
850                                                   }
851                                                   
852                                                   sub prompt_noecho {
853   ***      0      0             0             0      shift @_ if ref $_[0] eq __PACKAGE__;
854   ***      0                                  0      my ( $prompt ) = @_;
855   ***      0                                  0      local $OUTPUT_AUTOFLUSH = 1;
856   ***      0      0                           0      print $prompt
857                                                         or die "Cannot print: $OS_ERROR";
858   ***      0                                  0      my $response;
859   ***      0                                  0      eval {
860   ***      0                                  0         require Term::ReadKey;
861   ***      0                                  0         Term::ReadKey::ReadMode('noecho');
862   ***      0                                  0         chomp($response = <STDIN>);
863   ***      0                                  0         Term::ReadKey::ReadMode('normal');
864   ***      0      0                           0         print "\n"
865                                                            or die "Cannot print: $OS_ERROR";
866                                                      };
867   ***      0      0                           0      if ( $EVAL_ERROR ) {
868   ***      0                                  0         die "Cannot read response; is Term::ReadKey installed? $EVAL_ERROR";
869                                                      }
870   ***      0                                  0      return $response;
871                                                   }
872                                                   
873                                                   if ( MKDEBUG ) {
874                                                      print '# ', $^X, ' ', $], "\n";
875                                                      my $uname = `uname -a`;
876                                                      if ( $uname ) {
877                                                         $uname =~ s/\s+/ /g;
878                                                         print "# $uname\n";
879                                                      }
880                                                      printf("# %s  Ver %s Distrib %s Changeset %s line %d\n",
881                                                         $PROGRAM_NAME, ($main::VERSION || ''), ($main::DISTRIB || ''),
882                                                         ($main::SVN_REV || ''), __LINE__);
883                                                      print('# Arguments: ',
884                                                         join(' ', map { my $a = "_[$_]_"; $a =~ s/\n/\n# /g; $a; } @ARGV), "\n");
885                                                   }
886                                                   
887                                                   sub _read_config_file {
888           28                   28           111      my ( $self, $filename ) = @_;
889   ***     28     50                          68      open my $fh, "<", $filename or die "Cannot open $filename: $OS_ERROR\n";
890   ***      0                                  0      my @args;
891   ***      0                                  0      my $prefix = '--';
892   ***      0                                  0      my $parse  = 1;
893                                                   
894                                                      LINE:
895   ***      0                                  0      while ( my $line = <$fh> ) {
896   ***      0                                  0         chomp $line;
897   ***      0      0                           0         next LINE if $line =~ m/^\s*(?:\#|\;|$)/;
898   ***      0                                  0         $line =~ s/\s+#.*$//g;
899   ***      0                                  0         $line =~ s/^\s+|\s+$//g;
900   ***      0      0                           0         if ( $line eq '--' ) {
901   ***      0                                  0            $prefix = '';
902   ***      0                                  0            $parse  = 0;
903   ***      0                                  0            next LINE;
904                                                         }
905   ***      0      0      0                    0         if ( $parse
      ***             0                               
906                                                            && (my($opt, $arg) = $line =~ m/^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/)
907                                                         ) {
908   ***      0                                  0            push @args, grep { defined $_ } ("$prefix$opt", $arg);
      ***      0                                  0   
909                                                         }
910                                                         elsif ( $line =~ m/./ ) {
911   ***      0                                  0            push @args, $line;
912                                                         }
913                                                         else {
914   ***      0                                  0            die "Syntax error in file $filename at line $INPUT_LINE_NUMBER";
915                                                         }
916                                                      }
917   ***      0                                  0      close $fh;
918   ***      0                                  0      return @args;
919                                                   }
920                                                   
921                                                   sub read_para_after {
922   ***      0                    0             0      my ( $self, $file, $regex ) = @_;
923   ***      0      0                           0      open my $fh, "<", $file or die "Can't open $file: $OS_ERROR";
924   ***      0                                  0      local $INPUT_RECORD_SEPARATOR = '';
925   ***      0                                  0      my $para;
926   ***      0                                  0      while ( $para = <$fh> ) {
927   ***      0      0                           0         next unless $para =~ m/^=pod$/m;
928   ***      0                                  0         last;
929                                                      }
930   ***      0                                  0      while ( $para = <$fh> ) {
931   ***      0      0                           0         next unless $para =~ m/$regex/;
932   ***      0                                  0         last;
933                                                      }
934   ***      0                                  0      $para = <$fh>;
935   ***      0                                  0      chomp($para);
936   ***      0      0                           0      close $fh or die "Can't close $file: $OS_ERROR";
937   ***      0                                  0      return $para;
938                                                   }
939                                                   
940                                                   sub clone {
941   ***      0                    0             0      my ( $self ) = @_;
942                                                   
943   ***      0                                  0      my %clone = map {
944   ***      0                                  0         my $hashref  = $self->{$_};
945   ***      0                                  0         my $val_copy = {};
946   ***      0                                  0         foreach my $key ( keys %$hashref ) {
947   ***      0                                  0            my $ref = ref $hashref->{$key};
948   ***      0                                  0            $val_copy->{$key} = !$ref           ? $hashref->{$key}
949   ***      0                                  0                              : $ref eq 'HASH'  ? { %{$hashref->{$key}} }
950   ***      0      0                           0                              : $ref eq 'ARRAY' ? [ @{$hashref->{$key}} ]
      ***             0                               
      ***             0                               
951                                                                              : $hashref->{$key};
952                                                         }
953   ***      0                                  0         $_ => $val_copy;
954                                                      } qw(opts short_opts defaults);
955                                                   
956   ***      0                                  0      foreach my $scalar ( qw(got_opts) ) {
957   ***      0                                  0         $clone{$scalar} = $self->{$scalar};
958                                                      }
959                                                   
960   ***      0                                  0      return bless \%clone;     
961                                                   }
962                                                   
963                                                   sub _parse_size {
964            7                    7            37      my ( $self, $opt, $val ) = @_;
965                                                   
966   ***      7     50     50                   52      if ( lc($val || '') eq 'null' ) {
967   ***      0                                  0         MKDEBUG && _d('NULL size for', $opt->{long});
968   ***      0                                  0         $opt->{value} = 'null';
969   ***      0                                  0         return;
970                                                      }
971                                                   
972            7                                 41      my %factor_for = (k => 1_024, M => 1_048_576, G => 1_073_741_824);
973            7                                 65      my ($pre, $num, $factor) = $val =~ m/^([+-])?(\d+)([kMG])?$/;
974   ***      7     50                          34      if ( defined $num ) {
975   ***      7     50                          30         if ( $factor ) {
976   ***      0                                  0            $num *= $factor_for{$factor};
977   ***      0                                  0            MKDEBUG && _d('Setting option', $opt->{y},
978                                                               'to num', $num, '* factor', $factor);
979                                                         }
980   ***      7            50                   69         $opt->{value} = ($pre || '') . $num;
981                                                      }
982                                                      else {
983   ***      0                                  0         $self->save_error("Invalid size for --$opt->{long}");
984                                                      }
985            7                                 32      return;
986                                                   }
987                                                   
988                                                   sub _parse_attribs {
989          186                  186           751      my ( $self, $option, $attribs ) = @_;
990          186                                630      my $types = $self->{types};
991          186    100                        4038      return $option
                    100                               
      ***            50                               
                    100                               
992                                                         . ($attribs->{'short form'} ? '|' . $attribs->{'short form'}   : '' )
993                                                         . ($attribs->{'negatable'}  ? '!'                              : '' )
994                                                         . ($attribs->{'cumulative'} ? '+'                              : '' )
995                                                         . ($attribs->{'type'}       ? '=' . $types->{$attribs->{type}} : '' );
996                                                   }
997                                                   
998                                                   sub _parse_synopsis {
999            5                    5            23      my ( $self, $file ) = @_;
1000  ***      5             0                   50      $file ||= $self->{file} || __FILE__;
      ***                   33                        
1001           5                                 10      MKDEBUG && _d("Parsing SYNOPSIS in", $file);
1002                                                  
1003           5                                 35      local $INPUT_RECORD_SEPARATOR = '';  # read paragraphs
1004  ***      5     50                         202      open my $fh, "<", $file or die "Cannot open $file: $OS_ERROR";
1005           5                                 13      my $para;
1006  ***      5            66                18919      1 while defined($para = <$fh>) && $para !~ m/^=head1 SYNOPSIS/;
1007  ***      5     50                          22      die "$file does not contain a SYNOPSIS section" unless $para;
1008           5                                 15      my @synop;
1009           5                                 24      for ( 1..2 ) {  # 1 for the usage, 2 for the description
1010          10                                 41         my $para = <$fh>;
1011          10                                 44         push @synop, $para;
1012                                                     }
1013           5                                 49      close $fh;
1014           5                                 13      MKDEBUG && _d("Raw SYNOPSIS text:", @synop);
1015           5                                 26      my ($usage, $desc) = @synop;
1016  ***      5     50     33                   50      die "The SYNOPSIS section in $file is not formatted properly"
1017                                                        unless $usage && $desc;
1018                                                  
1019           5                                 67      $usage =~ s/^\s*Usage:\s+(.+)/$1/;
1020           5                                 20      chomp $usage;
1021                                                  
1022           5                                 35      $desc =~ s/\n/ /g;
1023           5                                 29      $desc =~ s/\s{2,}/ /g;
1024           5                                 16      $desc =~ s/\. ([A-Z][a-z])/.  $1/g;
1025           5                                 26      $desc =~ s/\s+$//;
1026                                                  
1027                                                     return (
1028           5                                 17         description => $desc,
1029                                                        usage       => $usage,
1030                                                     );
1031                                                  };
1032                                                  
1033                                                  sub _d {
1034  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1035  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1036  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1037                                                          @_;
1038  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1039                                                  }
1040                                                  
1041                                                  1;
1042                                                  
1043                                                  # ###########################################################################
1044                                                  # End OptionParser package
1045                                                  # ###########################################################################
1046                                                  
1047                                                  # ###########################################################################
1048                                                  # VersionParser package 6667
1049                                                  # This package is a copy without comments from the original.  The original
1050                                                  # with comments and its test file can be found in the SVN repository at,
1051                                                  #   trunk/common/VersionParser.pm
1052                                                  #   trunk/common/t/VersionParser.t
1053                                                  # See http://code.google.com/p/maatkit/wiki/Developers for more information.
1054                                                  # ###########################################################################
1055                                                  package VersionParser;
1056                                                  
1057           3                    3            40   use strict;
               3                                 11   
               3                                 30   
1058           3                    3            19   use warnings FATAL => 'all';
               3                                 10   
               3                                 24   
1059                                                  
1060           3                    3            19   use English qw(-no_match_vars);
               3                                 11   
               3                                 24   
1061                                                  
1062  ***      3            50      3            21   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               3                                  8   
               3                                 50   
1063                                                  
1064                                                  sub new {
1065           6                    6           545      my ( $class ) = @_;
1066           6                                 95      bless {}, $class;
1067                                                  }
1068                                                  
1069                                                  sub parse {
1070          15                   15           659      my ( $self, $str ) = @_;
1071          15                                207      my $result = sprintf('%03d%03d%03d', $str =~ m/(\d+)/g);
1072          15                                 39      MKDEBUG && _d($str, 'parses to', $result);
1073          15                                109      return $result;
1074                                                  }
1075                                                  
1076                                                  sub version_ge {
1077          10                   10            48      my ( $self, $dbh, $target ) = @_;
1078          10    100                          78      if ( !$self->{$dbh} ) {
1079           5                                 14         $self->{$dbh} = $self->parse(
1080                                                           $dbh->selectrow_array('SELECT VERSION()'));
1081                                                     }
1082  ***     10     50                         124      my $result = $self->{$dbh} ge $self->parse($target) ? 1 : 0;
1083          10                                 27      MKDEBUG && _d($self->{$dbh}, 'ge', $target, ':', $result);
1084          10                                 60      return $result;
1085                                                  }
1086                                                  
1087                                                  sub innodb_version {
1088  ***      0                    0             0      my ( $self, $dbh ) = @_;
1089  ***      0      0                           0      return unless $dbh;
1090  ***      0                                  0      my $innodb_version = "NO";
1091                                                  
1092  ***      0                                  0      my ($innodb) =
1093  ***      0                                  0         grep { $_->{engine} =~ m/InnoDB/i }
1094                                                        map  {
1095  ***      0                                  0            my %hash;
1096  ***      0                                  0            @hash{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                  0   
1097  ***      0                                  0            \%hash;
1098                                                        }
1099  ***      0                                  0         @{ $dbh->selectall_arrayref("SHOW ENGINES", {Slice=>{}}) };
1100  ***      0      0                           0      if ( $innodb ) {
1101  ***      0                                  0         MKDEBUG && _d("InnoDB support:", $innodb->{support});
1102  ***      0      0                           0         if ( $innodb->{support} =~ m/YES|DEFAULT/i ) {
1103  ***      0                                  0            my $vars = $dbh->selectrow_hashref(
1104                                                              "SHOW VARIABLES LIKE 'innodb_version'");
1105  ***      0      0      0                    0            $innodb_version = !$vars ? "BUILTIN"
1106                                                                           :          ($vars->{Value} || $vars->{value});
1107                                                        }
1108                                                        else {
1109  ***      0                                  0            $innodb_version = $innodb->{support};  # probably DISABLED or NO
1110                                                        }
1111                                                     }
1112                                                  
1113  ***      0                                  0      MKDEBUG && _d("InnoDB version:", $innodb_version);
1114  ***      0                                  0      return $innodb_version;
1115                                                  }
1116                                                  
1117                                                  sub _d {
1118  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1119  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1120  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1121                                                          @_;
1122  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1123                                                  }
1124                                                  
1125                                                  1;
1126                                                  
1127                                                  # ###########################################################################
1128                                                  # End VersionParser package
1129                                                  # ###########################################################################
1130                                                  
1131                                                  # ###########################################################################
1132                                                  # DSNParser package 6785
1133                                                  # This package is a copy without comments from the original.  The original
1134                                                  # with comments and its test file can be found in the SVN repository at,
1135                                                  #   trunk/common/DSNParser.pm
1136                                                  #   trunk/common/t/DSNParser.t
1137                                                  # See http://code.google.com/p/maatkit/wiki/Developers for more information.
1138                                                  # ###########################################################################
1139                                                  
1140                                                  package DSNParser;
1141                                                  
1142           3                    3            21   use strict;
               3                                 12   
               3                                 16   
1143           3                    3            18   use warnings FATAL => 'all';
               3                                  7   
               3                                 15   
1144           3                    3            22   use English qw(-no_match_vars);
               3                                  8   
               3                                 16   
1145  ***      3            50      3            24   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               3                                  8   
               3                                 45   
1146                                                  
1147           3                    3            19   use Data::Dumper;
               3                                  8   
               3                                 29   
1148                                                  $Data::Dumper::Indent    = 0;
1149                                                  $Data::Dumper::Quotekeys = 0;
1150                                                  
1151                                                  eval {
1152                                                     require DBI;
1153                                                  };
1154                                                  my $have_dbi = $EVAL_ERROR ? 0 : 1;
1155                                                  
1156                                                  
1157                                                  sub new {
1158           9                    9           115      my ( $class, %args ) = @_;
1159           9                                 64      foreach my $arg ( qw(opts) ) {
1160  ***      9     50                          77         die "I need a $arg argument" unless $args{$arg};
1161                                                     }
1162           9                                 58      my $self = {
1163                                                        opts => {}  # h, P, u, etc.  Should come from DSN OPTIONS section in POD.
1164                                                     };
1165           9                                 30      foreach my $opt ( @{$args{opts}} ) {
               9                                 49   
1166  ***     81     50     33                  720         if ( !$opt->{key} || !$opt->{desc} ) {
1167  ***      0                                  0            die "Invalid DSN option: ", Dumper($opt);
1168                                                        }
1169                                                        MKDEBUG && _d('DSN option:',
1170                                                           join(', ',
1171          81                                176               map { "$_=" . (defined $opt->{$_} ? ($opt->{$_} || '') : 'undef') }
1172                                                                 keys %$opt
1173                                                           )
1174                                                        );
1175          81           100                  754         $self->{opts}->{$opt->{key}} = {
1176                                                           dsn  => $opt->{dsn},
1177                                                           desc => $opt->{desc},
1178                                                           copy => $opt->{copy} || 0,
1179                                                        };
1180                                                     }
1181           9                                174      return bless $self, $class;
1182                                                  }
1183                                                  
1184                                                  sub prop {
1185          39                   39           180      my ( $self, $prop, $value ) = @_;
1186          39    100                         178      if ( @_ > 2 ) {
1187           5                                 13         MKDEBUG && _d('Setting', $prop, 'property');
1188           5                                 21         $self->{$prop} = $value;
1189                                                     }
1190          39                                253      return $self->{$prop};
1191                                                  }
1192                                                  
1193                                                  sub parse {
1194          13                   13           385      my ( $self, $dsn, $prev, $defaults ) = @_;
1195  ***     13     50                          56      if ( !$dsn ) {
1196  ***      0                                  0         MKDEBUG && _d('No DSN to parse');
1197  ***      0                                  0         return;
1198                                                     }
1199          13                                 32      MKDEBUG && _d('Parsing', $dsn);
1200          13           100                   68      $prev     ||= {};
1201  ***     13            50                   59      $defaults ||= {};
1202          13                                 34      my %given_props;
1203          13                                 40      my %final_props;
1204          13                                 44      my $opts = $self->{opts};
1205                                                  
1206          13                                 83      foreach my $dsn_part ( split(/,/, $dsn) ) {
1207  ***     27     50                         234         if ( my ($prop_key, $prop_val) = $dsn_part =~  m/^(.)=(.*)$/ ) {
1208          27                                151            $given_props{$prop_key} = $prop_val;
1209                                                        }
1210                                                        else {
1211  ***      0                                  0            MKDEBUG && _d('Interpreting', $dsn_part, 'as h=', $dsn_part);
1212  ***      0                                  0            $given_props{h} = $dsn_part;
1213                                                        }
1214                                                     }
1215                                                  
1216          13                                 70      foreach my $key ( keys %$opts ) {
1217         117                                256         MKDEBUG && _d('Finding value for', $key);
1218         117                                399         $final_props{$key} = $given_props{$key};
1219         117    100    100                 1023         if (   !defined $final_props{$key}
      ***                   66                        
1220                                                             && defined $prev->{$key} && $opts->{$key}->{copy} )
1221                                                        {
1222           5                                 28            $final_props{$key} = $prev->{$key};
1223           5                                 11            MKDEBUG && _d('Copying value for', $key, 'from previous DSN');
1224                                                        }
1225         117    100                         493         if ( !defined $final_props{$key} ) {
1226          85                                274            $final_props{$key} = $defaults->{$key};
1227          85                                240            MKDEBUG && _d('Copying value for', $key, 'from defaults');
1228                                                        }
1229                                                     }
1230                                                  
1231          13                                 68      foreach my $key ( keys %given_props ) {
1232  ***     27     50                         129         die "Unknown DSN option '$key' in '$dsn'.  For more details, "
1233                                                              . "please use the --help option, or try 'perldoc $PROGRAM_NAME' "
1234                                                              . "for complete documentation."
1235                                                           unless exists $opts->{$key};
1236                                                     }
1237  ***     13     50                          63      if ( (my $required = $self->prop('required')) ) {
1238  ***      0                                  0         foreach my $key ( keys %$required ) {
1239  ***      0      0                           0            die "Missing required DSN option '$key' in '$dsn'.  For more details, "
1240                                                                 . "please use the --help option, or try 'perldoc $PROGRAM_NAME' "
1241                                                                 . "for complete documentation."
1242                                                              unless $final_props{$key};
1243                                                        }
1244                                                     }
1245                                                  
1246          13                                 78      return \%final_props;
1247                                                  }
1248                                                  
1249                                                  sub parse_options {
1250           5                    5            22      my ( $self, $o ) = @_;
1251  ***      5     50                          27      die 'I need an OptionParser object' unless ref $o eq 'OptionParser';
1252           5                                 26      my $dsn_string
1253                                                        = join(',',
1254          45    100                         165             map  { "$_=".$o->get($_); }
1255           5                                 41             grep { $o->has($_) && $o->get($_) }
1256           5                                 19             keys %{$self->{opts}}
1257                                                          );
1258           5                                 22      MKDEBUG && _d('DSN string made from options:', $dsn_string);
1259           5                                 25      return $self->parse($dsn_string);
1260                                                  }
1261                                                  
1262                                                  sub as_string {
1263  ***      0                    0             0      my ( $self, $dsn, $props ) = @_;
1264  ***      0      0                           0      return $dsn unless ref $dsn;
1265  ***      0      0                           0      my %allowed = $props ? map { $_=>1 } @$props : ();
      ***      0                                  0   
1266  ***      0      0                           0      return join(',',
1267  ***      0      0                           0         map  { "$_=" . ($_ eq 'p' ? '...' : $dsn->{$_})  }
1268  ***      0      0                           0         grep { defined $dsn->{$_} && $self->{opts}->{$_} }
1269  ***      0                                  0         grep { !$props || $allowed{$_}                   }
1270                                                        sort keys %$dsn );
1271                                                  }
1272                                                  
1273                                                  sub usage {
1274  ***      0                    0             0      my ( $self ) = @_;
1275  ***      0                                  0      my $usage
1276                                                        = "DSN syntax is key=value[,key=value...]  Allowable DSN keys:\n\n"
1277                                                        . "  KEY  COPY  MEANING\n"
1278                                                        . "  ===  ====  =============================================\n";
1279  ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
1280  ***      0                                  0      foreach my $key ( sort keys %opts ) {
1281  ***      0      0      0                    0         $usage .= "  $key    "
1282                                                               .  ($opts{$key}->{copy} ? 'yes   ' : 'no    ')
1283                                                               .  ($opts{$key}->{desc} || '[No description]')
1284                                                               . "\n";
1285                                                     }
1286  ***      0                                  0      $usage .= "\n  If the DSN is a bareword, the word is treated as the 'h' key.\n";
1287  ***      0                                  0      return $usage;
1288                                                  }
1289                                                  
1290                                                  sub get_cxn_params {
1291           8                    8            65      my ( $self, $info ) = @_;
1292           8                                 23      my $dsn;
1293           8                                 20      my %opts = %{$self->{opts}};
               8                                 85   
1294  ***      8            50                   51      my $driver = $self->prop('dbidriver') || '';
1295  ***      8     50                          40      if ( $driver eq 'Pg' ) {
1296  ***      0                                  0         $dsn = 'DBI:Pg:dbname=' . ( $info->{D} || '' ) . ';'
1297  ***      0                                  0            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
1298  ***      0             0                    0                        grep { defined $info->{$_} }
1299                                                                       qw(h P));
1300                                                     }
1301                                                     else {
1302          11                                 94         $dsn = 'DBI:mysql:' . ( $info->{D} || '' ) . ';'
1303          40                                169            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
1304           8           100                  101                        grep { defined $info->{$_} }
1305                                                                       qw(F h P S A))
1306                                                           . ';mysql_read_default_group=client';
1307                                                     }
1308           8                                 31      MKDEBUG && _d($dsn);
1309           8                                 81      return ($dsn, $info->{u}, $info->{p});
1310                                                  }
1311                                                  
1312                                                  sub fill_in_dsn {
1313  ***      0                    0             0      my ( $self, $dbh, $dsn ) = @_;
1314  ***      0                                  0      my $vars = $dbh->selectall_hashref('SHOW VARIABLES', 'Variable_name');
1315  ***      0                                  0      my ($user, $db) = $dbh->selectrow_array('SELECT USER(), DATABASE()');
1316  ***      0                                  0      $user =~ s/@.*//;
1317  ***      0             0                    0      $dsn->{h} ||= $vars->{hostname}->{Value};
1318  ***      0             0                    0      $dsn->{S} ||= $vars->{'socket'}->{Value};
1319  ***      0             0                    0      $dsn->{P} ||= $vars->{port}->{Value};
1320  ***      0             0                    0      $dsn->{u} ||= $user;
1321  ***      0             0                    0      $dsn->{D} ||= $db;
1322                                                  }
1323                                                  
1324                                                  sub get_dbh {
1325           8                    8            52      my ( $self, $cxn_string, $user, $pass, $opts ) = @_;
1326  ***      8            50                   38      $opts ||= {};
1327  ***      8     50                          96      my $defaults = {
1328                                                        AutoCommit         => 0,
1329                                                        RaiseError         => 1,
1330                                                        PrintError         => 0,
1331                                                        ShowErrorStatement => 1,
1332                                                        mysql_enable_utf8 => ($cxn_string =~ m/charset=utf8/ ? 1 : 0),
1333                                                     };
1334           8                                 41      @{$defaults}{ keys %$opts } = values %$opts;
               8                                 33   
1335                                                  
1336  ***      8     50                          42      if ( $opts->{mysql_use_result} ) {
1337  ***      0                                  0         $defaults->{mysql_use_result} = 1;
1338                                                     }
1339                                                  
1340  ***      8     50                          39      if ( !$have_dbi ) {
1341  ***      0                                  0         die "Cannot connect to MySQL because the Perl DBI module is not "
1342                                                           . "installed or not found.  Run 'perl -MDBI' to see the directories "
1343                                                           . "that Perl searches for DBI.  If DBI is not installed, try:\n"
1344                                                           . "  Debian/Ubuntu  apt-get install libdbi-perl\n"
1345                                                           . "  RHEL/CentOS    yum install perl-DBI\n"
1346                                                           . "  OpenSolaris    pgk install pkg:/SUNWpmdbi\n";
1347                                                  
1348                                                     }
1349                                                  
1350           8                                 22      my $dbh;
1351           8                                 28      my $tries = 2;
1352  ***      8            66                  119      while ( !$dbh && $tries-- ) {
1353                                                        MKDEBUG && _d($cxn_string, ' ', $user, ' ', $pass, ' {',
1354           8                                 23            join(', ', map { "$_=>$defaults->{$_}" } keys %$defaults ), '}');
1355                                                  
1356           8                                 31         eval {
1357           8                                 94            $dbh = DBI->connect($cxn_string, $user, $pass, $defaults);
1358                                                  
1359  ***      8     50                          85            if ( $cxn_string =~ m/mysql/i ) {
1360           8                                 23               my $sql;
1361                                                  
1362           8                                 30               $sql = 'SELECT @@SQL_MODE';
1363           8                                 18               MKDEBUG && _d($dbh, $sql);
1364           8                                 23               my ($sql_mode) = $dbh->selectrow_array($sql);
1365                                                  
1366  ***      8     50                        1258               $sql = 'SET @@SQL_QUOTE_SHOW_CREATE = 1'
1367                                                                   . '/*!40101, @@SQL_MODE=\'NO_AUTO_VALUE_ON_ZERO'
1368                                                                   . ($sql_mode ? ",$sql_mode" : '')
1369                                                                   . '\'*/';
1370           8                                 23               MKDEBUG && _d($dbh, $sql);
1371           8                                654               $dbh->do($sql);
1372                                                  
1373  ***      8     50                          75               if ( my ($charset) = $cxn_string =~ m/charset=(\w+)/ ) {
1374  ***      0                                  0                  $sql = "/*!40101 SET NAMES $charset*/";
1375  ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
1376  ***      0                                  0                  $dbh->do($sql);
1377  ***      0                                  0                  MKDEBUG && _d('Enabling charset for STDOUT');
1378  ***      0      0                           0                  if ( $charset eq 'utf8' ) {
1379  ***      0      0                           0                     binmode(STDOUT, ':utf8')
1380                                                                       or die "Can't binmode(STDOUT, ':utf8'): $OS_ERROR";
1381                                                                 }
1382                                                                 else {
1383  ***      0      0                           0                     binmode(STDOUT) or die "Can't binmode(STDOUT): $OS_ERROR";
1384                                                                 }
1385                                                              }
1386                                                  
1387           8    100                          49               if ( $self->prop('set-vars') ) {
1388           5                                 26                  $sql = "SET " . $self->prop('set-vars');
1389           5                                 14                  MKDEBUG && _d($dbh, ':', $sql);
1390           5                                237                  $dbh->do($sql);
1391                                                              }
1392                                                           }
1393                                                        };
1394  ***      8     50     33                   90         if ( !$dbh && $EVAL_ERROR ) {
1395  ***      0                                  0            MKDEBUG && _d($EVAL_ERROR);
1396  ***      0      0                           0            if ( $EVAL_ERROR =~ m/not a compiled character set|character set utf8/ ) {
      ***             0                               
1397  ***      0                                  0               MKDEBUG && _d('Going to try again without utf8 support');
1398  ***      0                                  0               delete $defaults->{mysql_enable_utf8};
1399                                                           }
1400                                                           elsif ( $EVAL_ERROR =~ m/locate DBD\/mysql/i ) {
1401  ***      0                                  0               die "Cannot connect to MySQL because the Perl DBD::mysql module is "
1402                                                                 . "not installed or not found.  Run 'perl -MDBD::mysql' to see "
1403                                                                 . "the directories that Perl searches for DBD::mysql.  If "
1404                                                                 . "DBD::mysql is not installed, try:\n"
1405                                                                 . "  Debian/Ubuntu  apt-get install libdbd-mysql-perl\n"
1406                                                                 . "  RHEL/CentOS    yum install perl-DBD-MySQL\n"
1407                                                                 . "  OpenSolaris    pgk install pkg:/SUNWapu13dbd-mysql\n";
1408                                                           }
1409  ***      0      0                           0            if ( !$tries ) {
1410  ***      0                                  0               die $EVAL_ERROR;
1411                                                           }
1412                                                        }
1413                                                     }
1414                                                  
1415           8                                 17      MKDEBUG && _d('DBH info: ',
1416                                                        $dbh,
1417                                                        Dumper($dbh->selectrow_hashref(
1418                                                           'SELECT DATABASE(), CONNECTION_ID(), VERSION()/*!50038 , @@hostname*/')),
1419                                                        'Connection info:',      $dbh->{mysql_hostinfo},
1420                                                        'Character set info:',   Dumper($dbh->selectall_arrayref(
1421                                                                       'SHOW VARIABLES LIKE "character_set%"', { Slice => {}})),
1422                                                        '$DBD::mysql::VERSION:', $DBD::mysql::VERSION,
1423                                                        '$DBI::VERSION:',        $DBI::VERSION,
1424                                                     );
1425                                                  
1426           8                                 49      return $dbh;
1427                                                  }
1428                                                  
1429                                                  sub get_hostname {
1430  ***      0                    0             0      my ( $self, $dbh ) = @_;
1431  ***      0      0      0                    0      if ( my ($host) = ($dbh->{mysql_hostinfo} || '') =~ m/^(\w+) via/ ) {
1432  ***      0                                  0         return $host;
1433                                                     }
1434  ***      0                                  0      my ( $hostname, $one ) = $dbh->selectrow_array(
1435                                                        'SELECT /*!50038 @@hostname, */ 1');
1436  ***      0                                  0      return $hostname;
1437                                                  }
1438                                                  
1439                                                  sub disconnect {
1440  ***      0                    0             0      my ( $self, $dbh ) = @_;
1441  ***      0                                  0      MKDEBUG && $self->print_active_handles($dbh);
1442  ***      0                                  0      $dbh->disconnect;
1443                                                  }
1444                                                  
1445                                                  sub print_active_handles {
1446  ***      0                    0             0      my ( $self, $thing, $level ) = @_;
1447  ***      0             0                    0      $level ||= 0;
1448  ***      0      0      0                    0      printf("# Active %sh: %s %s %s\n", ($thing->{Type} || 'undef'), "\t" x $level,
      ***             0      0                        
      ***                    0                        
1449                                                        $thing, (($thing->{Type} || '') eq 'st' ? $thing->{Statement} || '' : ''))
1450                                                        or die "Cannot print: $OS_ERROR";
1451  ***      0                                  0      foreach my $handle ( grep {defined} @{ $thing->{ChildHandles} } ) {
      ***      0                                  0   
      ***      0                                  0   
1452  ***      0                                  0         $self->print_active_handles( $handle, $level + 1 );
1453                                                     }
1454                                                  }
1455                                                  
1456                                                  sub copy {
1457  ***      0                    0             0      my ( $self, $dsn_1, $dsn_2, %args ) = @_;
1458  ***      0      0                           0      die 'I need a dsn_1 argument' unless $dsn_1;
1459  ***      0      0                           0      die 'I need a dsn_2 argument' unless $dsn_2;
1460  ***      0                                  0      my %new_dsn = map {
1461  ***      0                                  0         my $key = $_;
1462  ***      0                                  0         my $val;
1463  ***      0      0                           0         if ( $args{overwrite} ) {
1464  ***      0      0                           0            $val = defined $dsn_1->{$key} ? $dsn_1->{$key} : $dsn_2->{$key};
1465                                                        }
1466                                                        else {
1467  ***      0      0                           0            $val = defined $dsn_2->{$key} ? $dsn_2->{$key} : $dsn_1->{$key};
1468                                                        }
1469  ***      0                                  0         $key => $val;
1470  ***      0                                  0      } keys %{$self->{opts}};
1471  ***      0                                  0      return \%new_dsn;
1472                                                  }
1473                                                  
1474                                                  sub _d {
1475  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1476  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1477  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1478                                                          @_;
1479  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1480                                                  }
1481                                                  
1482                                                  1;
1483                                                  
1484                                                  # ###########################################################################
1485                                                  # End DSNParser package
1486                                                  # ###########################################################################
1487                                                  
1488                                                  # ###########################################################################
1489                                                  # Daemon package 6255
1490                                                  # This package is a copy without comments from the original.  The original
1491                                                  # with comments and its test file can be found in the SVN repository at,
1492                                                  #   trunk/common/Daemon.pm
1493                                                  #   trunk/common/t/Daemon.t
1494                                                  # See http://code.google.com/p/maatkit/wiki/Developers for more information.
1495                                                  # ###########################################################################
1496                                                  
1497                                                  package Daemon;
1498                                                  
1499           3                    3           272   use strict;
               3                                  7   
               3                                 17   
1500           3                    3            21   use warnings FATAL => 'all';
               3                                  7   
               3                                502   
1501                                                  
1502           3                    3            18   use POSIX qw(setsid);
               3                                  6   
               3                                 20   
1503           3                    3            18   use English qw(-no_match_vars);
               3                                  6   
               3                                 17   
1504                                                  
1505  ***      3            50      3            18   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               3                                  8   
               3                                 42   
1506                                                  
1507                                                  sub new {
1508  ***      0                    0             0      my ( $class, %args ) = @_;
1509  ***      0                                  0      foreach my $arg ( qw(o) ) {
1510  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
1511                                                     }
1512  ***      0                                  0      my $o = $args{o};
1513  ***      0      0                           0      my $self = {
      ***             0                               
1514                                                        o        => $o,
1515                                                        log_file => $o->has('log') ? $o->get('log') : undef,
1516                                                        PID_file => $o->has('pid') ? $o->get('pid') : undef,
1517                                                     };
1518                                                  
1519  ***      0                                  0      check_PID_file(undef, $self->{PID_file});
1520                                                  
1521  ***      0                                  0      MKDEBUG && _d('Daemonized child will log to', $self->{log_file});
1522  ***      0                                  0      return bless $self, $class;
1523                                                  }
1524                                                  
1525                                                  sub daemonize {
1526  ***      0                    0             0      my ( $self ) = @_;
1527                                                  
1528  ***      0                                  0      MKDEBUG && _d('About to fork and daemonize');
1529  ***      0      0                           0      defined (my $pid = fork()) or die "Cannot fork: $OS_ERROR";
1530  ***      0      0                           0      if ( $pid ) {
1531  ***      0                                  0         MKDEBUG && _d('I am the parent and now I die');
1532  ***      0                                  0         exit;
1533                                                     }
1534                                                  
1535  ***      0                                  0      $self->{PID_owner} = $PID;
1536  ***      0                                  0      $self->{child}     = 1;
1537                                                  
1538  ***      0      0                           0      POSIX::setsid() or die "Cannot start a new session: $OS_ERROR";
1539  ***      0      0                           0      chdir '/'       or die "Cannot chdir to /: $OS_ERROR";
1540                                                  
1541  ***      0                                  0      $self->_make_PID_file();
1542                                                  
1543  ***      0                                  0      $OUTPUT_AUTOFLUSH = 1;
1544                                                  
1545  ***      0      0                           0      if ( -t STDIN ) {
1546  ***      0                                  0         close STDIN;
1547  ***      0      0                           0         open  STDIN, '/dev/null'
1548                                                           or die "Cannot reopen STDIN to /dev/null: $OS_ERROR";
1549                                                     }
1550                                                  
1551  ***      0      0                           0      if ( $self->{log_file} ) {
1552  ***      0                                  0         close STDOUT;
1553  ***      0      0                           0         open  STDOUT, '>>', $self->{log_file}
1554                                                           or die "Cannot open log file $self->{log_file}: $OS_ERROR";
1555                                                  
1556  ***      0                                  0         close STDERR;
1557  ***      0      0                           0         open  STDERR, ">&STDOUT"
1558                                                           or die "Cannot dupe STDERR to STDOUT: $OS_ERROR"; 
1559                                                     }
1560                                                     else {
1561  ***      0      0                           0         if ( -t STDOUT ) {
1562  ***      0                                  0            close STDOUT;
1563  ***      0      0                           0            open  STDOUT, '>', '/dev/null'
1564                                                              or die "Cannot reopen STDOUT to /dev/null: $OS_ERROR";
1565                                                        }
1566  ***      0      0                           0         if ( -t STDERR ) {
1567  ***      0                                  0            close STDERR;
1568  ***      0      0                           0            open  STDERR, '>', '/dev/null'
1569                                                              or die "Cannot reopen STDERR to /dev/null: $OS_ERROR";
1570                                                        }
1571                                                     }
1572                                                  
1573  ***      0                                  0      MKDEBUG && _d('I am the child and now I live daemonized');
1574  ***      0                                  0      return;
1575                                                  }
1576                                                  
1577                                                  sub check_PID_file {
1578  ***      0                    0             0      my ( $self, $file ) = @_;
1579  ***      0      0                           0      my $PID_file = $self ? $self->{PID_file} : $file;
1580  ***      0                                  0      MKDEBUG && _d('Checking PID file', $PID_file);
1581  ***      0      0      0                    0      if ( $PID_file && -f $PID_file ) {
1582  ***      0                                  0         my $pid;
1583  ***      0                                  0         eval { chomp($pid = `cat $PID_file`); };
      ***      0                                  0   
1584  ***      0      0                           0         die "Cannot cat $PID_file: $OS_ERROR" if $EVAL_ERROR;
1585  ***      0                                  0         MKDEBUG && _d('PID file exists; it contains PID', $pid);
1586  ***      0      0                           0         if ( $pid ) {
1587  ***      0                                  0            my $pid_is_alive = kill 0, $pid;
1588  ***      0      0                           0            if ( $pid_is_alive ) {
1589  ***      0                                  0               die "The PID file $PID_file already exists "
1590                                                                 . " and the PID that it contains, $pid, is running";
1591                                                           }
1592                                                           else {
1593  ***      0                                  0               warn "Overwriting PID file $PID_file because the PID that it "
1594                                                                 . "contains, $pid, is not running";
1595                                                           }
1596                                                        }
1597                                                        else {
1598  ***      0                                  0            die "The PID file $PID_file already exists but it does not "
1599                                                              . "contain a PID";
1600                                                        }
1601                                                     }
1602                                                     else {
1603  ***      0                                  0         MKDEBUG && _d('No PID file');
1604                                                     }
1605  ***      0                                  0      return;
1606                                                  }
1607                                                  
1608                                                  sub make_PID_file {
1609  ***      0                    0             0      my ( $self ) = @_;
1610  ***      0      0                           0      if ( exists $self->{child} ) {
1611  ***      0                                  0         die "Do not call Daemon::make_PID_file() for daemonized scripts";
1612                                                     }
1613  ***      0                                  0      $self->_make_PID_file();
1614  ***      0                                  0      $self->{PID_owner} = $PID;
1615  ***      0                                  0      return;
1616                                                  }
1617                                                  
1618                                                  sub _make_PID_file {
1619  ***      0                    0             0      my ( $self ) = @_;
1620                                                  
1621  ***      0                                  0      my $PID_file = $self->{PID_file};
1622  ***      0      0                           0      if ( !$PID_file ) {
1623  ***      0                                  0         MKDEBUG && _d('No PID file to create');
1624  ***      0                                  0         return;
1625                                                     }
1626                                                  
1627  ***      0                                  0      $self->check_PID_file();
1628                                                  
1629  ***      0      0                           0      open my $PID_FH, '>', $PID_file
1630                                                        or die "Cannot open PID file $PID_file: $OS_ERROR";
1631  ***      0      0                           0      print $PID_FH $PID
1632                                                        or die "Cannot print to PID file $PID_file: $OS_ERROR";
1633  ***      0      0                           0      close $PID_FH
1634                                                        or die "Cannot close PID file $PID_file: $OS_ERROR";
1635                                                  
1636  ***      0                                  0      MKDEBUG && _d('Created PID file:', $self->{PID_file});
1637  ***      0                                  0      return;
1638                                                  }
1639                                                  
1640                                                  sub _remove_PID_file {
1641  ***      0                    0             0      my ( $self ) = @_;
1642  ***      0      0      0                    0      if ( $self->{PID_file} && -f $self->{PID_file} ) {
1643  ***      0      0                           0         unlink $self->{PID_file}
1644                                                           or warn "Cannot remove PID file $self->{PID_file}: $OS_ERROR";
1645  ***      0                                  0         MKDEBUG && _d('Removed PID file');
1646                                                     }
1647                                                     else {
1648  ***      0                                  0         MKDEBUG && _d('No PID to remove');
1649                                                     }
1650  ***      0                                  0      return;
1651                                                  }
1652                                                  
1653                                                  sub DESTROY {
1654  ***      0                    0             0      my ( $self ) = @_;
1655                                                  
1656  ***      0      0      0                    0      $self->_remove_PID_file() if ($self->{PID_owner} || 0) == $PID;
1657                                                  
1658  ***      0                                  0      return;
1659                                                  }
1660                                                  
1661                                                  sub _d {
1662  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1663  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1664  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1665                                                          @_;
1666  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1667                                                  }
1668                                                  
1669                                                  1;
1670                                                  
1671                                                  # ###########################################################################
1672                                                  # End Daemon package
1673                                                  # ###########################################################################
1674                                                  
1675                                                  # ###########################################################################
1676                                                  # Quoter package 6850
1677                                                  # This package is a copy without comments from the original.  The original
1678                                                  # with comments and its test file can be found in the SVN repository at,
1679                                                  #   trunk/common/Quoter.pm
1680                                                  #   trunk/common/t/Quoter.t
1681                                                  # See http://code.google.com/p/maatkit/wiki/Developers for more information.
1682                                                  # ###########################################################################
1683                                                  
1684                                                  package Quoter;
1685                                                  
1686           3                    3            19   use strict;
               3                                  8   
               3                                 15   
1687           3                    3            17   use warnings FATAL => 'all';
               3                                  6   
               3                                 19   
1688           3                    3            17   use English qw(-no_match_vars);
               3                                  7   
               3                                 14   
1689                                                  
1690  ***      3            50      3            18   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               3                                  6   
               3                                 52   
1691                                                  
1692                                                  sub new {
1693           6                    6            45      my ( $class, %args ) = @_;
1694           6                                 59      return bless {}, $class;
1695                                                  }
1696                                                  
1697                                                  sub quote {
1698          82                   82           426      my ( $self, @vals ) = @_;
1699          82                                298      foreach my $val ( @vals ) {
1700         123                                479         $val =~ s/`/``/g;
1701                                                     }
1702          82                                292      return join('.', map { '`' . $_ . '`' } @vals);
             123                                708   
1703                                                  }
1704                                                  
1705                                                  sub quote_val {
1706          10                   10            40      my ( $self, $val ) = @_;
1707                                                  
1708  ***     10     50                          41      return 'NULL' unless defined $val;          # undef = NULL
1709  ***     10     50                          35      return "''" if $val eq '';                  # blank string = ''
1710  ***     10     50                          40      return $val if $val =~ m/^0x[0-9a-fA-F]+$/;  # hex data
1711                                                  
1712          10                                 30      $val =~ s/(['\\])/\\$1/g;
1713          10                                 72      return "'$val'";
1714                                                  }
1715                                                  
1716                                                  sub split_unquote {
1717          44                   44           200      my ( $self, $db_tbl, $default_db ) = @_;
1718          44                                232      $db_tbl =~ s/`//g;
1719          44                                221      my ( $db, $tbl ) = split(/[.]/, $db_tbl);
1720          44    100                        6599      if ( !$tbl ) {
1721          15                                 44         $tbl = $db;
1722          15                                 42         $db  = $default_db;
1723                                                     }
1724          44                                229      return ($db, $tbl);
1725                                                  }
1726                                                  
1727                                                  sub literal_like {
1728          27                   27           117      my ( $self, $like ) = @_;
1729  ***     27     50                         112      return unless $like;
1730          27                                255      $like =~ s/([%_])/\\$1/g;
1731          27                                152      return "'$like'";
1732                                                  }
1733                                                  
1734                                                  sub join_quote {
1735          15                   15            66      my ( $self, $default_db, $db_tbl ) = @_;
1736  ***     15     50                          59      return unless $db_tbl;
1737          15                                 73      my ($db, $tbl) = split(/[.]/, $db_tbl);
1738  ***     15     50                          55      if ( !$tbl ) {
1739          15                                 45         $tbl = $db;
1740          15                                 41         $db  = $default_db;
1741                                                     }
1742  ***     15     50     33                  142      $db  = "`$db`"  if $db  && $db  !~ m/^`/;
1743  ***     15     50     33                  135      $tbl = "`$tbl`" if $tbl && $tbl !~ m/^`/;
1744  ***     15     50                         130      return $db ? "$db.$tbl" : $tbl;
1745                                                  }
1746                                                  
1747                                                  1;
1748                                                  
1749                                                  # ###########################################################################
1750                                                  # End Quoter package
1751                                                  # ###########################################################################
1752                                                  
1753                                                  # ###########################################################################
1754                                                  # Transformers package 7226
1755                                                  # This package is a copy without comments from the original.  The original
1756                                                  # with comments and its test file can be found in the SVN repository at,
1757                                                  #   trunk/common/Transformers.pm
1758                                                  #   trunk/common/t/Transformers.t
1759                                                  # See http://code.google.com/p/maatkit/wiki/Developers for more information.
1760                                                  # ###########################################################################
1761                                                  
1762                                                  package Transformers;
1763                                                  
1764           3                    3            24   use strict;
               3                                  8   
               3                                 17   
1765           3                    3            23   use warnings FATAL => 'all';
               3                                 11   
               3                                 15   
1766           3                    3            18   use English qw(-no_match_vars);
               3                                  6   
               3                                 13   
1767           3                    3            37   use Time::Local qw(timegm timelocal);
               3                                  9   
               3                                 31   
1768           3                    3            20   use Digest::MD5 qw(md5_hex);
               3                                  8   
               3                                 20   
1769                                                  
1770  ***      3            50      3            20   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               3                                  7   
               3                                 40   
1771                                                  
1772                                                  require Exporter;
1773                                                  our @ISA         = qw(Exporter);
1774                                                  our %EXPORT_TAGS = ();
1775                                                  our @EXPORT      = ();
1776                                                  our @EXPORT_OK   = qw(
1777                                                     micro_t
1778                                                     percentage_of
1779                                                     secs_to_time
1780                                                     time_to_secs
1781                                                     shorten
1782                                                     ts
1783                                                     parse_timestamp
1784                                                     unix_timestamp
1785                                                     any_unix_timestamp
1786                                                     make_checksum
1787                                                     crc32
1788                                                  );
1789                                                  
1790                                                  our $mysql_ts  = qr/(\d\d)(\d\d)(\d\d) +(\d+):(\d+):(\d+)(\.\d+)?/;
1791                                                  our $proper_ts = qr/(\d\d\d\d)-(\d\d)-(\d\d)[T ](\d\d):(\d\d):(\d\d)(\.\d+)?/;
1792                                                  our $n_ts      = qr/(\d{1,5})([shmd]?)/; # Limit \d{1,5} because \d{6} looks
1793                                                  
1794                                                  sub micro_t {
1795  ***      0                    0             0      my ( $t, %args ) = @_;
1796  ***      0      0                           0      my $p_ms = defined $args{p_ms} ? $args{p_ms} : 0;  # precision for ms vals
1797  ***      0      0                           0      my $p_s  = defined $args{p_s}  ? $args{p_s}  : 0;  # precision for s vals
1798  ***      0                                  0      my $f;
1799                                                  
1800  ***      0      0                           0      $t = 0 if $t < 0;
1801                                                  
1802  ***      0      0                           0      $t = sprintf('%.17f', $t) if $t =~ /e/;
1803                                                  
1804  ***      0                                  0      $t =~ s/\.(\d{1,6})\d*/\.$1/;
1805                                                  
1806  ***      0      0      0                    0      if ($t > 0 && $t <= 0.000999) {
      ***             0      0                        
      ***             0                               
1807  ***      0                                  0         $f = ($t * 1000000) . 'us';
1808                                                     }
1809                                                     elsif ($t >= 0.001000 && $t <= 0.999999) {
1810  ***      0                                  0         $f = sprintf("%.${p_ms}f", $t * 1000);
1811  ***      0                                  0         $f = ($f * 1) . 'ms'; # * 1 to remove insignificant zeros
1812                                                     }
1813                                                     elsif ($t >= 1) {
1814  ***      0                                  0         $f = sprintf("%.${p_s}f", $t);
1815  ***      0                                  0         $f = ($f * 1) . 's'; # * 1 to remove insignificant zeros
1816                                                     }
1817                                                     else {
1818  ***      0                                  0         $f = 0;  # $t should = 0 at this point
1819                                                     }
1820                                                  
1821  ***      0                                  0      return $f;
1822                                                  }
1823                                                  
1824                                                  sub percentage_of {
1825  ***      0                    0             0      my ( $is, $of, %args ) = @_;
1826  ***      0             0                    0      my $p   = $args{p} || 0; # float precision
1827  ***      0      0                           0      my $fmt = $p ? "%.${p}f" : "%d";
1828  ***      0             0                    0      return sprintf $fmt, ($is * 100) / ($of ||= 1);
1829                                                  }
1830                                                  
1831                                                  sub secs_to_time {
1832  ***      0                    0             0      my ( $secs, $fmt ) = @_;
1833  ***      0             0                    0      $secs ||= 0;
1834  ***      0      0                           0      return '00:00' unless $secs;
1835                                                  
1836  ***      0      0      0                    0      $fmt ||= $secs >= 86_400 ? 'd'
      ***             0                               
1837                                                            : $secs >= 3_600  ? 'h'
1838                                                            :                   'm';
1839                                                  
1840                                                     return
1841  ***      0      0                           0         $fmt eq 'd' ? sprintf(
      ***             0                               
1842                                                           "%d+%02d:%02d:%02d",
1843                                                           int($secs / 86_400),
1844                                                           int(($secs % 86_400) / 3_600),
1845                                                           int(($secs % 3_600) / 60),
1846                                                           $secs % 60)
1847                                                        : $fmt eq 'h' ? sprintf(
1848                                                           "%02d:%02d:%02d",
1849                                                           int(($secs % 86_400) / 3_600),
1850                                                           int(($secs % 3_600) / 60),
1851                                                           $secs % 60)
1852                                                        : sprintf(
1853                                                           "%02d:%02d",
1854                                                           int(($secs % 3_600) / 60),
1855                                                           $secs % 60);
1856                                                  }
1857                                                  
1858                                                  sub time_to_secs {
1859  ***      0                    0             0      my ( $val, $default_suffix ) = @_;
1860  ***      0      0                           0      die "I need a val argument" unless defined $val;
1861  ***      0                                  0      my $t = 0;
1862  ***      0                                  0      my ( $prefix, $num, $suffix ) = $val =~ m/([+-]?)(\d+)([a-z])?$/;
1863  ***      0             0                    0      $suffix = $suffix || $default_suffix || 's';
      ***                    0                        
1864  ***      0      0                           0      if ( $suffix =~ m/[smhd]/ ) {
1865  ***      0      0                           0         $t = $suffix eq 's' ? $num * 1        # Seconds
      ***             0                               
      ***             0                               
1866                                                           : $suffix eq 'm' ? $num * 60       # Minutes
1867                                                           : $suffix eq 'h' ? $num * 3600     # Hours
1868                                                           :                  $num * 86400;   # Days
1869                                                  
1870  ***      0      0      0                    0         $t *= -1 if $prefix && $prefix eq '-';
1871                                                     }
1872                                                     else {
1873  ***      0                                  0         die "Invalid suffix for $val: $suffix";
1874                                                     }
1875  ***      0                                  0      return $t;
1876                                                  }
1877                                                  
1878                                                  sub shorten {
1879  ***      0                    0             0      my ( $num, %args ) = @_;
1880  ***      0      0                           0      my $p = defined $args{p} ? $args{p} : 2;     # float precision
1881  ***      0      0                           0      my $d = defined $args{d} ? $args{d} : 1_024; # divisor
1882  ***      0                                  0      my $n = 0;
1883  ***      0                                  0      my @units = ('', qw(k M G T P E Z Y));
1884  ***      0             0                    0      while ( $num >= $d && $n < @units - 1 ) {
1885  ***      0                                  0         $num /= $d;
1886  ***      0                                  0         ++$n;
1887                                                     }
1888  ***      0      0      0                    0      return sprintf(
1889                                                        $num =~ m/\./ || $n
1890                                                           ? "%.${p}f%s"
1891                                                           : '%d',
1892                                                        $num, $units[$n]);
1893                                                  }
1894                                                  
1895                                                  sub ts {
1896          73                   73           296      my ( $time, $gmt ) = @_;
1897  ***     73     50                        1144      my ( $sec, $min, $hour, $mday, $mon, $year )
1898                                                        = $gmt ? gmtime($time) : localtime($time);
1899          73                                286      $mon  += 1;
1900          73                                212      $year += 1900;
1901          73                                540      my $val = sprintf("%d-%02d-%02dT%02d:%02d:%02d",
1902                                                        $year, $mon, $mday, $hour, $min, $sec);
1903  ***     73     50                         466      if ( my ($us) = $time =~ m/(\.\d+)$/ ) {
1904  ***      0                                  0         $us = sprintf("%.6f", $us);
1905  ***      0                                  0         $us =~ s/^0\././;
1906  ***      0                                  0         $val .= $us;
1907                                                     }
1908          73                                641      return $val;
1909                                                  }
1910                                                  
1911                                                  sub parse_timestamp {
1912  ***      0                    0             0      my ( $val ) = @_;
1913  ***      0      0                           0      if ( my($y, $m, $d, $h, $i, $s, $f)
1914                                                           = $val =~ m/^$mysql_ts$/ )
1915                                                     {
1916  ***      0      0                           0         return sprintf "%d-%02d-%02d %02d:%02d:"
      ***             0                               
1917                                                                       . (defined $f ? '%09.6f' : '%02d'),
1918                                                                       $y + 2000, $m, $d, $h, $i, (defined $f ? $s + $f : $s);
1919                                                     }
1920  ***      0                                  0      return $val;
1921                                                  }
1922                                                  
1923                                                  sub unix_timestamp {
1924  ***      0                    0             0      my ( $val, $gmt ) = @_;
1925  ***      0      0                           0      if ( my($y, $m, $d, $h, $i, $s, $us) = $val =~ m/^$proper_ts$/ ) {
1926  ***      0      0                           0         $val = $gmt
1927                                                           ? timegm($s, $i, $h, $d, $m - 1, $y)
1928                                                           : timelocal($s, $i, $h, $d, $m - 1, $y);
1929  ***      0      0                           0         if ( defined $us ) {
1930  ***      0                                  0            $us = sprintf('%.6f', $us);
1931  ***      0                                  0            $us =~ s/^0\././;
1932  ***      0                                  0            $val .= $us;
1933                                                        }
1934                                                     }
1935  ***      0                                  0      return $val;
1936                                                  }
1937                                                  
1938                                                  sub any_unix_timestamp {
1939  ***      0                    0             0      my ( $val, $callback ) = @_;
1940                                                  
1941  ***      0      0                           0      if ( my ($n, $suffix) = $val =~ m/^$n_ts$/ ) {
      ***             0                               
      ***             0                               
      ***             0                               
1942  ***      0      0                           0         $n = $suffix eq 's' ? $n            # Seconds
      ***             0                               
      ***             0                               
      ***             0                               
1943                                                           : $suffix eq 'm' ? $n * 60       # Minutes
1944                                                           : $suffix eq 'h' ? $n * 3600     # Hours
1945                                                           : $suffix eq 'd' ? $n * 86400    # Days
1946                                                           :                  $n;           # default: Seconds
1947  ***      0                                  0         MKDEBUG && _d('ts is now - N[shmd]:', $n);
1948  ***      0                                  0         return time - $n;
1949                                                     }
1950                                                     elsif ( $val =~ m/^\d{9,}/ ) {
1951  ***      0                                  0         MKDEBUG && _d('ts is already a unix timestamp');
1952  ***      0                                  0         return $val;
1953                                                     }
1954                                                     elsif ( my ($ymd, $hms) = $val =~ m/^(\d{6})(?:\s+(\d+:\d+:\d+))?/ ) {
1955  ***      0                                  0         MKDEBUG && _d('ts is MySQL slow log timestamp');
1956  ***      0      0                           0         $val .= ' 00:00:00' unless $hms;
1957  ***      0                                  0         return unix_timestamp(parse_timestamp($val));
1958                                                     }
1959                                                     elsif ( ($ymd, $hms) = $val =~ m/^(\d{4}-\d\d-\d\d)(?:[T ](\d+:\d+:\d+))?/) {
1960  ***      0                                  0         MKDEBUG && _d('ts is properly formatted timestamp');
1961  ***      0      0                           0         $val .= ' 00:00:00' unless $hms;
1962  ***      0                                  0         return unix_timestamp($val);
1963                                                     }
1964                                                     else {
1965  ***      0                                  0         MKDEBUG && _d('ts is MySQL expression');
1966  ***      0      0      0                    0         return $callback->($val) if $callback && ref $callback eq 'CODE';
1967                                                     }
1968                                                  
1969  ***      0                                  0      MKDEBUG && _d('Unknown ts type:', $val);
1970  ***      0                                  0      return;
1971                                                  }
1972                                                  
1973                                                  sub make_checksum {
1974  ***      0                    0             0      my ( $val ) = @_;
1975  ***      0                                  0      my $checksum = uc substr(md5_hex($val), -16);
1976  ***      0                                  0      MKDEBUG && _d($checksum, 'checksum for', $val);
1977  ***      0                                  0      return $checksum;
1978                                                  }
1979                                                  
1980                                                  sub crc32 {
1981  ***      0                    0             0      my ( $string ) = @_;
1982  ***      0      0                           0      return unless $string;
1983  ***      0                                  0      my $poly = 0xEDB88320;
1984  ***      0                                  0      my $crc  = 0xFFFFFFFF;
1985  ***      0                                  0      foreach my $char ( split(//, $string) ) {
1986  ***      0                                  0         my $comp = ($crc ^ ord($char)) & 0xFF;
1987  ***      0                                  0         for ( 1 .. 8 ) {
1988  ***      0      0                           0            $comp = $comp & 1 ? $poly ^ ($comp >> 1) : $comp >> 1;
1989                                                        }
1990  ***      0                                  0         $crc = (($crc >> 8) & 0x00FFFFFF) ^ $comp;
1991                                                     }
1992  ***      0                                  0      return $crc ^ 0xFFFFFFFF;
1993                                                  }
1994                                                  
1995                                                  sub _d {
1996  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1997  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1998  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1999                                                          @_;
2000  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2001                                                  }
2002                                                  
2003                                                  1;
2004                                                  
2005                                                  # ###########################################################################
2006                                                  # End Transformers package
2007                                                  # ###########################################################################
2008                                                  
2009                                                  # ###########################################################################
2010                                                  # TableParser package 7156
2011                                                  # This package is a copy without comments from the original.  The original
2012                                                  # with comments and its test file can be found in the SVN repository at,
2013                                                  #   trunk/common/TableParser.pm
2014                                                  #   trunk/common/t/TableParser.t
2015                                                  # See http://code.google.com/p/maatkit/wiki/Developers for more information.
2016                                                  # ###########################################################################
2017                                                  
2018                                                  package TableParser;
2019                                                  
2020           3                    3            25   use strict;
               3                                  8   
               3                                 21   
2021           3                    3            19   use warnings FATAL => 'all';
               3                                 11   
               3                                 18   
2022           3                    3            17   use English qw(-no_match_vars);
               3                                  7   
               3                                 19   
2023           3                    3            23   use Data::Dumper;
               3                                  7   
               3                                 19   
2024                                                  $Data::Dumper::Indent    = 1;
2025                                                  $Data::Dumper::Sortkeys  = 1;
2026                                                  $Data::Dumper::Quotekeys = 0;
2027                                                  
2028  ***      3            50      3            19   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               3                                  7   
               3                                 44   
2029                                                  
2030                                                  sub new {
2031           6                    6            51      my ( $class, %args ) = @_;
2032           6                                 27      my @required_args = qw(Quoter);
2033           6                                 39      foreach my $arg ( @required_args ) {
2034  ***      6     50                          51         die "I need a $arg argument" unless $args{$arg};
2035                                                     }
2036           6                                 42      my $self = { %args };
2037           6                                 64      return bless $self, $class;
2038                                                  }
2039                                                  
2040                                                  sub parse {
2041          10                   10            52      my ( $self, $ddl, $opts ) = @_;
2042  ***     10     50                          45      return unless $ddl;
2043  ***     10     50                          66      if ( ref $ddl eq 'ARRAY' ) {
2044  ***     10     50                          57         if ( lc $ddl->[0] eq 'table' ) {
2045          10                                 41            $ddl = $ddl->[1];
2046                                                        }
2047                                                        else {
2048                                                           return {
2049  ***      0                                  0               engine => 'VIEW',
2050                                                           };
2051                                                        }
2052                                                     }
2053                                                  
2054  ***     10     50                         105      if ( $ddl !~ m/CREATE (?:TEMPORARY )?TABLE `/ ) {
2055  ***      0                                  0         die "Cannot parse table definition; is ANSI quoting "
2056                                                           . "enabled or SQL_QUOTE_SHOW_CREATE disabled?";
2057                                                     }
2058                                                  
2059          10                                108      my ($name)     = $ddl =~ m/CREATE (?:TEMPORARY )?TABLE\s+(`.+?`)/;
2060  ***     10     50                          86      (undef, $name) = $self->{Quoter}->split_unquote($name) if $name;
2061                                                  
2062          10                                213      $ddl =~ s/(`[^`]+`)/\L$1/g;
2063                                                  
2064          10                                 69      my $engine = $self->get_engine($ddl);
2065                                                  
2066          10                                203      my @defs   = $ddl =~ m/^(\s+`.*?),?$/gm;
2067          10                                 40      my @cols   = map { $_ =~ m/`([^`]+)`/ } @defs;
              29                                163   
2068          10                                 27      MKDEBUG && _d('Table cols:', join(', ', map { "`$_`" } @cols));
2069                                                  
2070          10                                 29      my %def_for;
2071          10                                 74      @def_for{@cols} = @defs;
2072                                                  
2073          10                                 32      my (@nums, @null);
2074          10                                 31      my (%type_for, %is_nullable, %is_numeric, %is_autoinc);
2075          10                                 50      foreach my $col ( @cols ) {
2076          29                                 89         my $def = $def_for{$col};
2077          29                                188         my ( $type ) = $def =~ m/`[^`]+`\s([a-z]+)/;
2078  ***     29     50                         116         die "Can't determine column type for $def" unless $type;
2079          29                                101         $type_for{$col} = $type;
2080          29    100                         186         if ( $type =~ m/(?:(?:tiny|big|medium|small)?int|float|double|decimal|year)/ ) {
2081           9                                 36            push @nums, $col;
2082           9                                 36            $is_numeric{$col} = 1;
2083                                                        }
2084          29    100                         147         if ( $def !~ m/NOT NULL/ ) {
2085          20                                 67            push @null, $col;
2086          20                                 68            $is_nullable{$col} = 1;
2087                                                        }
2088          29    100                         176         $is_autoinc{$col} = $def =~ m/AUTO_INCREMENT/i ? 1 : 0;
2089                                                     }
2090                                                  
2091          10                                 84      my ($keys, $clustered_key) = $self->get_keys($ddl, $opts, \%is_nullable);
2092                                                  
2093          10                                 80      my ($charset) = $ddl =~ m/DEFAULT CHARSET=(\w+)/;
2094                                                  
2095                                                     return {
2096          29                                147         name           => $name,
2097                                                        cols           => \@cols,
2098          29                                313         col_posn       => { map { $cols[$_] => $_ } 0..$#cols },
2099          10                                100         is_col         => { map { $_ => 1 } @cols },
2100                                                        null_cols      => \@null,
2101                                                        is_nullable    => \%is_nullable,
2102                                                        is_autoinc     => \%is_autoinc,
2103                                                        clustered_key  => $clustered_key,
2104                                                        keys           => $keys,
2105                                                        defs           => \%def_for,
2106                                                        numeric_cols   => \@nums,
2107                                                        is_numeric     => \%is_numeric,
2108                                                        engine         => $engine,
2109                                                        type_for       => \%type_for,
2110                                                        charset        => $charset,
2111                                                     };
2112                                                  }
2113                                                  
2114                                                  sub sort_indexes {
2115  ***      0                    0             0      my ( $self, $tbl ) = @_;
2116                                                  
2117                                                     my @indexes
2118  ***      0                                  0         = sort {
2119  ***      0                                  0            (($a ne 'PRIMARY') <=> ($b ne 'PRIMARY'))
2120                                                           || ( !$tbl->{keys}->{$a}->{is_unique} <=> !$tbl->{keys}->{$b}->{is_unique} )
2121                                                           || ( $tbl->{keys}->{$a}->{is_nullable} <=> $tbl->{keys}->{$b}->{is_nullable} )
2122  ***      0      0      0                    0            || ( scalar(@{$tbl->{keys}->{$a}->{cols}}) <=> scalar(@{$tbl->{keys}->{$b}->{cols}}) )
      ***      0             0                    0   
2123                                                        }
2124                                                        grep {
2125  ***      0                                  0            $tbl->{keys}->{$_}->{type} eq 'BTREE'
2126                                                        }
2127  ***      0                                  0         sort keys %{$tbl->{keys}};
2128                                                  
2129  ***      0                                  0      MKDEBUG && _d('Indexes sorted best-first:', join(', ', @indexes));
2130  ***      0                                  0      return @indexes;
2131                                                  }
2132                                                  
2133                                                  sub find_best_index {
2134  ***      0                    0             0      my ( $self, $tbl, $index ) = @_;
2135  ***      0                                  0      my $best;
2136  ***      0      0                           0      if ( $index ) {
2137  ***      0                                  0         ($best) = grep { uc $_ eq uc $index } keys %{$tbl->{keys}};
      ***      0                                  0   
      ***      0                                  0   
2138                                                     }
2139  ***      0      0                           0      if ( !$best ) {
2140  ***      0      0                           0         if ( $index ) {
2141  ***      0                                  0            die "Index '$index' does not exist in table";
2142                                                        }
2143                                                        else {
2144  ***      0                                  0            ($best) = $self->sort_indexes($tbl);
2145                                                        }
2146                                                     }
2147  ***      0                                  0      MKDEBUG && _d('Best index found is', $best);
2148  ***      0                                  0      return $best;
2149                                                  }
2150                                                  
2151                                                  sub find_possible_keys {
2152  ***      0                    0             0      my ( $self, $dbh, $database, $table, $quoter, $where ) = @_;
2153  ***      0      0                           0      return () unless $where;
2154  ***      0                                  0      my $sql = 'EXPLAIN SELECT * FROM ' . $quoter->quote($database, $table)
2155                                                        . ' WHERE ' . $where;
2156  ***      0                                  0      MKDEBUG && _d($sql);
2157  ***      0                                  0      my $expl = $dbh->selectrow_hashref($sql);
2158  ***      0                                  0      $expl = { map { lc($_) => $expl->{$_} } keys %$expl };
      ***      0                                  0   
2159  ***      0      0                           0      if ( $expl->{possible_keys} ) {
2160  ***      0                                  0         MKDEBUG && _d('possible_keys =', $expl->{possible_keys});
2161  ***      0                                  0         my @candidates = split(',', $expl->{possible_keys});
2162  ***      0                                  0         my %possible   = map { $_ => 1 } @candidates;
      ***      0                                  0   
2163  ***      0      0                           0         if ( $expl->{key} ) {
2164  ***      0                                  0            MKDEBUG && _d('MySQL chose', $expl->{key});
2165  ***      0                                  0            unshift @candidates, grep { $possible{$_} } split(',', $expl->{key});
      ***      0                                  0   
2166  ***      0                                  0            MKDEBUG && _d('Before deduping:', join(', ', @candidates));
2167  ***      0                                  0            my %seen;
2168  ***      0                                  0            @candidates = grep { !$seen{$_}++ } @candidates;
      ***      0                                  0   
2169                                                        }
2170  ***      0                                  0         MKDEBUG && _d('Final list:', join(', ', @candidates));
2171  ***      0                                  0         return @candidates;
2172                                                     }
2173                                                     else {
2174  ***      0                                  0         MKDEBUG && _d('No keys in possible_keys');
2175  ***      0                                  0         return ();
2176                                                     }
2177                                                  }
2178                                                  
2179                                                  sub check_table {
2180          27                   27           188      my ( $self, %args ) = @_;
2181          27                                132      my @required_args = qw(dbh db tbl);
2182          27                                 92      foreach my $arg ( @required_args ) {
2183  ***     81     50                         367         die "I need a $arg argument" unless $args{$arg};
2184                                                     }
2185          27                                120      my ($dbh, $db, $tbl) = @args{@required_args};
2186          27                                 91      my $q      = $self->{Quoter};
2187          27                                117      my $db_tbl = $q->quote($db, $tbl);
2188          27                                 65      MKDEBUG && _d('Checking', $db_tbl);
2189                                                  
2190          27                                106      my $sql = "SHOW TABLES FROM " . $q->quote($db)
2191                                                             . ' LIKE ' . $q->literal_like($tbl);
2192          27                                 66      MKDEBUG && _d($sql);
2193          27                                 72      my $row;
2194          27                                 72      eval {
2195          27                                 67         $row = $dbh->selectrow_arrayref($sql);
2196                                                     };
2197  ***     27     50                        6110      if ( $EVAL_ERROR ) {
2198  ***      0                                  0         MKDEBUG && _d($EVAL_ERROR);
2199  ***      0                                  0         return 0;
2200                                                     }
2201  ***     27    100     66                  267      if ( !$row->[0] || $row->[0] ne $tbl ) {
2202          16                                 38         MKDEBUG && _d('Table does not exist');
2203          16                                123         return 0;
2204                                                     }
2205                                                  
2206          11                                 27      MKDEBUG && _d('Table exists; no privs to check');
2207  ***     11     50                         113      return 1 unless $args{all_privs};
2208                                                  
2209  ***      0                                  0      $sql = "SHOW FULL COLUMNS FROM $db_tbl";
2210  ***      0                                  0      MKDEBUG && _d($sql);
2211  ***      0                                  0      eval {
2212  ***      0                                  0         $row = $dbh->selectrow_hashref($sql);
2213                                                     };
2214  ***      0      0                           0      if ( $EVAL_ERROR ) {
2215  ***      0                                  0         MKDEBUG && _d($EVAL_ERROR);
2216  ***      0                                  0         return 0;
2217                                                     }
2218  ***      0      0                           0      if ( !scalar keys %$row ) {
2219  ***      0                                  0         MKDEBUG && _d('Table has no columns:', Dumper($row));
2220  ***      0                                  0         return 0;
2221                                                     }
2222  ***      0             0                    0      my $privs = $row->{privileges} || $row->{Privileges};
2223                                                  
2224  ***      0                                  0      $sql = "DELETE FROM $db_tbl LIMIT 0";
2225  ***      0                                  0      MKDEBUG && _d($sql);
2226  ***      0                                  0      eval {
2227  ***      0                                  0         $dbh->do($sql);
2228                                                     };
2229  ***      0      0                           0      my $can_delete = $EVAL_ERROR ? 0 : 1;
2230                                                  
2231  ***      0                                  0      MKDEBUG && _d('User privs on', $db_tbl, ':', $privs,
2232                                                        ($can_delete ? 'delete' : ''));
2233                                                  
2234  ***      0      0      0                    0      if ( !($privs =~ m/select/ && $privs =~ m/insert/ && $privs =~ m/update/
      ***                    0                        
      ***                    0                        
2235                                                            && $can_delete) ) {
2236  ***      0                                  0         MKDEBUG && _d('User does not have all privs');
2237  ***      0                                  0         return 0;
2238                                                     }
2239                                                  
2240  ***      0                                  0      MKDEBUG && _d('User has all privs');
2241  ***      0                                  0      return 1;
2242                                                  }
2243                                                  
2244                                                  sub get_engine {
2245          20                   20            93      my ( $self, $ddl, $opts ) = @_;
2246          20                                246      my ( $engine ) = $ddl =~ m/\).*?(?:ENGINE|TYPE)=(\w+)/;
2247          20                                 52      MKDEBUG && _d('Storage engine:', $engine);
2248  ***     20            50                  109      return $engine || undef;
2249                                                  }
2250                                                  
2251                                                  sub get_keys {
2252          10                   10            59      my ( $self, $ddl, $opts, $is_nullable ) = @_;
2253          10                                 46      my $engine        = $self->get_engine($ddl);
2254          10                                 30      my $keys          = {};
2255          10                                 31      my $clustered_key = undef;
2256                                                  
2257                                                     KEY:
2258          10                                111      foreach my $key ( $ddl =~ m/^  ((?:[A-Z]+ )?KEY .*)$/gm ) {
2259                                                  
2260  ***      9     50                          41         next KEY if $key =~ m/FOREIGN/;
2261                                                  
2262           9                                 33         my $key_ddl = $key;
2263           9                                 20         MKDEBUG && _d('Parsed key:', $key_ddl);
2264                                                  
2265  ***      9     50                          64         if ( $engine !~ m/MEMORY|HEAP/ ) {
2266           9                                 37            $key =~ s/USING HASH/USING BTREE/;
2267                                                        }
2268                                                  
2269           9                                 75         my ( $type, $cols ) = $key =~ m/(?:USING (\w+))? \((.+)\)/;
2270           9                                 50         my ( $special ) = $key =~ m/(FULLTEXT|SPATIAL)/;
2271  ***      9            33                  126         $type = $type || $special || 'BTREE';
      ***                   50                        
2272  ***      9     50     33                   71         if ( $opts->{mysql_version} && $opts->{mysql_version} lt '004001000'
      ***                   33                        
2273                                                           && $engine =~ m/HEAP|MEMORY/i )
2274                                                        {
2275  ***      0                                  0            $type = 'HASH'; # MySQL pre-4.1 supports only HASH indexes on HEAP
2276                                                        }
2277                                                  
2278           9                                 76         my ($name) = $key =~ m/(PRIMARY|`[^`]*`)/;
2279  ***      9     50                          61         my $unique = $key =~ m/PRIMARY|UNIQUE/ ? 1 : 0;
2280           9                                 24         my @cols;
2281           9                                 23         my @col_prefixes;
2282           9                                 62         foreach my $col_def ( $cols =~ m/`[^`]+`(?:\(\d+\))?/g ) {
2283           9                                 53            my ($name, $prefix) = $col_def =~ m/`([^`]+)`(?:\((\d+)\))?/;
2284           9                                 36            push @cols, $name;
2285           9                                 43            push @col_prefixes, $prefix;
2286                                                        }
2287           9                                 37         $name =~ s/`//g;
2288                                                  
2289           9                                 21         MKDEBUG && _d( $name, 'key cols:', join(', ', map { "`$_`" } @cols));
2290                                                  
2291           9                                 47         $keys->{$name} = {
2292                                                           name         => $name,
2293                                                           type         => $type,
2294                                                           colnames     => $cols,
2295                                                           cols         => \@cols,
2296                                                           col_prefixes => \@col_prefixes,
2297                                                           is_unique    => $unique,
2298           9                                121            is_nullable  => scalar(grep { $is_nullable->{$_} } @cols),
2299           9                                 59            is_col       => { map { $_ => 1 } @cols },
2300                                                           ddl          => $key_ddl,
2301                                                        };
2302                                                  
2303  ***      9    100     66                   96         if ( $engine =~ m/InnoDB/i && !$clustered_key ) {
2304           2                                  7            my $this_key = $keys->{$name};
2305  ***      2     50      0                   10            if ( $this_key->{name} eq 'PRIMARY' ) {
      ***             0                               
2306           2                                  6               $clustered_key = 'PRIMARY';
2307                                                           }
2308                                                           elsif ( $this_key->{is_unique} && !$this_key->{is_nullable} ) {
2309  ***      0                                  0               $clustered_key = $this_key->{name};
2310                                                           }
2311           2                                  9            MKDEBUG && $clustered_key && _d('This key is the clustered key');
2312                                                        }
2313                                                     }
2314                                                  
2315          10                                 62      return $keys, $clustered_key;
2316                                                  }
2317                                                  
2318                                                  sub get_fks {
2319  ***      0                    0             0      my ( $self, $ddl, $opts ) = @_;
2320  ***      0                                  0      my $fks = {};
2321                                                  
2322  ***      0                                  0      foreach my $fk (
2323                                                        $ddl =~ m/CONSTRAINT .* FOREIGN KEY .* REFERENCES [^\)]*\)/mg )
2324                                                     {
2325  ***      0                                  0         my ( $name ) = $fk =~ m/CONSTRAINT `(.*?)`/;
2326  ***      0                                  0         my ( $cols ) = $fk =~ m/FOREIGN KEY \(([^\)]+)\)/;
2327  ***      0                                  0         my ( $parent, $parent_cols ) = $fk =~ m/REFERENCES (\S+) \(([^\)]+)\)/;
2328                                                  
2329  ***      0      0      0                    0         if ( $parent !~ m/\./ && $opts->{database} ) {
2330  ***      0                                  0            $parent = "`$opts->{database}`.$parent";
2331                                                        }
2332                                                  
2333  ***      0                                  0         $fks->{$name} = {
2334                                                           name           => $name,
2335                                                           colnames       => $cols,
2336  ***      0                                  0            cols           => [ map { s/[ `]+//g; $_; } split(',', $cols) ],
      ***      0                                  0   
2337                                                           parent_tbl     => $parent,
2338                                                           parent_colnames=> $parent_cols,
2339  ***      0                                  0            parent_cols    => [ map { s/[ `]+//g; $_; } split(',', $parent_cols) ],
      ***      0                                  0   
2340                                                           ddl            => $fk,
2341                                                        };
2342                                                     }
2343                                                  
2344  ***      0                                  0      return $fks;
2345                                                  }
2346                                                  
2347                                                  sub remove_auto_increment {
2348  ***      0                    0             0      my ( $self, $ddl ) = @_;
2349  ***      0                                  0      $ddl =~ s/(^\).*?) AUTO_INCREMENT=\d+\b/$1/m;
2350  ***      0                                  0      return $ddl;
2351                                                  }
2352                                                  
2353                                                  sub remove_secondary_indexes {
2354  ***      0                    0             0      my ( $self, $ddl ) = @_;
2355  ***      0                                  0      my $sec_indexes_ddl;
2356  ***      0                                  0      my $tbl_struct = $self->parse($ddl);
2357                                                  
2358  ***      0      0      0                    0      if ( ($tbl_struct->{engine} || '') =~ m/InnoDB/i ) {
2359  ***      0                                  0         my $clustered_key = $tbl_struct->{clustered_key};
2360  ***      0             0                    0         $clustered_key  ||= '';
2361                                                  
2362  ***      0                                  0         my @sec_indexes   = map {
2363  ***      0                                  0            my $key_def = $_->{ddl};
2364  ***      0                                  0            $key_def =~ s/([\(\)])/\\$1/g;
2365  ***      0                                  0            $ddl =~ s/\s+$key_def//i;
2366                                                  
2367  ***      0                                  0            my $key_ddl = "ADD $_->{ddl}";
2368  ***      0      0                           0            $key_ddl   .= ',' unless $key_ddl =~ m/,$/;
2369  ***      0                                  0            $key_ddl;
2370                                                        }
2371  ***      0                                  0         grep { $_->{name} ne $clustered_key }
2372  ***      0                                  0         values %{$tbl_struct->{keys}};
2373  ***      0                                  0         MKDEBUG && _d('Secondary indexes:', Dumper(\@sec_indexes));
2374                                                  
2375  ***      0      0                           0         if ( @sec_indexes ) {
2376  ***      0                                  0            $sec_indexes_ddl = join(' ', @sec_indexes);
2377  ***      0                                  0            $sec_indexes_ddl =~ s/,$//;
2378                                                        }
2379                                                  
2380  ***      0                                  0         $ddl =~ s/,(\n\) )/$1/s;
2381                                                     }
2382                                                     else {
2383  ***      0                                  0         MKDEBUG && _d('Not removing secondary indexes from',
2384                                                           $tbl_struct->{engine}, 'table');
2385                                                     }
2386                                                  
2387  ***      0                                  0      return $ddl, $sec_indexes_ddl, $tbl_struct;
2388                                                  }
2389                                                  
2390                                                  sub _d {
2391  ***      0                    0             0      my ($package, undef, $line) = caller 0;
2392  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
2393  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
2394                                                          @_;
2395  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2396                                                  }
2397                                                  
2398                                                  1;
2399                                                  
2400                                                  # ###########################################################################
2401                                                  # End TableParser package
2402                                                  # ###########################################################################
2403                                                  
2404                                                  # ###########################################################################
2405                                                  # MySQLDump package 6345
2406                                                  # This package is a copy without comments from the original.  The original
2407                                                  # with comments and its test file can be found in the SVN repository at,
2408                                                  #   trunk/common/MySQLDump.pm
2409                                                  #   trunk/common/t/MySQLDump.t
2410                                                  # See http://code.google.com/p/maatkit/wiki/Developers for more information.
2411                                                  # ###########################################################################
2412                                                  package MySQLDump;
2413                                                  
2414           3                    3            25   use strict;
               3                                  7   
               3                                 18   
2415           3                    3            18   use warnings FATAL => 'all';
               3                                  8   
               3                                 17   
2416                                                  
2417           3                    3            18   use English qw(-no_match_vars);
               3                                 11   
               3                                 16   
2418                                                  
2419  ***      3            50      3            20   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               3                                  6   
               3                                 51   
2420                                                  
2421                                                  ( our $before = <<'EOF') =~ s/^   //gm;
2422                                                     /*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
2423                                                     /*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
2424                                                     /*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
2425                                                     /*!40101 SET NAMES utf8 */;
2426                                                     /*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
2427                                                     /*!40103 SET TIME_ZONE='+00:00' */;
2428                                                     /*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
2429                                                     /*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
2430                                                     /*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
2431                                                     /*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
2432                                                  EOF
2433                                                  
2434                                                  ( our $after = <<'EOF') =~ s/^   //gm;
2435                                                     /*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;
2436                                                     /*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
2437                                                     /*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
2438                                                     /*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
2439                                                     /*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
2440                                                     /*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
2441                                                     /*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
2442                                                     /*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
2443                                                  EOF
2444                                                  
2445                                                  sub new {
2446           6                    6            45      my ( $class, %args ) = @_;
2447           6                                 45      my $self = {
2448                                                        cache => 0,  # Afaik no script uses this cache any longer because
2449                                                     };
2450           6                                 61      return bless $self, $class;
2451                                                  }
2452                                                  
2453                                                  sub dump {
2454  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl, $what ) = @_;
2455                                                  
2456  ***      0      0                           0      if ( $what eq 'table' ) {
      ***             0                               
      ***             0                               
2457  ***      0                                  0         my $ddl = $self->get_create_table($dbh, $quoter, $db, $tbl);
2458  ***      0      0                           0         return unless $ddl;
2459  ***      0      0                           0         if ( $ddl->[0] eq 'table' ) {
2460  ***      0                                  0            return $before
2461                                                              . 'DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . ";\n"
2462                                                              . $ddl->[1] . ";\n";
2463                                                        }
2464                                                        else {
2465  ***      0                                  0            return 'DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . ";\n"
2466                                                              . '/*!50001 DROP VIEW IF EXISTS '
2467                                                              . $quoter->quote($tbl) . "*/;\n/*!50001 "
2468                                                              . $self->get_tmp_table($dbh, $quoter, $db, $tbl) . "*/;\n";
2469                                                        }
2470                                                     }
2471                                                     elsif ( $what eq 'triggers' ) {
2472  ***      0                                  0         my $trgs = $self->get_triggers($dbh, $quoter, $db, $tbl);
2473  ***      0      0      0                    0         if ( $trgs && @$trgs ) {
2474  ***      0                                  0            my $result = $before . "\nDELIMITER ;;\n";
2475  ***      0                                  0            foreach my $trg ( @$trgs ) {
2476  ***      0      0                           0               if ( $trg->{sql_mode} ) {
2477  ***      0                                  0                  $result .= qq{/*!50003 SET SESSION SQL_MODE='$trg->{sql_mode}' */;;\n};
2478                                                              }
2479  ***      0                                  0               $result .= "/*!50003 CREATE */ ";
2480  ***      0      0                           0               if ( $trg->{definer} ) {
2481  ***      0                                  0                  my ( $user, $host )
2482  ***      0                                  0                     = map { s/'/''/g; "'$_'"; }
      ***      0                                  0   
2483                                                                      split('@', $trg->{definer}, 2);
2484  ***      0                                  0                  $result .= "/*!50017 DEFINER=$user\@$host */ ";
2485                                                              }
2486  ***      0                                  0               $result .= sprintf("/*!50003 TRIGGER %s %s %s ON %s\nFOR EACH ROW %s */;;\n\n",
2487                                                                 $quoter->quote($trg->{trigger}),
2488  ***      0                                  0                  @{$trg}{qw(timing event)},
2489                                                                 $quoter->quote($trg->{table}),
2490                                                                 $trg->{statement});
2491                                                           }
2492  ***      0                                  0            $result .= "DELIMITER ;\n\n/*!50003 SET SESSION SQL_MODE=\@OLD_SQL_MODE */;\n\n";
2493  ***      0                                  0            return $result;
2494                                                        }
2495                                                        else {
2496  ***      0                                  0            return undef;
2497                                                        }
2498                                                     }
2499                                                     elsif ( $what eq 'view' ) {
2500  ***      0                                  0         my $ddl = $self->get_create_table($dbh, $quoter, $db, $tbl);
2501  ***      0                                  0         return '/*!50001 DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . "*/;\n"
2502                                                           . '/*!50001 DROP VIEW IF EXISTS ' . $quoter->quote($tbl) . "*/;\n"
2503                                                           . '/*!50001 ' . $ddl->[1] . "*/;\n";
2504                                                     }
2505                                                     else {
2506  ***      0                                  0         die "You didn't say what to dump.";
2507                                                     }
2508                                                  }
2509                                                  
2510                                                  sub _use_db {
2511          10                   10            60      my ( $self, $dbh, $quoter, $new ) = @_;
2512  ***     10     50                          55      if ( !$new ) {
2513  ***      0                                  0         MKDEBUG && _d('No new DB to use');
2514  ***      0                                  0         return;
2515                                                     }
2516          10                                 69      my $sql = 'USE ' . $quoter->quote($new);
2517          10                                 30      MKDEBUG && _d($dbh, $sql);
2518          10                                814      $dbh->do($sql);
2519          10                                 50      return;
2520                                                  }
2521                                                  
2522                                                  sub get_create_table {
2523          10                   10        193691      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
2524  ***     10     50     33                   97      if ( !$self->{cache} || !$self->{tables}->{$db}->{$tbl} ) {
2525          10                                 42         my $sql = '/*!40101 SET @OLD_SQL_MODE := @@SQL_MODE, '
2526                                                           . q{@@SQL_MODE := REPLACE(REPLACE(@@SQL_MODE, 'ANSI_QUOTES', ''), ',,', ','), }
2527                                                           . '@OLD_QUOTE := @@SQL_QUOTE_SHOW_CREATE, '
2528                                                           . '@@SQL_QUOTE_SHOW_CREATE := 1 */';
2529          10                                 27         MKDEBUG && _d($sql);
2530          10                                 35         eval { $dbh->do($sql); };
              10                               2209   
2531          10                                 38         MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
2532          10                                 80         $self->_use_db($dbh, $quoter, $db);
2533          10                                 45         $sql = "SHOW CREATE TABLE " . $quoter->quote($db, $tbl);
2534          10                                 27         MKDEBUG && _d($sql);
2535          10                                 26         my $href;
2536          10                                 27         eval { $href = $dbh->selectrow_hashref($sql); };
              10                                 28   
2537  ***     10     50                          74         if ( $EVAL_ERROR ) {
2538  ***      0                                  0            warn "Failed to $sql.  The table may be damaged.\nError: $EVAL_ERROR";
2539  ***      0                                  0            return;
2540                                                        }
2541                                                  
2542          10                                 35         $sql = '/*!40101 SET @@SQL_MODE := @OLD_SQL_MODE, '
2543                                                           . '@@SQL_QUOTE_SHOW_CREATE := @OLD_QUOTE */';
2544          10                                 23         MKDEBUG && _d($sql);
2545          10                                709         $dbh->do($sql);
2546          10                                 72         my ($key) = grep { m/create table/i } keys %$href;
              20                                146   
2547  ***     10     50                          49         if ( $key ) {
2548          10                                 26            MKDEBUG && _d('This table is a base table');
2549          10                                133            $self->{tables}->{$db}->{$tbl} = [ 'table', $href->{$key} ];
2550                                                        }
2551                                                        else {
2552  ***      0                                  0            MKDEBUG && _d('This table is a view');
2553  ***      0                                  0            ($key) = grep { m/create view/i } keys %$href;
      ***      0                                  0   
2554  ***      0                                  0            $self->{tables}->{$db}->{$tbl} = [ 'view', $href->{$key} ];
2555                                                        }
2556                                                     }
2557          10                                116      return $self->{tables}->{$db}->{$tbl};
2558                                                  }
2559                                                  
2560                                                  sub get_columns {
2561  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
2562  ***      0                                  0      MKDEBUG && _d('Get columns for', $db, $tbl);
2563  ***      0      0      0                    0      if ( !$self->{cache} || !$self->{columns}->{$db}->{$tbl} ) {
2564  ***      0                                  0         $self->_use_db($dbh, $quoter, $db);
2565  ***      0                                  0         my $sql = "SHOW COLUMNS FROM " . $quoter->quote($db, $tbl);
2566  ***      0                                  0         MKDEBUG && _d($sql);
2567  ***      0                                  0         my $cols = $dbh->selectall_arrayref($sql, { Slice => {} });
2568                                                  
2569  ***      0                                  0         $self->{columns}->{$db}->{$tbl} = [
2570                                                           map {
2571  ***      0                                  0               my %row;
2572  ***      0                                  0               @row{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                  0   
2573  ***      0                                  0               \%row;
2574                                                           } @$cols
2575                                                        ];
2576                                                     }
2577  ***      0                                  0      return $self->{columns}->{$db}->{$tbl};
2578                                                  }
2579                                                  
2580                                                  sub get_tmp_table {
2581  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
2582  ***      0                                  0      my $result = 'CREATE TABLE ' . $quoter->quote($tbl) . " (\n";
2583  ***      0                                  0      $result .= join(",\n",
2584  ***      0                                  0         map { '  ' . $quoter->quote($_->{field}) . ' ' . $_->{type} }
2585  ***      0                                  0         @{$self->get_columns($dbh, $quoter, $db, $tbl)});
2586  ***      0                                  0      $result .= "\n)";
2587  ***      0                                  0      MKDEBUG && _d($result);
2588  ***      0                                  0      return $result;
2589                                                  }
2590                                                  
2591                                                  sub get_triggers {
2592  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
2593  ***      0      0      0                    0      if ( !$self->{cache} || !$self->{triggers}->{$db} ) {
2594  ***      0                                  0         $self->{triggers}->{$db} = {};
2595  ***      0                                  0         my $sql = '/*!40101 SET @OLD_SQL_MODE := @@SQL_MODE, '
2596                                                           . q{@@SQL_MODE := REPLACE(REPLACE(@@SQL_MODE, 'ANSI_QUOTES', ''), ',,', ','), }
2597                                                           . '@OLD_QUOTE := @@SQL_QUOTE_SHOW_CREATE, '
2598                                                           . '@@SQL_QUOTE_SHOW_CREATE := 1 */';
2599  ***      0                                  0         MKDEBUG && _d($sql);
2600  ***      0                                  0         eval { $dbh->do($sql); };
      ***      0                                  0   
2601  ***      0                                  0         MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
2602  ***      0                                  0         $sql = "SHOW TRIGGERS FROM " . $quoter->quote($db);
2603  ***      0                                  0         MKDEBUG && _d($sql);
2604  ***      0                                  0         my $sth = $dbh->prepare($sql);
2605  ***      0                                  0         $sth->execute();
2606  ***      0      0                           0         if ( $sth->rows ) {
2607  ***      0                                  0            my $trgs = $sth->fetchall_arrayref({});
2608  ***      0                                  0            foreach my $trg (@$trgs) {
2609  ***      0                                  0               my %trg;
2610  ***      0                                  0               @trg{ map { lc $_ } keys %$trg } = values %$trg;
      ***      0                                  0   
2611  ***      0                                  0               push @{ $self->{triggers}->{$db}->{ $trg{table} } }, \%trg;
      ***      0                                  0   
2612                                                           }
2613                                                        }
2614  ***      0                                  0         $sql = '/*!40101 SET @@SQL_MODE := @OLD_SQL_MODE, '
2615                                                           . '@@SQL_QUOTE_SHOW_CREATE := @OLD_QUOTE */';
2616  ***      0                                  0         MKDEBUG && _d($sql);
2617  ***      0                                  0         $dbh->do($sql);
2618                                                     }
2619  ***      0      0                           0      if ( $tbl ) {
2620  ***      0                                  0         return $self->{triggers}->{$db}->{$tbl};
2621                                                     }
2622  ***      0                                  0      return values %{$self->{triggers}->{$db}};
      ***      0                                  0   
2623                                                  }
2624                                                  
2625                                                  sub get_databases {
2626  ***      0                    0             0      my ( $self, $dbh, $quoter, $like ) = @_;
2627  ***      0      0      0                    0      if ( !$self->{cache} || !$self->{databases} || $like ) {
      ***                    0                        
2628  ***      0                                  0         my $sql = 'SHOW DATABASES';
2629  ***      0                                  0         my @params;
2630  ***      0      0                           0         if ( $like ) {
2631  ***      0                                  0            $sql .= ' LIKE ?';
2632  ***      0                                  0            push @params, $like;
2633                                                        }
2634  ***      0                                  0         my $sth = $dbh->prepare($sql);
2635  ***      0                                  0         MKDEBUG && _d($sql, @params);
2636  ***      0                                  0         $sth->execute( @params );
2637  ***      0                                  0         my @dbs = map { $_->[0] } @{$sth->fetchall_arrayref()};
      ***      0                                  0   
      ***      0                                  0   
2638  ***      0      0                           0         $self->{databases} = \@dbs unless $like;
2639  ***      0                                  0         return @dbs;
2640                                                     }
2641  ***      0                                  0      return @{$self->{databases}};
      ***      0                                  0   
2642                                                  }
2643                                                  
2644                                                  sub get_table_status {
2645  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $like ) = @_;
2646  ***      0      0      0                    0      if ( !$self->{cache} || !$self->{table_status}->{$db} || $like ) {
      ***                    0                        
2647  ***      0                                  0         my $sql = "SHOW TABLE STATUS FROM " . $quoter->quote($db);
2648  ***      0                                  0         my @params;
2649  ***      0      0                           0         if ( $like ) {
2650  ***      0                                  0            $sql .= ' LIKE ?';
2651  ***      0                                  0            push @params, $like;
2652                                                        }
2653  ***      0                                  0         MKDEBUG && _d($sql, @params);
2654  ***      0                                  0         my $sth = $dbh->prepare($sql);
2655  ***      0                                  0         $sth->execute(@params);
2656  ***      0                                  0         my @tables = @{$sth->fetchall_arrayref({})};
      ***      0                                  0   
2657  ***      0                                  0         @tables = map {
2658  ***      0                                  0            my %tbl; # Make a copy with lowercased keys
2659  ***      0                                  0            @tbl{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                  0   
2660  ***      0             0                    0            $tbl{engine} ||= $tbl{type} || $tbl{comment};
      ***                    0                        
2661  ***      0                                  0            delete $tbl{type};
2662  ***      0                                  0            \%tbl;
2663                                                        } @tables;
2664  ***      0      0                           0         $self->{table_status}->{$db} = \@tables unless $like;
2665  ***      0                                  0         return @tables;
2666                                                     }
2667  ***      0                                  0      return @{$self->{table_status}->{$db}};
      ***      0                                  0   
2668                                                  }
2669                                                  
2670                                                  sub get_table_list {
2671  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $like ) = @_;
2672  ***      0      0      0                    0      if ( !$self->{cache} || !$self->{table_list}->{$db} || $like ) {
      ***                    0                        
2673  ***      0                                  0         my $sql = "SHOW /*!50002 FULL*/ TABLES FROM " . $quoter->quote($db);
2674  ***      0                                  0         my @params;
2675  ***      0      0                           0         if ( $like ) {
2676  ***      0                                  0            $sql .= ' LIKE ?';
2677  ***      0                                  0            push @params, $like;
2678                                                        }
2679  ***      0                                  0         MKDEBUG && _d($sql, @params);
2680  ***      0                                  0         my $sth = $dbh->prepare($sql);
2681  ***      0                                  0         $sth->execute(@params);
2682  ***      0                                  0         my @tables = @{$sth->fetchall_arrayref()};
      ***      0                                  0   
2683  ***      0      0      0                    0         @tables = map {
2684  ***      0                                  0            my %tbl = (
2685                                                              name   => $_->[0],
2686                                                              engine => ($_->[1] || '') eq 'VIEW' ? 'VIEW' : '',
2687                                                           );
2688  ***      0                                  0            \%tbl;
2689                                                        } @tables;
2690  ***      0      0                           0         $self->{table_list}->{$db} = \@tables unless $like;
2691  ***      0                                  0         return @tables;
2692                                                     }
2693  ***      0                                  0      return @{$self->{table_list}->{$db}};
      ***      0                                  0   
2694                                                  }
2695                                                  
2696                                                  sub _d {
2697  ***      0                    0             0      my ($package, undef, $line) = caller 0;
2698  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
2699  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
2700                                                          @_;
2701  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2702                                                  }
2703                                                  
2704                                                  1;
2705                                                  
2706                                                  # ###########################################################################
2707                                                  # End MySQLDump package
2708                                                  # ###########################################################################
2709                                                  
2710                                                  # ###########################################################################
2711                                                  # TableChunker package 7169
2712                                                  # This package is a copy without comments from the original.  The original
2713                                                  # with comments and its test file can be found in the SVN repository at,
2714                                                  #   trunk/common/TableChunker.pm
2715                                                  #   trunk/common/t/TableChunker.t
2716                                                  # See http://code.google.com/p/maatkit/wiki/Developers for more information.
2717                                                  # ###########################################################################
2718                                                  
2719                                                  package TableChunker;
2720                                                  
2721           3                    3            26   use strict;
               3                                  8   
               3                                 17   
2722           3                    3            18   use warnings FATAL => 'all';
               3                                  8   
               3                                 17   
2723           3                    3            18   use English qw(-no_match_vars);
               3                                  8   
               3                                 16   
2724  ***      3            50      3            23   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               3                                  6   
               3                                 41   
2725                                                  
2726           3                    3            20   use POSIX qw(floor ceil);
               3                                  7   
               3                                 22   
2727           3                    3            21   use List::Util qw(min max);
               3                                  7   
               3                                 19   
2728           3                    3            17   use Data::Dumper;
               3                                  8   
               3                                 14   
2729                                                  $Data::Dumper::Indent    = 1;
2730                                                  $Data::Dumper::Sortkeys  = 1;
2731                                                  $Data::Dumper::Quotekeys = 0;
2732                                                  
2733                                                  sub new {
2734           6                    6            52      my ( $class, %args ) = @_;
2735           6                                 33      foreach my $arg ( qw(Quoter MySQLDump) ) {
2736  ***     12     50                          64         die "I need a $arg argument" unless $args{$arg};
2737                                                     }
2738                                                  
2739           6                                 43      my %int_types  = map { $_ => 1 } qw(bigint date datetime int mediumint smallint time timestamp tinyint year);
              60                                302   
2740           6                                 37      my %real_types = map { $_ => 1 } qw(decimal double float);
              18                                 82   
2741                                                  
2742           6                                 74      my $self = {
2743                                                        %args,
2744                                                        int_types  => \%int_types,
2745                                                        real_types => \%real_types,
2746                                                        EPOCH      => '1970-01-01',
2747                                                     };
2748                                                  
2749           6                                 67      return bless $self, $class;
2750                                                  }
2751                                                  
2752                                                  sub find_chunk_columns {
2753           6                    6            50      my ( $self, %args ) = @_;
2754           6                                 39      foreach my $arg ( qw(tbl_struct) ) {
2755  ***      6     50                          39         die "I need a $arg argument" unless $args{$arg};
2756                                                     }
2757           6                                 20      my $tbl_struct = $args{tbl_struct};
2758                                                  
2759           6                                 20      my @possible_indexes;
2760           6                                 19      foreach my $index ( values %{ $tbl_struct->{keys} } ) {
               6                                 42   
2761                                                  
2762  ***      5     50                          30         next unless $index->{type} eq 'BTREE';
2763                                                  
2764  ***      5     50                          15         next if grep { defined } @{$index->{col_prefixes}};
               5                                 28   
               5                                 25   
2765                                                  
2766  ***      5     50                          26         if ( $args{exact} ) {
2767  ***      5     50     33                   45            next unless $index->{is_unique} && @{$index->{cols}} == 1;
               5                                 41   
2768                                                        }
2769                                                  
2770           5                                 25         push @possible_indexes, $index;
2771                                                     }
2772                                                     MKDEBUG && _d('Possible chunk indexes in order:',
2773           6                                 18         join(', ', map { $_->{name} } @possible_indexes));
2774                                                  
2775           6                                 18      my $can_chunk_exact = 0;
2776           6                                 17      my @candidate_cols;
2777           6                                 21      foreach my $index ( @possible_indexes ) { 
2778           5                                 21         my $col = $index->{cols}->[0];
2779                                                  
2780           5                                 24         my $col_type = $tbl_struct->{type_for}->{$col};
2781  ***      5     50     33                   46         next unless $self->{int_types}->{$col_type}
      ***                   33                        
2782                                                                 || $self->{real_types}->{$col_type}
2783                                                                 || $col_type =~ m/char/;
2784                                                  
2785           5                                 59         push @candidate_cols, { column => $col, index => $index->{name} };
2786                                                     }
2787                                                  
2788  ***      6    100     50                   72      $can_chunk_exact = 1 if $args{exact} && scalar @candidate_cols;
2789                                                  
2790           6                                 16      if ( MKDEBUG ) {
2791                                                        my $chunk_type = $args{exact} ? 'Exact' : 'Inexact';
2792                                                        _d($chunk_type, 'chunkable:',
2793                                                           join(', ', map { "$_->{column} on $_->{index}" } @candidate_cols));
2794                                                     }
2795                                                  
2796           6                                 17      my @result;
2797           6                                 16      MKDEBUG && _d('Ordering columns by order in tbl, PK first');
2798           6    100                          39      if ( $tbl_struct->{keys}->{PRIMARY} ) {
2799           5                                 28         my $pk_first_col = $tbl_struct->{keys}->{PRIMARY}->{cols}->[0];
2800           5                                 16         @result          = grep { $_->{column} eq $pk_first_col } @candidate_cols;
               5                                 29   
2801           5                                 22         @candidate_cols  = grep { $_->{column} ne $pk_first_col } @candidate_cols;
               5                                 27   
2802                                                     }
2803           6                                 20      my $i = 0;
2804           6                                 19      my %col_pos = map { $_ => $i++ } @{$tbl_struct->{cols}};
              17                                 87   
               6                                 30   
2805           6                                 44      push @result, sort { $col_pos{$a->{column}} <=> $col_pos{$b->{column}} }
      ***      0                                  0   
2806                                                                      @candidate_cols;
2807                                                  
2808           6                                 16      if ( MKDEBUG ) {
2809                                                        _d('Chunkable columns:',
2810                                                           join(', ', map { "$_->{column} on $_->{index}" } @result));
2811                                                        _d('Can chunk exactly:', $can_chunk_exact);
2812                                                     }
2813                                                  
2814           6                                 43      return ($can_chunk_exact, @result);
2815                                                  }
2816                                                  
2817                                                  sub calculate_chunks {
2818           3                    3            34      my ( $self, %args ) = @_;
2819           3                                 22      my @required_args = qw(dbh db tbl tbl_struct chunk_col rows_in_range chunk_size);
2820           3                                 17      foreach my $arg ( @required_args ) {
2821  ***     21     50                          92         die "I need a $arg argument" unless defined $args{$arg};
2822                                                     }
2823                                                     MKDEBUG && _d('Calculate chunks for',
2824           3                                 10         join(", ", map {"$_=".(defined $args{$_} ? $args{$_} : "undef")}
2825                                                           qw(db tbl chunk_col min max rows_in_range chunk_size zero_chunk exact)
2826                                                        ));
2827                                                  
2828  ***      3     50                          16      if ( !$args{rows_in_range} ) {
2829  ***      0                                  0         MKDEBUG && _d("Empty table");
2830  ***      0                                  0         return '1=1';
2831                                                     }
2832                                                  
2833           3    100                          21      if ( $args{rows_in_range} < $args{chunk_size} ) {
2834           2                                  5         MKDEBUG && _d("Chunk size larger than rows in range");
2835           2                                 17         return '1=1';
2836                                                     }
2837                                                  
2838           1                                  4      my $q          = $self->{Quoter};
2839           1                                  3      my $dbh        = $args{dbh};
2840           1                                  4      my $chunk_col  = $args{chunk_col};
2841           1                                  3      my $tbl_struct = $args{tbl_struct};
2842           1                                  4      my $col_type   = $tbl_struct->{type_for}->{$chunk_col};
2843           1                                  3      MKDEBUG && _d('chunk col type:', $col_type);
2844                                                  
2845           1                                  4      my %chunker;
2846  ***      1     50     33                    8      if ( $tbl_struct->{is_numeric}->{$chunk_col} || $col_type =~ /date|time/ ) {
      ***             0                               
2847           1                                 11         %chunker = $self->_chunk_numeric(%args);
2848                                                     }
2849                                                     elsif ( $col_type =~ m/char/ ) {
2850  ***      0                                  0         %chunker = $self->_chunk_char(%args);
2851                                                     }
2852                                                     else {
2853  ***      0                                  0         die "Cannot chunk $col_type columns";
2854                                                     }
2855           1                                  5      MKDEBUG && _d("Chunker:", Dumper(\%chunker));
2856           1                                  7      my ($col, $start_point, $end_point, $interval, $range_func)
2857                                                        = @chunker{qw(col start_point end_point interval range_func)};
2858                                                  
2859           1                                  3      my @chunks;
2860  ***      1     50                           4      if ( $start_point < $end_point ) {
2861                                                  
2862  ***      1     50                           6         push @chunks, "$col = 0" if $chunker{have_zero_chunk};
2863                                                  
2864           1                                  3         my ($beg, $end);
2865           1                                  3         my $iter = 0;
2866                                                        for ( my $i = $start_point; $i < $end_point; $i += $interval ) {
2867           5                                 26            ($beg, $end) = $self->$range_func($dbh, $i, $interval, $end_point);
2868                                                  
2869           5    100                          21            if ( $iter++ == 0 ) {
2870  ***      1     50                          10               push @chunks,
2871                                                                 ($chunker{have_zero_chunk} ? "$col > 0 AND " : "")
2872                                                                 ."$col < " . $q->quote_val($end);
2873                                                           }
2874                                                           else {
2875           4                                 19               push @chunks, "$col >= " . $q->quote_val($beg) . " AND $col < " . $q->quote_val($end);
2876                                                           }
2877           1                                  3         }
2878                                                  
2879  ***      1            50                   14         my $chunk_range = lc $args{chunk_range} || 'open';
2880           1                                  5         my $nullable    = $args{tbl_struct}->{is_nullable}->{$args{chunk_col}};
2881           1                                  3         pop @chunks;
2882  ***      1     50                           4         if ( @chunks ) {
2883  ***      1     50                           5            push @chunks, "$col >= " . $q->quote_val($beg)
2884                                                              . ($chunk_range eq 'openclosed'
2885                                                                 ? " AND $col <= " . $q->quote_val($args{max}) : "");
2886                                                        }
2887                                                        else {
2888  ***      0      0                           0            push @chunks, $nullable ? "$col IS NOT NULL" : '1=1';
2889                                                        }
2890  ***      1     50                           5         if ( $nullable ) {
2891  ***      0                                  0            push @chunks, "$col IS NULL";
2892                                                        }
2893                                                     }
2894                                                     else {
2895  ***      0                                  0         MKDEBUG && _d('No chunks; using single chunk 1=1');
2896  ***      0                                  0         push @chunks, '1=1';
2897                                                     }
2898                                                  
2899           1                                 12      return @chunks;
2900                                                  }
2901                                                  
2902                                                  sub _chunk_numeric {
2903           1                    1            10      my ( $self, %args ) = @_;
2904           1                                  7      my @required_args = qw(dbh db tbl tbl_struct chunk_col rows_in_range chunk_size);
2905           1                                  5      foreach my $arg ( @required_args ) {
2906  ***      7     50                          31         die "I need a $arg argument" unless defined $args{$arg};
2907                                                     }
2908           1                                  4      my $q        = $self->{Quoter};
2909           1                                  6      my $db_tbl   = $q->quote($args{db}, $args{tbl});
2910           1                                  6      my $col_type = $args{tbl_struct}->{type_for}->{$args{chunk_col}};
2911                                                  
2912           1                                  3      my $range_func;
2913  ***      1     50                          18      if ( $col_type =~ m/(?:int|year|float|double|decimal)$/ ) {
      ***             0                               
      ***             0                               
2914           1                                  4         $range_func  = 'range_num';
2915                                                     }
2916                                                     elsif ( $col_type =~ m/^(?:timestamp|date|time)$/ ) {
2917  ***      0                                  0         $range_func  = "range_$col_type";
2918                                                     }
2919                                                     elsif ( $col_type eq 'datetime' ) {
2920  ***      0                                  0         $range_func  = 'range_datetime';
2921                                                     }
2922                                                  
2923           1                                  3      my ($start_point, $end_point);
2924           1                                  3      eval {
2925           1                                 10         $start_point = $self->value_to_number(
2926                                                           value       => $args{min},
2927                                                           column_type => $col_type,
2928                                                           dbh         => $args{dbh},
2929                                                        );
2930           1                                  6         $end_point  = $self->value_to_number(
2931                                                           value       => $args{max},
2932                                                           column_type => $col_type,
2933                                                           dbh         => $args{dbh},
2934                                                        );
2935                                                     };
2936  ***      1     50                           5      if ( $EVAL_ERROR ) {
2937  ***      0      0                           0         if ( $EVAL_ERROR =~ m/don't know how to chunk/ ) {
2938  ***      0                                  0            die $EVAL_ERROR;
2939                                                        }
2940                                                        else {
2941  ***      0      0                           0            die "Error calculating chunk start and end points for table "
2942                                                              . "`$args{tbl_struct}->{name}` on column `$args{chunk_col}` "
2943                                                              . "with min/max values "
2944                                                              . join('/',
2945  ***      0                                  0                     map { defined $args{$_} ? $args{$_} : 'undef' } qw(min max))
2946                                                              . ":\n\n"
2947                                                              . $EVAL_ERROR
2948                                                              . "\nVerify that the min and max values are valid for the column.  "
2949                                                              . "If they are valid, this error could be caused by a bug in the "
2950                                                              . "tool.";
2951                                                        }
2952                                                     }
2953                                                  
2954  ***      1     50                           4      if ( !defined $start_point ) {
2955  ***      0                                  0         MKDEBUG && _d('Start point is undefined');
2956  ***      0                                  0         $start_point = 0;
2957                                                     }
2958  ***      1     50     33                   11      if ( !defined $end_point || $end_point < $start_point ) {
2959  ***      0                                  0         MKDEBUG && _d('End point is undefined or before start point');
2960  ***      0                                  0         $end_point = 0;
2961                                                     }
2962           1                                  2      MKDEBUG && _d("Actual chunk range:", $start_point, "to", $end_point);
2963                                                  
2964           1                                  4      my $have_zero_chunk = 0;
2965  ***      1     50                           5      if ( $args{zero_chunk} ) {
2966  ***      0      0      0                    0         if ( $start_point != $end_point && $start_point >= 0 ) {
2967  ***      0                                  0            MKDEBUG && _d('Zero chunking');
2968  ***      0                                  0            my $nonzero_val = $self->get_nonzero_value(
2969                                                              %args,
2970                                                              db_tbl   => $db_tbl,
2971                                                              col      => $args{chunk_col},
2972                                                              col_type => $col_type,
2973                                                              val      => $args{min}
2974                                                           );
2975  ***      0                                  0            $start_point = $self->value_to_number(
2976                                                              value       => $nonzero_val,
2977                                                              column_type => $col_type,
2978                                                              dbh         => $args{dbh},
2979                                                           );
2980  ***      0                                  0            $have_zero_chunk = 1;
2981                                                        }
2982                                                        else {
2983  ***      0                                  0            MKDEBUG && _d("Cannot zero chunk");
2984                                                        }
2985                                                     }
2986           1                                  2      MKDEBUG && _d("Using chunk range:", $start_point, "to", $end_point);
2987                                                  
2988           1                                  8      my $interval = $args{chunk_size}
2989                                                                  * ($end_point - $start_point)
2990                                                                  / $args{rows_in_range};
2991  ***      1     50                           5      if ( $self->{int_types}->{$col_type} ) {
2992           1                                 24         $interval = ceil($interval);
2993                                                     }
2994  ***      1            33                    5      $interval ||= $args{chunk_size};
2995  ***      1     50                           5      if ( $args{exact} ) {
2996  ***      0                                  0         $interval = $args{chunk_size};
2997                                                     }
2998           1                                  3      MKDEBUG && _d('Chunk interval:', $interval, 'units');
2999                                                  
3000                                                     return (
3001           1                                  5         col             => $q->quote($args{chunk_col}),
3002                                                        start_point     => $start_point,
3003                                                        end_point       => $end_point,
3004                                                        interval        => $interval,
3005                                                        range_func      => $range_func,
3006                                                        have_zero_chunk => $have_zero_chunk,
3007                                                     );
3008                                                  }
3009                                                  
3010                                                  sub _chunk_char {
3011  ***      0                    0             0      my ( $self, %args ) = @_;
3012  ***      0                                  0      my @required_args = qw(dbh db tbl tbl_struct chunk_col rows_in_range chunk_size);
3013  ***      0                                  0      foreach my $arg ( @required_args ) {
3014  ***      0      0                           0         die "I need a $arg argument" unless defined $args{$arg};
3015                                                     }
3016  ***      0                                  0      my $q         = $self->{Quoter};
3017  ***      0                                  0      my $db_tbl    = $q->quote($args{db}, $args{tbl});
3018  ***      0                                  0      my $dbh       = $args{dbh};
3019  ***      0                                  0      my $chunk_col = $args{chunk_col};
3020  ***      0                                  0      my $row;
3021  ***      0                                  0      my $sql;
3022                                                  
3023  ***      0                                  0      $sql = "SELECT MIN($chunk_col), MAX($chunk_col) FROM $db_tbl "
3024                                                          . "ORDER BY `$chunk_col`";
3025  ***      0                                  0      MKDEBUG && _d($dbh, $sql);
3026  ***      0                                  0      $row = $dbh->selectrow_arrayref($sql);
3027  ***      0                                  0      my ($min_col, $max_col) = ($row->[0], $row->[1]);
3028                                                  
3029  ***      0                                  0      $sql = "SELECT ORD(?) AS min_col_ord, ORD(?) AS max_col_ord";
3030  ***      0                                  0      MKDEBUG && _d($dbh, $sql);
3031  ***      0                                  0      my $ord_sth = $dbh->prepare($sql);  # avoid quoting issues
3032  ***      0                                  0      $ord_sth->execute($min_col, $max_col);
3033  ***      0                                  0      $row = $ord_sth->fetchrow_arrayref();
3034  ***      0                                  0      my ($min_col_ord, $max_col_ord) = ($row->[0], $row->[1]);
3035  ***      0                                  0      MKDEBUG && _d("Min/max col char code:", $min_col_ord, $max_col_ord);
3036                                                  
3037  ***      0                                  0      my $base;
3038  ***      0                                  0      my @chars;
3039  ***      0                                  0      MKDEBUG && _d("Table charset:", $args{tbl_struct}->{charset});
3040  ***      0      0      0                    0      if ( ($args{tbl_struct}->{charset} || "") eq "latin1" ) {
3041  ***      0                                  0         my @sorted_latin1_chars = (
3042                                                            32,  33,  34,  35,  36,  37,  38,  39,  40,  41,  42,  43,  44,  45,
3043                                                            46,  47,  48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
3044                                                            60,  61,  62,  63,  64,  65,  66,  67,  68,  69,  70,  71,  72,  73,
3045                                                            74,  75,  76,  77,  78,  79,  80,  81,  82,  83,  84,  85,  86,  87,
3046                                                            88,  89,  90,  91,  92,  93,  94,  95,  96, 123, 124, 125, 126, 161,
3047                                                           162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175,
3048                                                           176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189,
3049                                                           190, 191, 215, 216, 222, 223, 247, 255);
3050                                                  
3051  ***      0                                  0         my ($first_char, $last_char);
3052  ***      0                                  0         for my $i ( 0..$#sorted_latin1_chars ) {
3053  ***      0      0      0                    0            $first_char = $i and last if $sorted_latin1_chars[$i] >= $min_col_ord;
3054                                                        }
3055  ***      0                                  0         for my $i ( $first_char..$#sorted_latin1_chars ) {
3056  ***      0      0      0                    0            $last_char = $i and last if $sorted_latin1_chars[$i] >= $max_col_ord;
3057                                                        };
3058                                                  
3059  ***      0                                  0         @chars = map { chr $_; } @sorted_latin1_chars[$first_char..$last_char];
      ***      0                                  0   
3060  ***      0                                  0         $base  = scalar @chars;
3061                                                     }
3062                                                     else {
3063                                                  
3064  ***      0                                  0         my $tmp_tbl    = '__maatkit_char_chunking_map';
3065  ***      0                                  0         my $tmp_db_tbl = $q->quote($args{db}, $tmp_tbl);
3066  ***      0                                  0         $sql = "DROP TABLE IF EXISTS $tmp_db_tbl";
3067  ***      0                                  0         MKDEBUG && _d($dbh, $sql);
3068  ***      0                                  0         $dbh->do($sql);
3069  ***      0                                  0         my $col_def = $args{tbl_struct}->{defs}->{$chunk_col};
3070  ***      0                                  0         $sql        = "CREATE TEMPORARY TABLE $tmp_db_tbl ($col_def) "
3071                                                                    . "ENGINE=MEMORY";
3072  ***      0                                  0         MKDEBUG && _d($dbh, $sql);
3073  ***      0                                  0         $dbh->do($sql);
3074                                                  
3075  ***      0                                  0         $sql = "INSERT INTO $tmp_db_tbl VALUE (CHAR(?))";
3076  ***      0                                  0         MKDEBUG && _d($dbh, $sql);
3077  ***      0                                  0         my $ins_char_sth = $dbh->prepare($sql);  # avoid quoting issues
3078  ***      0                                  0         for my $char_code ( $min_col_ord..$max_col_ord ) {
3079  ***      0                                  0            $ins_char_sth->execute($char_code);
3080                                                        }
3081                                                  
3082  ***      0                                  0         $sql = "SELECT `$chunk_col` FROM $tmp_db_tbl "
3083                                                             . "WHERE `$chunk_col` BETWEEN ? AND ? "
3084                                                             . "ORDER BY `$chunk_col`";
3085  ***      0                                  0         MKDEBUG && _d($dbh, $sql);
3086  ***      0                                  0         my $sel_char_sth = $dbh->prepare($sql);
3087  ***      0                                  0         $sel_char_sth->execute($min_col, $max_col);
3088                                                  
3089  ***      0                                  0         @chars = map { $_->[0] } @{ $sel_char_sth->fetchall_arrayref() };
      ***      0                                  0   
      ***      0                                  0   
3090  ***      0                                  0         $base  = scalar @chars;
3091                                                  
3092  ***      0                                  0         $sql = "DROP TABLE $tmp_db_tbl";
3093  ***      0                                  0         MKDEBUG && _d($dbh, $sql);
3094  ***      0                                  0         $dbh->do($sql);
3095                                                     }
3096  ***      0                                  0      MKDEBUG && _d("Base", $base, "chars:", @chars);
3097                                                  
3098                                                  
3099  ***      0                                  0      $sql = "SELECT MAX(LENGTH($chunk_col)) FROM $db_tbl ORDER BY `$chunk_col`";
3100  ***      0                                  0      MKDEBUG && _d($dbh, $sql);
3101  ***      0                                  0      $row = $dbh->selectrow_arrayref($sql);
3102  ***      0                                  0      my $max_col_len = $row->[0];
3103  ***      0                                  0      MKDEBUG && _d("Max column value:", $max_col, $max_col_len);
3104  ***      0                                  0      my $n_values;
3105  ***      0                                  0      for my $n_chars ( 1..$max_col_len ) {
3106  ***      0                                  0         $n_values = $base**$n_chars;
3107  ***      0      0                           0         if ( $n_values >= $args{chunk_size} ) {
3108  ***      0                                  0            MKDEBUG && _d($n_chars, "chars in base", $base, "expresses",
3109                                                              $n_values, "values");
3110  ***      0                                  0            last;
3111                                                        }
3112                                                     }
3113                                                  
3114  ***      0                                  0      my $n_chunks = $args{rows_in_range} / $args{chunk_size};
3115  ***      0             0                    0      my $interval = floor($n_values / $n_chunks) || 1;
3116                                                  
3117                                                     my $range_func = sub {
3118  ***      0                    0             0         my ( $self, $dbh, $start, $interval, $max ) = @_;
3119  ***      0                                  0         my $start_char = $self->base_count(
3120                                                           count_to => $start,
3121                                                           base     => $base,
3122                                                           symbols  => \@chars,
3123                                                        );
3124  ***      0                                  0         my $end_char = $self->base_count(
3125                                                           count_to => min($max, $start + $interval),
3126                                                           base     => $base,
3127                                                           symbols  => \@chars,
3128                                                        );
3129  ***      0                                  0         return $start_char, $end_char;
3130  ***      0                                  0      };
3131                                                  
3132                                                     return (
3133  ***      0                                  0         col         => $q->quote($chunk_col),
3134                                                        start_point => 0,
3135                                                        end_point   => $n_values,
3136                                                        interval    => $interval,
3137                                                        range_func  => $range_func,
3138                                                     );
3139                                                  }
3140                                                  
3141                                                  sub get_first_chunkable_column {
3142  ***      0                    0             0      my ( $self, %args ) = @_;
3143  ***      0                                  0      foreach my $arg ( qw(tbl_struct) ) {
3144  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
3145                                                     }
3146                                                  
3147  ***      0                                  0      my ($exact, @cols) = $self->find_chunk_columns(%args);
3148  ***      0                                  0      my $col = $cols[0]->{column};
3149  ***      0                                  0      my $idx = $cols[0]->{index};
3150                                                  
3151  ***      0                                  0      my $wanted_col = $args{chunk_column};
3152  ***      0                                  0      my $wanted_idx = $args{chunk_index};
3153  ***      0                                  0      MKDEBUG && _d("Preferred chunk col/idx:", $wanted_col, $wanted_idx);
3154                                                  
3155  ***      0      0      0                    0      if ( $wanted_col && $wanted_idx ) {
      ***             0                               
      ***             0                               
3156  ***      0                                  0         foreach my $chunkable_col ( @cols ) {
3157  ***      0      0      0                    0            if (    $wanted_col eq $chunkable_col->{column}
3158                                                                && $wanted_idx eq $chunkable_col->{index} ) {
3159  ***      0                                  0               $col = $wanted_col;
3160  ***      0                                  0               $idx = $wanted_idx;
3161  ***      0                                  0               last;
3162                                                           }
3163                                                        }
3164                                                     }
3165                                                     elsif ( $wanted_col ) {
3166  ***      0                                  0         foreach my $chunkable_col ( @cols ) {
3167  ***      0      0                           0            if ( $wanted_col eq $chunkable_col->{column} ) {
3168  ***      0                                  0               $col = $wanted_col;
3169  ***      0                                  0               $idx = $chunkable_col->{index};
3170  ***      0                                  0               last;
3171                                                           }
3172                                                        }
3173                                                     }
3174                                                     elsif ( $wanted_idx ) {
3175  ***      0                                  0         foreach my $chunkable_col ( @cols ) {
3176  ***      0      0                           0            if ( $wanted_idx eq $chunkable_col->{index} ) {
3177  ***      0                                  0               $col = $chunkable_col->{column};
3178  ***      0                                  0               $idx = $wanted_idx;
3179  ***      0                                  0               last;
3180                                                           }
3181                                                        }
3182                                                     }
3183                                                  
3184  ***      0                                  0      MKDEBUG && _d('First chunkable col/index:', $col, $idx);
3185  ***      0                                  0      return $col, $idx;
3186                                                  }
3187                                                  
3188                                                  sub size_to_rows {
3189  ***      0                    0             0      my ( $self, %args ) = @_;
3190  ***      0                                  0      my @required_args = qw(dbh db tbl chunk_size);
3191  ***      0                                  0      foreach my $arg ( @required_args ) {
3192  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
3193                                                     }
3194  ***      0                                  0      my ($dbh, $db, $tbl, $chunk_size) = @args{@required_args};
3195  ***      0                                  0      my $q  = $self->{Quoter};
3196  ***      0                                  0      my $du = $self->{MySQLDump};
3197                                                  
3198  ***      0                                  0      my ($n_rows, $avg_row_length);
3199                                                  
3200  ***      0                                  0      my ( $num, $suffix ) = $chunk_size =~ m/^(\d+)([MGk])?$/;
3201  ***      0      0                           0      if ( $suffix ) { # Convert to bytes.
      ***             0                               
3202  ***      0      0                           0         $chunk_size = $suffix eq 'k' ? $num * 1_024
      ***             0                               
3203                                                                    : $suffix eq 'M' ? $num * 1_024 * 1_024
3204                                                                    :                  $num * 1_024 * 1_024 * 1_024;
3205                                                     }
3206                                                     elsif ( $num ) {
3207  ***      0                                  0         $n_rows = $num;
3208                                                     }
3209                                                     else {
3210  ***      0                                  0         die "Invalid chunk size $chunk_size; must be an integer "
3211                                                           . "with optional suffix kMG";
3212                                                     }
3213                                                  
3214  ***      0      0      0                    0      if ( $suffix || $args{avg_row_length} ) {
3215  ***      0                                  0         my ($status) = $du->get_table_status($dbh, $q, $db, $tbl);
3216  ***      0                                  0         $avg_row_length = $status->{avg_row_length};
3217  ***      0      0                           0         if ( !defined $n_rows ) {
3218  ***      0      0                           0            $n_rows = $avg_row_length ? ceil($chunk_size / $avg_row_length) : undef;
3219                                                        }
3220                                                     }
3221                                                  
3222  ***      0                                  0      return $n_rows, $avg_row_length;
3223                                                  }
3224                                                  
3225                                                  sub get_range_statistics {
3226           3                    3            42      my ( $self, %args ) = @_;
3227           3                                 20      my @required_args = qw(dbh db tbl chunk_col tbl_struct);
3228           3                                 12      foreach my $arg ( @required_args ) {
3229  ***     15     50                          69         die "I need a $arg argument" unless $args{$arg};
3230                                                     }
3231           3                                 18      my ($dbh, $db, $tbl, $col) = @args{@required_args};
3232           3                                 10      my $where = $args{where};
3233           3                                 12      my $q     = $self->{Quoter};
3234                                                  
3235           3                                 12      my $col_type       = $args{tbl_struct}->{type_for}->{$col};
3236           3                                 15      my $col_is_numeric = $args{tbl_struct}->{is_numeric}->{$col};
3237                                                  
3238           3                                 18      my $db_tbl = $q->quote($db, $tbl);
3239           3                                 15      $col       = $q->quote($col);
3240                                                  
3241           3                                 10      my ($min, $max);
3242           3                                 16      eval {
3243  ***      3     50                          40         my $sql = "SELECT MIN($col), MAX($col) FROM $db_tbl"
      ***            50                               
3244                                                                . ($args{index_hint} ? " $args{index_hint}" : "")
3245                                                                . ($where ? " WHERE ($where)" : '');
3246           3                                  7         MKDEBUG && _d($dbh, $sql);
3247           3                                  7         ($min, $max) = $dbh->selectrow_array($sql);
3248           3                                675         MKDEBUG && _d("Actual end points:", $min, $max);
3249                                                  
3250           3                                 56         ($min, $max) = $self->get_valid_end_points(
3251                                                           %args,
3252                                                           dbh      => $dbh,
3253                                                           db_tbl   => $db_tbl,
3254                                                           col      => $col,
3255                                                           col_type => $col_type,
3256                                                           min      => $min,
3257                                                           max      => $max,
3258                                                        );
3259           3                                 13         MKDEBUG && _d("Valid end points:", $min, $max);
3260                                                     };
3261  ***      3     50                          12      if ( $EVAL_ERROR ) {
3262  ***      0                                  0         die "Error getting min and max values for table $db_tbl "
3263                                                           . "on column $col: $EVAL_ERROR";
3264                                                     }
3265                                                  
3266  ***      3     50                          30      my $sql = "EXPLAIN SELECT * FROM $db_tbl"
      ***            50                               
3267                                                             . ($args{index_hint} ? " $args{index_hint}" : "")
3268                                                             . ($where ? " WHERE $where" : '');
3269           3                                  7      MKDEBUG && _d($sql);
3270           3                                  7      my $expl = $dbh->selectrow_hashref($sql);
3271                                                  
3272                                                     return (
3273           3                                 53         min           => $min,
3274                                                        max           => $max,
3275                                                        rows_in_range => $expl->{rows},
3276                                                     );
3277                                                  }
3278                                                  
3279                                                  sub inject_chunks {
3280  ***      0                    0             0      my ( $self, %args ) = @_;
3281  ***      0                                  0      foreach my $arg ( qw(database table chunks chunk_num query) ) {
3282  ***      0      0                           0         die "I need a $arg argument" unless defined $args{$arg};
3283                                                     }
3284  ***      0                                  0      MKDEBUG && _d('Injecting chunk', $args{chunk_num});
3285  ***      0                                  0      my $query   = $args{query};
3286  ***      0                                  0      my $comment = sprintf("/*%s.%s:%d/%d*/",
3287                                                        $args{database}, $args{table},
3288  ***      0                                  0         $args{chunk_num} + 1, scalar @{$args{chunks}});
3289  ***      0                                  0      $query =~ s!/\*PROGRESS_COMMENT\*/!$comment!;
3290  ***      0                                  0      my $where = "WHERE (" . $args{chunks}->[$args{chunk_num}] . ')';
3291  ***      0      0      0                    0      if ( $args{where} && grep { $_ } @{$args{where}} ) {
      ***      0                                  0   
      ***      0                                  0   
3292  ***      0                                  0         $where .= " AND ("
3293  ***      0                                  0            . join(" AND ", map { "($_)" } grep { $_ } @{$args{where}} )
      ***      0                                  0   
      ***      0                                  0   
3294                                                           . ")";
3295                                                     }
3296  ***      0                                  0      my $db_tbl     = $self->{Quoter}->quote(@args{qw(database table)});
3297  ***      0             0                    0      my $index_hint = $args{index_hint} || '';
3298                                                  
3299  ***      0                                  0      MKDEBUG && _d('Parameters:',
3300                                                        Dumper({WHERE => $where, DB_TBL => $db_tbl, INDEX_HINT => $index_hint}));
3301  ***      0                                  0      $query =~ s!/\*WHERE\*/! $where!;
3302  ***      0                                  0      $query =~ s!/\*DB_TBL\*/!$db_tbl!;
3303  ***      0                                  0      $query =~ s!/\*INDEX_HINT\*/! $index_hint!;
3304  ***      0                                  0      $query =~ s!/\*CHUNK_NUM\*/! $args{chunk_num} AS chunk_num,!;
3305                                                  
3306  ***      0                                  0      return $query;
3307                                                  }
3308                                                  
3309                                                  
3310                                                  sub value_to_number {
3311           2                    2            13      my ( $self, %args ) = @_;
3312           2                                  9      my @required_args = qw(column_type dbh);
3313           2                                  8      foreach my $arg ( @required_args ) {
3314  ***      4     50                          19         die "I need a $arg argument" unless defined $args{$arg};
3315                                                     }
3316           2                                  8      my $val = $args{value};
3317           2                                  8      my ($col_type, $dbh) = @args{@required_args};
3318           2                                  4      MKDEBUG && _d('Converting MySQL', $col_type, $val);
3319                                                  
3320  ***      2     50                           9      return unless defined $val;  # value is NULL
3321                                                  
3322           2                                 10      my %mysql_conv_func_for = (
3323                                                        timestamp => 'UNIX_TIMESTAMP',
3324                                                        date      => 'TO_DAYS',
3325                                                        time      => 'TIME_TO_SEC',
3326                                                        datetime  => 'TO_DAYS',
3327                                                     );
3328                                                  
3329           2                                  5      my $num;
3330  ***      2     50                          19      if ( $col_type =~ m/(?:int|year|float|double|decimal)$/ ) {
      ***             0                               
      ***             0                               
3331           2                                  7         $num = $val;
3332                                                     }
3333                                                     elsif ( $col_type =~ m/^(?:timestamp|date|time)$/ ) {
3334  ***      0                                  0         my $func = $mysql_conv_func_for{$col_type};
3335  ***      0                                  0         my $sql = "SELECT $func(?)";
3336  ***      0                                  0         MKDEBUG && _d($dbh, $sql, $val);
3337  ***      0                                  0         my $sth = $dbh->prepare($sql);
3338  ***      0                                  0         $sth->execute($val);
3339  ***      0                                  0         ($num) = $sth->fetchrow_array();
3340                                                     }
3341                                                     elsif ( $col_type eq 'datetime' ) {
3342  ***      0                                  0         $num = $self->timestampdiff($dbh, $val);
3343                                                     }
3344                                                     else {
3345  ***      0                                  0         die "I don't know how to chunk $col_type\n";
3346                                                     }
3347           2                                  5      MKDEBUG && _d('Converts to', $num);
3348           2                                 11      return $num;
3349                                                  }
3350                                                  
3351                                                  sub range_num {
3352           5                    5            22      my ( $self, $dbh, $start, $interval, $max ) = @_;
3353           5                                 28      my $end = min($max, $start + $interval);
3354                                                  
3355                                                  
3356  ***      5     50                          27      $start = sprintf('%.17f', $start) if $start =~ /e/;
3357  ***      5     50                          21      $end   = sprintf('%.17f', $end)   if $end   =~ /e/;
3358                                                  
3359           5                                 13      $start =~ s/\.(\d{5}).*$/.$1/;
3360           5                                 12      $end   =~ s/\.(\d{5}).*$/.$1/;
3361                                                  
3362  ***      5     50                          19      if ( $end > $start ) {
3363           5                                 23         return ( $start, $end );
3364                                                     }
3365                                                     else {
3366  ***      0                                  0         die "Chunk size is too small: $end !> $start\n";
3367                                                     }
3368                                                  }
3369                                                  
3370                                                  sub range_time {
3371  ***      0                    0             0      my ( $self, $dbh, $start, $interval, $max ) = @_;
3372  ***      0                                  0      my $sql = "SELECT SEC_TO_TIME($start), SEC_TO_TIME(LEAST($max, $start + $interval))";
3373  ***      0                                  0      MKDEBUG && _d($sql);
3374  ***      0                                  0      return $dbh->selectrow_array($sql);
3375                                                  }
3376                                                  
3377                                                  sub range_date {
3378  ***      0                    0             0      my ( $self, $dbh, $start, $interval, $max ) = @_;
3379  ***      0                                  0      my $sql = "SELECT FROM_DAYS($start), FROM_DAYS(LEAST($max, $start + $interval))";
3380  ***      0                                  0      MKDEBUG && _d($sql);
3381  ***      0                                  0      return $dbh->selectrow_array($sql);
3382                                                  }
3383                                                  
3384                                                  sub range_datetime {
3385  ***      0                    0             0      my ( $self, $dbh, $start, $interval, $max ) = @_;
3386  ***      0                                  0      my $sql = "SELECT DATE_ADD('$self->{EPOCH}', INTERVAL $start SECOND), "
3387                                                         . "DATE_ADD('$self->{EPOCH}', INTERVAL LEAST($max, $start + $interval) SECOND)";
3388  ***      0                                  0      MKDEBUG && _d($sql);
3389  ***      0                                  0      return $dbh->selectrow_array($sql);
3390                                                  }
3391                                                  
3392                                                  sub range_timestamp {
3393  ***      0                    0             0      my ( $self, $dbh, $start, $interval, $max ) = @_;
3394  ***      0                                  0      my $sql = "SELECT FROM_UNIXTIME($start), FROM_UNIXTIME(LEAST($max, $start + $interval))";
3395  ***      0                                  0      MKDEBUG && _d($sql);
3396  ***      0                                  0      return $dbh->selectrow_array($sql);
3397                                                  }
3398                                                  
3399                                                  sub timestampdiff {
3400  ***      0                    0             0      my ( $self, $dbh, $time ) = @_;
3401  ***      0                                  0      my $sql = "SELECT (COALESCE(TO_DAYS('$time'), 0) * 86400 + TIME_TO_SEC('$time')) "
3402                                                        . "- TO_DAYS('$self->{EPOCH} 00:00:00') * 86400";
3403  ***      0                                  0      MKDEBUG && _d($sql);
3404  ***      0                                  0      my ( $diff ) = $dbh->selectrow_array($sql);
3405  ***      0                                  0      $sql = "SELECT DATE_ADD('$self->{EPOCH}', INTERVAL $diff SECOND)";
3406  ***      0                                  0      MKDEBUG && _d($sql);
3407  ***      0                                  0      my ( $check ) = $dbh->selectrow_array($sql);
3408  ***      0      0                           0      die <<"   EOF"
3409                                                     Incorrect datetime math: given $time, calculated $diff but checked to $check.
3410                                                     This could be due to a version of MySQL that overflows on large interval
3411                                                     values to DATE_ADD(), or the given datetime is not a valid date.  If not,
3412                                                     please report this as a bug.
3413                                                     EOF
3414                                                        unless $check eq $time;
3415  ***      0                                  0      return $diff;
3416                                                  }
3417                                                  
3418                                                  
3419                                                  
3420                                                  
3421                                                  sub get_valid_end_points {
3422           3                    3            55      my ( $self, %args ) = @_;
3423           3                                 22      my @required_args = qw(dbh db_tbl col col_type);
3424           3                                 14      foreach my $arg ( @required_args ) {
3425  ***     12     50                          58         die "I need a $arg argument" unless $args{$arg};
3426                                                     }
3427           3                                 17      my ($dbh, $db_tbl, $col, $col_type) = @args{@required_args};
3428           3                                 13      my ($real_min, $real_max)           = @args{qw(min max)};
3429                                                  
3430  ***      3     50                          28      my $err_fmt = "Error finding a valid %s value for table $db_tbl on "
3431                                                                 . "column $col. The real %s value %s is invalid and "
3432                                                                 . "no other valid values were found.  Verify that the table "
3433                                                                 . "has at least one valid value for this column"
3434                                                                 . ($args{where} ? " where $args{where}." : ".");
3435                                                  
3436           3                                 10      my $valid_min = $real_min;
3437  ***      3     50                          14      if ( defined $valid_min ) {
3438           3                                  8         MKDEBUG && _d("Validating min end point:", $real_min);
3439           3                                 32         $valid_min = $self->_get_valid_end_point(
3440                                                           %args,
3441                                                           val      => $real_min,
3442                                                           endpoint => 'min',
3443                                                        );
3444  ***      3      0                          17         die sprintf($err_fmt, 'minimum', 'minimum',
      ***            50                               
3445                                                           (defined $real_min ? $real_min : "NULL"))
3446                                                           unless defined $valid_min;
3447                                                     }
3448                                                  
3449           3                                 10      my $valid_max = $real_max;
3450  ***      3     50                          13      if ( defined $valid_max ) {
3451           3                                  7         MKDEBUG && _d("Validating max end point:", $real_min);
3452           3                                 19         $valid_max = $self->_get_valid_end_point(
3453                                                           %args,
3454                                                           val      => $real_max,
3455                                                           endpoint => 'max',
3456                                                        );
3457  ***      3      0                          17         die sprintf($err_fmt, 'maximum', 'maximum',
      ***            50                               
3458                                                           (defined $real_max ? $real_max : "NULL"))
3459                                                           unless defined $valid_max;
3460                                                     }
3461                                                  
3462           3                                 18      return $valid_min, $valid_max;
3463                                                  }
3464                                                  
3465                                                  sub _get_valid_end_point {
3466           6                    6            72      my ( $self, %args ) = @_;
3467           6                                 53      my @required_args = qw(dbh db_tbl col col_type);
3468           6                                 24      foreach my $arg ( @required_args ) {
3469  ***     24     50                         103         die "I need a $arg argument" unless $args{$arg};
3470                                                     }
3471           6                                 29      my ($dbh, $db_tbl, $col, $col_type) = @args{@required_args};
3472           6                                 18      my $val = $args{val};
3473                                                  
3474  ***      6     50                          27      return $val unless defined $val;
3475                                                  
3476  ***      6     50                          30      my $validate = $col_type =~ m/time|date/ ? \&_validate_temporal_value
3477                                                                  :                             undef;
3478                                                  
3479  ***      6     50                          25      if ( !$validate ) {
3480           6                                 12         MKDEBUG && _d("No validator for", $col_type, "values");
3481           6                                 37         return $val;
3482                                                     }
3483                                                  
3484  ***      0      0                           0      return $val if defined $validate->($dbh, $val);
3485                                                  
3486  ***      0                                  0      MKDEBUG && _d("Value is invalid, getting first valid value");
3487  ***      0                                  0      $val = $self->get_first_valid_value(
3488                                                        %args,
3489                                                        val      => $val,
3490                                                        validate => $validate,
3491                                                     );
3492                                                  
3493  ***      0                                  0      return $val;
3494                                                  }
3495                                                  
3496                                                  sub get_first_valid_value {
3497  ***      0                    0             0      my ( $self, %args ) = @_;
3498  ***      0                                  0      my @required_args = qw(dbh db_tbl col validate endpoint);
3499  ***      0                                  0      foreach my $arg ( @required_args ) {
3500  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
3501                                                     }
3502  ***      0                                  0      my ($dbh, $db_tbl, $col, $validate, $endpoint) = @args{@required_args};
3503  ***      0      0                           0      my $tries = defined $args{tries} ? $args{tries} : 5;
3504  ***      0                                  0      my $val   = $args{val};
3505                                                  
3506  ***      0      0                           0      return unless defined $val;
3507                                                  
3508  ***      0      0                           0      my $cmp = $endpoint =~ m/min/i ? '>'
      ***             0                               
3509                                                             : $endpoint =~ m/max/i ? '<'
3510                                                             :                        die "Invalid endpoint arg: $endpoint";
3511  ***      0      0                           0      my $sql = "SELECT $col FROM $db_tbl "
      ***             0                               
3512                                                             . ($args{index_hint} ? "$args{index_hint} " : "")
3513                                                             . "WHERE $col $cmp ? AND $col IS NOT NULL "
3514                                                             . ($args{where} ? "AND ($args{where}) " : "")
3515                                                             . "ORDER BY $col LIMIT 1";
3516  ***      0                                  0      MKDEBUG && _d($dbh, $sql);
3517  ***      0                                  0      my $sth = $dbh->prepare($sql);
3518                                                  
3519  ***      0                                  0      my $last_val = $val;
3520  ***      0                                  0      while ( $tries-- ) {
3521  ***      0                                  0         $sth->execute($last_val);
3522  ***      0                                  0         my ($next_val) = $sth->fetchrow_array();
3523  ***      0                                  0         MKDEBUG && _d('Next value:', $next_val, '; tries left:', $tries);
3524  ***      0      0                           0         if ( !defined $next_val ) {
3525  ***      0                                  0            MKDEBUG && _d('No more rows in table');
3526  ***      0                                  0            last;
3527                                                        }
3528  ***      0      0                           0         if ( defined $validate->($dbh, $next_val) ) {
3529  ***      0                                  0            MKDEBUG && _d('First valid value:', $next_val);
3530  ***      0                                  0            $sth->finish();
3531  ***      0                                  0            return $next_val;
3532                                                        }
3533  ***      0                                  0         $last_val = $next_val;
3534                                                     }
3535  ***      0                                  0      $sth->finish();
3536  ***      0                                  0      $val = undef;  # no valid value found
3537                                                  
3538  ***      0                                  0      return $val;
3539                                                  }
3540                                                  
3541                                                  sub _validate_temporal_value {
3542  ***      0                    0             0      my ( $dbh, $val ) = @_;
3543  ***      0                                  0      my $sql = "SELECT IF(TIME_FORMAT(?,'%H:%i:%s')=?, TIME_TO_SEC(?), TO_DAYS(?))";
3544  ***      0                                  0      my $res;
3545  ***      0                                  0      eval {
3546  ***      0                                  0         MKDEBUG && _d($dbh, $sql, $val);
3547  ***      0                                  0         my $sth = $dbh->prepare($sql);
3548  ***      0                                  0         $sth->execute($val, $val, $val, $val);
3549  ***      0                                  0         ($res) = $sth->fetchrow_array();
3550  ***      0                                  0         $sth->finish();
3551                                                     };
3552  ***      0      0                           0      if ( $EVAL_ERROR ) {
3553  ***      0                                  0         MKDEBUG && _d($EVAL_ERROR);
3554                                                     }
3555  ***      0                                  0      return $res;
3556                                                  }
3557                                                  
3558                                                  sub get_nonzero_value {
3559  ***      0                    0             0      my ( $self, %args ) = @_;
3560  ***      0                                  0      my @required_args = qw(dbh db_tbl col col_type);
3561  ***      0                                  0      foreach my $arg ( @required_args ) {
3562  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
3563                                                     }
3564  ***      0                                  0      my ($dbh, $db_tbl, $col, $col_type) = @args{@required_args};
3565  ***      0      0                           0      my $tries = defined $args{tries} ? $args{tries} : 5;
3566  ***      0                                  0      my $val   = $args{val};
3567                                                  
3568                                                     my $is_nonzero = $col_type =~ m/time|date/ ? \&_validate_temporal_value
3569  ***      0      0             0             0                     :                             sub { return $_[1]; };
      ***      0                                  0   
3570                                                  
3571  ***      0      0                           0      if ( !$is_nonzero->($dbh, $val) ) {  # quasi-double-negative, sorry
3572  ***      0                                  0         MKDEBUG && _d('Discarding zero value:', $val);
3573  ***      0      0                           0         my $sql = "SELECT $col FROM $db_tbl "
      ***             0                               
3574                                                                . ($args{index_hint} ? "$args{index_hint} " : "")
3575                                                                . "WHERE $col > ? AND $col IS NOT NULL "
3576                                                                . ($args{where} ? "AND ($args{where}) " : '')
3577                                                                . "ORDER BY $col LIMIT 1";
3578  ***      0                                  0         MKDEBUG && _d($sql);
3579  ***      0                                  0         my $sth = $dbh->prepare($sql);
3580                                                  
3581  ***      0                                  0         my $last_val = $val;
3582  ***      0                                  0         while ( $tries-- ) {
3583  ***      0                                  0            $sth->execute($last_val);
3584  ***      0                                  0            my ($next_val) = $sth->fetchrow_array();
3585  ***      0      0                           0            if ( $is_nonzero->($dbh, $next_val) ) {
3586  ***      0                                  0               MKDEBUG && _d('First non-zero value:', $next_val);
3587  ***      0                                  0               $sth->finish();
3588  ***      0                                  0               return $next_val;
3589                                                           }
3590  ***      0                                  0            $last_val = $next_val;
3591                                                        }
3592  ***      0                                  0         $sth->finish();
3593  ***      0                                  0         $val = undef;  # no non-zero value found
3594                                                     }
3595                                                  
3596  ***      0                                  0      return $val;
3597                                                  }
3598                                                  
3599                                                  sub base_count {
3600  ***      0                    0             0      my ( $self, %args ) = @_;
3601  ***      0                                  0      my @required_args = qw(count_to base symbols);
3602  ***      0                                  0      foreach my $arg ( @required_args ) {
3603  ***      0      0                           0         die "I need a $arg argument" unless defined $args{$arg};
3604                                                     }
3605  ***      0                                  0      my ($n, $base, $symbols) = @args{@required_args};
3606                                                  
3607  ***      0      0                           0      return $symbols->[0] if $n == 0;
3608                                                  
3609  ***      0                                  0      my $highest_power = floor(log($n)/log($base));
3610  ***      0      0                           0      if ( $highest_power == 0 ){
3611  ***      0                                  0         return $symbols->[$n];
3612                                                     }
3613                                                  
3614  ***      0                                  0      my @base_powers;
3615  ***      0                                  0      for my $power ( 0..$highest_power ) {
3616  ***      0             0                    0         push @base_powers, ($base**$power) || 1;  
3617                                                     }
3618                                                  
3619  ***      0                                  0      my @base_multiples;
3620  ***      0                                  0      foreach my $base_power ( reverse @base_powers ) {
3621  ***      0                                  0         my $multiples = floor($n / $base_power);
3622  ***      0                                  0         push @base_multiples, $multiples;
3623  ***      0                                  0         $n -= $multiples * $base_power;
3624                                                     }
3625                                                  
3626  ***      0                                  0      return join('', map { $symbols->[$_] } @base_multiples);
      ***      0                                  0   
3627                                                  }
3628                                                  
3629                                                  sub _d {
3630  ***      0                    0             0      my ($package, undef, $line) = caller 0;
3631  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
3632  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
3633                                                          @_;
3634  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
3635                                                  }
3636                                                  
3637                                                  1;
3638                                                  
3639                                                  # ###########################################################################
3640                                                  # End TableChunker package
3641                                                  # ###########################################################################
3642                                                  
3643                                                  # ###########################################################################
3644                                                  # Progress package 7096
3645                                                  # This package is a copy without comments from the original.  The original
3646                                                  # with comments and its test file can be found in the SVN repository at,
3647                                                  #   trunk/common/Progress.pm
3648                                                  #   trunk/common/t/Progress.t
3649                                                  # See http://code.google.com/p/maatkit/wiki/Developers for more information.
3650                                                  # ###########################################################################
3651                                                  package Progress;
3652                                                  
3653           3                    3            31   use strict;
               3                                  7   
               3                                 22   
3654           3                    3            19   use warnings FATAL => 'all';
               3                                  6   
               3                                 20   
3655                                                  
3656           3                    3            18   use English qw(-no_match_vars);
               3                                 11   
               3                                 30   
3657           3                    3            22   use Data::Dumper;
               3                                  7   
               3                                 19   
3658                                                  $Data::Dumper::Indent    = 1;
3659                                                  $Data::Dumper::Sortkeys  = 1;
3660                                                  $Data::Dumper::Quotekeys = 0;
3661                                                  
3662  ***      3            50      3            23   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               3                                  7   
               3                                 47   
3663                                                  
3664                                                  sub new {
3665           3                    3            26      my ( $class, %args ) = @_;
3666           3                                 18      foreach my $arg (qw(jobsize)) {
3667  ***      3     50                          19         die "I need a $arg argument" unless defined $args{$arg};
3668                                                     }
3669  ***      3     50     33                   24      if ( (!$args{report} || !$args{interval}) ) {
3670  ***      3     50     33                   25         if ( $args{spec} && @{$args{spec}} == 2 ) {
               3                                 26   
3671           3                                 10            @args{qw(report interval)} = @{$args{spec}};
               3                                 29   
3672                                                        }
3673                                                        else {
3674  ***      0                                  0            die "I need either report and interval arguments, or a spec";
3675                                                        }
3676                                                     }
3677                                                  
3678  ***      3            50                   19      my $name  = $args{name} || "Progress";
3679  ***      3            33                   20      $args{start} ||= time();
3680           3                                  8      my $self;
3681                                                     $self = {
3682                                                        last_reported => $args{start},
3683                                                        fraction      => 0,       # How complete the job is
3684                                                        callback      => sub {
3685  ***      0                    0             0            my ($fraction, $elapsed, $remaining, $eta) = @_;
3686  ***      0                                  0            printf STDERR "$name: %3d%% %s remain\n",
3687                                                              $fraction * 100,
3688                                                              Transformers::secs_to_time($remaining),
3689                                                              Transformers::ts($eta);
3690                                                        },
3691           3                                 64         %args,
3692                                                     };
3693           3                                 47      return bless $self, $class;
3694                                                  }
3695                                                  
3696                                                  sub validate_spec {
3697  ***      5     50             5            41      shift @_ if $_[0] eq 'Progress'; # Permit calling as Progress-> or Progress::
3698           5                                 20      my ( $spec ) = @_;
3699  ***      5     50                          22      if ( @$spec != 2 ) {
3700  ***      0                                  0         die "spec array requires a two-part argument\n";
3701                                                     }
3702  ***      5     50                         110      if ( $spec->[0] !~ m/^(?:percentage|time|iterations)$/ ) {
3703  ***      0                                  0         die "spec array's first element must be one of "
3704                                                          . "percentage,time,iterations\n";
3705                                                     }
3706  ***      5     50                          47      if ( $spec->[1] !~ m/^\d+$/ ) {
3707  ***      0                                  0         die "spec array's second element must be an integer\n";
3708                                                     }
3709                                                  }
3710                                                  
3711                                                  sub set_callback {
3712  ***      0                    0             0      my ( $self, $callback ) = @_;
3713  ***      0                                  0      $self->{callback} = $callback;
3714                                                  }
3715                                                  
3716                                                  sub start {
3717  ***      0                    0             0      my ( $self, $start ) = @_;
3718  ***      0             0                    0      $self->{start} = $self->{last_reported} = $start || time();
3719                                                  }
3720                                                  
3721                                                  sub update {
3722           7                    7            45      my ( $self, $callback, $now ) = @_;
3723           7                                 39      my $jobsize   = $self->{jobsize};
3724  ***      7            33                   49      $now        ||= time();
3725           7                                 30      $self->{iterations}++; # How many updates have happened;
3726                                                  
3727  ***      7     50     33                  137      if ( $self->{report} eq 'time'
      ***             0      0                        
3728                                                           && $self->{interval} > $now - $self->{last_reported}
3729                                                     ) {
3730           7                                 24         return;
3731                                                     }
3732                                                     elsif ( $self->{report} eq 'iterations'
3733                                                           && ($self->{iterations} - 1) % $self->{interval} > 0
3734                                                     ) {
3735  ***      0                                  0         return;
3736                                                     }
3737  ***      0                                  0      $self->{last_reported} = $now;
3738                                                  
3739  ***      0                                  0      my $completed = $callback->();
3740  ***      0                                  0      $self->{updates}++; # How many times we have run the update callback
3741                                                  
3742  ***      0      0                           0      return if $completed > $jobsize;
3743                                                  
3744  ***      0      0                           0      my $fraction = $completed > 0 ? $completed / $jobsize : 0;
3745                                                  
3746  ***      0      0      0                    0      if ( $self->{report} eq 'percentage'
3747                                                           && $self->fraction_modulo($self->{fraction})
3748                                                              >= $self->fraction_modulo($fraction)
3749                                                     ) {
3750  ***      0                                  0         $self->{fraction} = $fraction;
3751  ***      0                                  0         return;
3752                                                     }
3753  ***      0                                  0      $self->{fraction} = $fraction;
3754                                                  
3755  ***      0                                  0      my $elapsed   = $now - $self->{start};
3756  ***      0                                  0      my $remaining = 0;
3757  ***      0                                  0      my $eta       = $now;
3758  ***      0      0      0                    0      if ( $completed > 0 && $completed <= $jobsize && $elapsed > 0 ) {
      ***                    0                        
3759  ***      0                                  0         my $rate = $completed / $elapsed;
3760  ***      0      0                           0         if ( $rate > 0 ) {
3761  ***      0                                  0            $remaining = ($jobsize - $completed) / $rate;
3762  ***      0                                  0            $eta       = $now + int($remaining);
3763                                                        }
3764                                                     }
3765  ***      0                                  0      $self->{callback}->($fraction, $elapsed, $remaining, $eta, $completed);
3766                                                  }
3767                                                  
3768                                                  sub fraction_modulo {
3769  ***      0                    0             0      my ( $self, $num ) = @_;
3770  ***      0                                  0      $num *= 100; # Convert from fraction to percentage
3771  ***      0                                  0      return sprintf('%d',
3772                                                        sprintf('%d', $num / $self->{interval}) * $self->{interval});
3773                                                  }
3774                                                  
3775                                                  sub _d {
3776  ***      0                    0             0      my ($package, undef, $line) = caller 0;
3777  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
3778  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
3779                                                          @_;
3780  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
3781                                                  }
3782                                                  
3783                                                  1;
3784                                                  
3785                                                  # ###########################################################################
3786                                                  # End Progress package
3787                                                  # ###########################################################################
3788                                                  
3789                                                  # ###########################################################################
3790                                                  # OSCCaptureSync package 7308
3791                                                  # This package is a copy without comments from the original.  The original
3792                                                  # with comments and its test file can be found in the SVN repository at,
3793                                                  #   trunk/common/OSCCaptureSync.pm
3794                                                  #   trunk/common/t/OSCCaptureSync.t
3795                                                  # See http://code.google.com/p/maatkit/wiki/Developers for more information.
3796                                                  # ###########################################################################
3797                                                  
3798                                                  package OSCCaptureSync;
3799                                                  
3800           3                    3            27   use strict;
               3                                  8   
               3                                 20   
3801           3                    3            17   use warnings FATAL => 'all';
               3                                  7   
               3                                 16   
3802           3                    3            19   use English qw(-no_match_vars);
               3                                 10   
               3                                 16   
3803  ***      3            50      3            19   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               3                                  8   
               3                                 45   
3804                                                  
3805                                                  sub new {
3806           5                    5            25      my ( $class, %args ) = @_;
3807           5                                 20      my @required_args = qw();
3808           5                                 24      foreach my $arg ( @required_args ) {
3809  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
3810                                                     }
3811                                                  
3812           5                                 20      my $self = {
3813                                                        %args,
3814                                                     };
3815                                                  
3816           5                                 59      return bless $self, $class;
3817                                                  }
3818                                                  
3819                                                  sub capture {
3820           3                    3            57      my ( $self, %args ) = @_;
3821           3                                 26      my @required_args = qw(dbh msg old_table new_table columns chunk_column);
3822           3                                 17      foreach my $arg ( @required_args ) {
3823  ***     18     50                          78         die "I need a $arg argument" unless $args{$arg};
3824                                                     }
3825           3                                 17      my ($dbh, $msg) = @args{@required_args};
3826                                                  
3827           3                                 28      my @triggers = $self->_make_triggers(%args);
3828           3                                 16      foreach my $sql ( @triggers ) {
3829           9                                 64         $msg->($sql);
3830  ***      9     50                      750988         $dbh->do($sql) unless $args{print};
3831                                                     }
3832                                                  
3833           3                                 71      return;
3834                                                  }
3835                                                  
3836                                                  sub _make_triggers {
3837           3                    3            45      my ( $self, %args ) = @_;
3838           3                                 27      my @required_args = qw(old_table new_table chunk_column columns);
3839           3                                 15      foreach my $arg ( @required_args ) {
3840  ***     12     50                          57         die "I need a $arg argument" unless $args{$arg};
3841                                                     }
3842           3                                 15      my ($old_table, $new_table, $chunk_column) = @args{@required_args};
3843                                                  
3844           3                                 10      my $new_values = join(', ', map { "NEW.$_" } @{$args{columns}});
               9                                 39   
               3                                 13   
3845           3                                  9      my $columns    = join(', ', @{$args{columns}});
               3                                 15   
3846                                                  
3847           3                                 26      my $delete_trigger = "CREATE TRIGGER mk_osc_del AFTER DELETE ON $old_table "
3848                                                                        . "FOR EACH ROW "
3849                                                                        . "DELETE IGNORE FROM $new_table "
3850                                                                        . "WHERE $new_table.$chunk_column = OLD.$chunk_column";
3851                                                  
3852           3                                 26      my $insert_trigger = "CREATE TRIGGER mk_osc_ins AFTER INSERT ON $old_table "
3853                                                                        . "FOR EACH ROW "
3854                                                                        . "REPLACE INTO $new_table ($columns) "
3855                                                                        . "VALUES($new_values)";
3856                                                  
3857           3                                 22      my $update_trigger = "CREATE TRIGGER mk_osc_upd AFTER UPDATE ON $old_table "
3858                                                                        . "FOR EACH ROW "
3859                                                                        . "REPLACE INTO $new_table ($columns) "
3860                                                                        . "VALUES ($new_values)";
3861                                                  
3862           3                                 31      return $delete_trigger, $update_trigger, $insert_trigger;
3863                                                  }
3864                                                  
3865                                                  sub sync {
3866           3                    3            55      my ( $self, %args ) = @_;
3867           3                                 19      my @required_args = qw();
3868           3                                 20      foreach my $arg ( @required_args ) {
3869  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
3870                                                     }
3871           3                                 16      return;
3872                                                  }
3873                                                  
3874                                                  sub cleanup {
3875           4                    4            49      my ( $self, %args ) = @_;
3876           4                                 46      my @required_args = qw(dbh db msg);
3877           4                                 24      foreach my $arg ( @required_args ) {
3878  ***     12     50                          64         die "I need a $arg argument" unless $args{$arg};
3879                                                     }
3880           4                                 23      my ($dbh, $db, $msg) = @args{@required_args};
3881                                                  
3882           4                                 19      foreach my $trigger ( qw(del ins upd) ) {
3883          12                                101         my $sql = "DROP TRIGGER IF EXISTS `$db`.`mk_osc_$trigger`";
3884          12                                 69         $msg->($sql);
3885  ***     12     50                      240077         $dbh->do($sql) unless $args{print};
3886                                                     }
3887                                                  
3888           4                                 56      return;
3889                                                  }
3890                                                  
3891                                                  sub _d {
3892  ***      0                    0             0      my ($package, undef, $line) = caller 0;
3893  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
3894  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
3895                                                          @_;
3896  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
3897                                                  }
3898                                                  
3899                                                  1;
3900                                                  
3901                                                  # ###########################################################################
3902                                                  # End OSCCaptureSync package
3903                                                  # ###########################################################################
3904                                                  
3905                                                  # ###########################################################################
3906                                                  # CopyRowsInsertSelect package 7349
3907                                                  # This package is a copy without comments from the original.  The original
3908                                                  # with comments and its test file can be found in the SVN repository at,
3909                                                  #   trunk/common/CopyRowsInsertSelect.pm
3910                                                  #   trunk/common/t/CopyRowsInsertSelect.t
3911                                                  # See http://code.google.com/p/maatkit/wiki/Developers for more information.
3912                                                  # ###########################################################################
3913                                                  
3914                                                  package CopyRowsInsertSelect;
3915                                                  
3916           3                    3            20   use strict;
               3                                  7   
               3                                 16   
3917           3                    3            18   use warnings FATAL => 'all';
               3                                  7   
               3                                 23   
3918           3                    3            17   use English qw(-no_match_vars);
               3                                  8   
               3                                 14   
3919  ***      3            50      3            18   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               3                                  8   
               3                                 93   
3920                                                  
3921                                                  sub new {
3922           5                    5            30      my ( $class, %args ) = @_;
3923           5                                 22      my @required_args = qw(Retry);
3924           5                                 22      foreach my $arg ( @required_args ) {
3925  ***      5     50                          32         die "I need a $arg argument" unless $args{$arg};
3926                                                     }
3927                                                  
3928           5                                 24      my $self = {
3929                                                        %args,
3930                                                     };
3931                                                  
3932           5                                 49      return bless $self, $class;
3933                                                  }
3934                                                  
3935                                                  sub copy {
3936           3                    3            58      my ( $self, %args ) = @_;
3937           3                                 32      my @required_args = qw(dbh msg old_table new_table chunks columns);
3938           3                                 23      foreach my $arg ( @required_args ) {
3939  ***     18     50                         145         die "I need a $arg argument" unless $args{$arg};
3940                                                     }
3941           3                                 21      my ($dbh, $msg, $old_table, $new_table, $chunks) = @args{@required_args};
3942           3                                 12      my $pr       = $args{Progress};
3943           3                                 11      my $sleep    = $args{sleep};
3944           3                                 10      my $columns  = join(', ', @{$args{columns}});
               3                                 26   
3945           3                                 14      my $n_chunks = @$chunks - 1;
3946                                                  
3947           3                                 17      for my $chunkno ( 0..$n_chunks ) {
3948  ***      7     50                          45         if ( !$chunks->[$chunkno] ) {
3949  ***      0                                  0            warn "Chunk number ", ($chunkno + 1), "is undefined";
3950  ***      0                                  0            next;
3951                                                        }
3952                                                  
3953  ***      7     50                         129         my $sql = "INSERT IGNORE INTO $new_table ($columns) "
      ***            50                               
3954                                                                . "SELECT $columns FROM $old_table "
3955                                                                . "WHERE ($chunks->[$chunkno])"
3956                                                                . ($args{where}        ? " AND ($args{where})"  : "")
3957                                                                . ($args{engine_flags} ? " $args{engine_flags}" : "");
3958                                                  
3959  ***      7     50                          33         if ( $args{print} ) {
3960  ***      0                                  0            $msg->($sql);
3961                                                        }
3962                                                        else {
3963           7                                 20            my $error;
3964                                                           $self->{Retry}->retry(
3965           2                    2        2000290               wait  => sub { sleep 1; },
3966                                                              tries => 3,
3967                                                              try   => sub {
3968           9                    9            64                  my ( %args ) = @_;
3969           9                                 30                     eval {
3970           9                             527173                        $dbh->do($sql);
3971                                                                    };
3972           9    100                         105                     if ( $EVAL_ERROR ) {
3973           2                                  7                        MKDEBUG && _d($EVAL_ERROR);
3974  ***      2     50                          34                        if ( $EVAL_ERROR =~ m/Lock wait timeout exceeded/ ) {
3975           2                                  8                           $error = $EVAL_ERROR;
3976  ***      2     50                          13                           if ( $args{tryno} > 1 ) {
3977  ***      0                                  0                              $msg->("Lock wait timeout exceeded; retrying $sql");
3978                                                                          }
3979           2                                 18                           return;
3980                                                                       }
3981  ***      0                                  0                        die $EVAL_ERROR;
3982                                                                    }
3983           7                                 97                     return 1;
3984                                                              },
3985  ***      0                    0             0               on_failure => sub { die $error; },
3986           7                                136            );
3987                                                        }
3988                                                  
3989  ***      7     50             0           263         $pr->update(sub { return $chunkno + 1; }) if $pr;
      ***      0                                  0   
3990                                                  
3991  ***      7     50     33                   64         $sleep->($chunkno + 1) if $sleep && $chunkno < $n_chunks;
3992                                                     }
3993                                                  
3994           3                                 38      return;
3995                                                  }
3996                                                  
3997                                                  sub cleanup {
3998           4                    4            86      my ( $self, %args ) = @_;
3999           4                                 30      return;
4000                                                  }
4001                                                  
4002                                                  sub _d {
4003  ***      0                    0             0      my ($package, undef, $line) = caller 0;
4004  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
4005  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
4006                                                          @_;
4007  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
4008                                                  }
4009                                                  
4010                                                  1;
4011                                                  
4012                                                  # ###########################################################################
4013                                                  # End CopyRowsInsertSelect package
4014                                                  # ###########################################################################
4015                                                  
4016                                                  # ###########################################################################
4017                                                  # Retry package 7096
4018                                                  # This package is a copy without comments from the original.  The original
4019                                                  # with comments and its test file can be found in the SVN repository at,
4020                                                  #   trunk/common/Retry.pm
4021                                                  #   trunk/common/t/Retry.t
4022                                                  # See http://code.google.com/p/maatkit/wiki/Developers for more information.
4023                                                  # ###########################################################################
4024                                                  
4025                                                  package Retry;
4026                                                  
4027           3                    3            25   use strict;
               3                                  8   
               3                                 15   
4028           3                    3            17   use warnings FATAL => 'all';
               3                                  9   
               3                                 14   
4029           3                    3            16   use English qw(-no_match_vars);
               3                                  7   
               3                                 14   
4030  ***      3            50      3            20   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               3                                  6   
               3                                 38   
4031                                                  
4032                                                  sub new {
4033           5                    5            29      my ( $class, %args ) = @_;
4034           5                                 21      my $self = {
4035                                                        %args,
4036                                                     };
4037           5                                 81      return bless $self, $class;
4038                                                  }
4039                                                  
4040                                                  sub retry {
4041           7                    7            69      my ( $self, %args ) = @_;
4042           7                                 37      my @required_args = qw(try wait);
4043           7                                 33      foreach my $arg ( @required_args ) {
4044  ***     14     50                          74         die "I need a $arg argument" unless $args{$arg};
4045                                                     };
4046           7                                 34      my ($try, $wait) = @args{@required_args};
4047  ***      7            50                   35      my $tries = $args{tries} || 3;
4048                                                  
4049           7                                 19      my $tryno = 0;
4050           7                                 38      while ( ++$tryno <= $tries ) {
4051           9                                 31         MKDEBUG && _d("Retry", $tryno, "of", $tries);
4052           9                                 23         my $result;
4053           9                                 35         eval {
4054           9                                 42            $result = $try->(tryno=>$tryno);
4055                                                        };
4056                                                  
4057           9    100                          58         if ( defined $result ) {
4058           7                                 19            MKDEBUG && _d("Try code succeeded");
4059  ***      7     50                          63            if ( my $on_success = $args{on_success} ) {
4060  ***      0                                  0               MKDEBUG && _d("Calling on_success code");
4061  ***      0                                  0               $on_success->(tryno=>$tryno, result=>$result);
4062                                                           }
4063           7                                 70            return $result;
4064                                                        }
4065                                                  
4066  ***      2     50                           9         if ( $EVAL_ERROR ) {
4067  ***      0                                  0            MKDEBUG && _d("Try code died:", $EVAL_ERROR);
4068  ***      0      0                           0            return unless $args{retry_on_die};
4069                                                        }
4070                                                  
4071  ***      2     50                          10         if ( $tryno < $tries ) {
4072           2                                  4            MKDEBUG && _d("Try code failed, calling wait code");
4073           2                                 12            $wait->(tryno=>$tryno);
4074                                                        }
4075                                                     }
4076                                                  
4077  ***      0                                  0      MKDEBUG && _d("Try code did not succeed");
4078  ***      0      0                           0      if ( my $on_failure = $args{on_failure} ) {
4079  ***      0                                  0         MKDEBUG && _d("Calling on_failure code");
4080  ***      0                                  0         $on_failure->();
4081                                                     }
4082                                                  
4083  ***      0                                  0      return;
4084                                                  }
4085                                                  
4086                                                  sub _d {
4087  ***      0                    0             0      my ($package, undef, $line) = caller 0;
4088  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
4089  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
4090                                                          @_;
4091  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
4092                                                  }
4093                                                  
4094                                                  1;
4095                                                  
4096                                                  # ###########################################################################
4097                                                  # End Retry package
4098                                                  # ###########################################################################
4099                                                  
4100                                                  # ###########################################################################
4101                                                  # This is a combination of modules and programs in one -- a runnable module.
4102                                                  # http://www.perl.com/pub/a/2006/07/13/lightning-articles.html?page=last
4103                                                  # Or, look it up in the Camel book on pages 642 and 643 in the 3rd edition.
4104                                                  #
4105                                                  # Check at the end of this package for the call to main() which actually runs
4106                                                  # the program.
4107                                                  # ###########################################################################
4108                                                  package mk_online_schema_change;
4109                                                  
4110           3                    3            21   use English qw(-no_match_vars);
               3                                  6   
               3                                 15   
4111           3                    3            21   use Time::HiRes qw(usleep);
               3                                  8   
               3                                 25   
4112           3                    3            18   use Data::Dumper;
               3                                 12   
               3                                 16   
4113                                                  $Data::Dumper::Indent    = 1;
4114                                                  $Data::Dumper::Sortkeys  = 1;
4115                                                  $Data::Dumper::Quotekeys = 0;
4116                                                  
4117                                                  Transformers->import qw(ts);
4118                                                  
4119  ***      3            50      3            18   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               3                                 10   
               3                                 38   
4120                                                  
4121                                                  my $quiet = 0;  # for msg()
4122                                                  
4123                                                  sub main {
4124           5                    5        181111      @ARGV       = @_;  # set global ARGV for this package
4125           5                                100      my $vp      = new VersionParser();
4126           5                                 68      my $q       = new Quoter();
4127           5                                 78      my $tp      = new TableParser(Quoter => $q);
4128           5                                 61      my $du      = new MySQLDump();
4129           5                                 69      my $chunker = new TableChunker(Quoter => $q, MySQLDump => $du);
4130                                                  
4131                                                     # ########################################################################
4132                                                     # Get configuration information.
4133                                                     # ########################################################################
4134           5                                 80      my $o = new OptionParser();
4135           5                                 31      $o->get_specs();
4136           5                                 76      $o->get_opts();
4137                                                  
4138           5                                 31      my $dp = $o->DSNParser();
4139           5                                 26      $dp->prop('set-vars', $o->get('set-vars'));
4140                                                  
4141           5                                 18      $quiet = $o->get('quiet');
4142                                                  
4143                                                     # Figure out which cmd line args are files (if any) and which is
4144                                                     # the DSN (if any).
4145           5                                 13      my $dsn;
4146           5                                 14      my @files;
4147           5                                 25      foreach my $arg ( @ARGV ) {
4148  ***      5     50                          58         if ( -f $arg ) {
4149  ***      0                                  0            push @files, $arg;
4150                                                        }
4151                                                        else {
4152  ***      5     50                          23            $o->save_error('Specify only 1 DSN on the command line') if $dsn;
4153           5                                 26            $dsn = $arg;
4154                                                        }
4155                                                     }
4156           5                                 42      $dsn = $dp->parse($dsn, $dp->parse_options($o));
4157  ***      5            50                   71      my ($db, $old_tbl) = $q->split_unquote($dsn->{t} || "", $dsn->{D} || "");
      ***                   50                        
4158                                                  
4159  ***      5     50                          23      if ( !$o->get('help') ) {
4160  ***      5     50                          20         if ( !$db ) {
4161  ***      0                                  0            $o->save_error("No database was specified in the DSN or by "
4162                                                              . "--database (-D)");
4163                                                        }
4164                                                  
4165  ***      5     50                          24         if ( !$dsn->{t} ) {
4166  ***      0                                  0            $o->save_error('The DSN must specify a t (table) part');
4167                                                        }
4168                                                  
4169  ***      5     50     50                   41         if ( $old_tbl && $old_tbl eq ($o->get('new-table') || "") ) {
      ***                   33                        
4170  ***      0                                  0            $o->save_error("--new-table cannot be the same as the old table");
4171                                                        }
4172                                                  
4173  ***      5     50                          20         if ( $o->get('progress') ) {
4174           5                                 16            eval { Progress->validate_spec($o->get('progress')) };
               5                                 22   
4175  ***      5     50                          25            if ( $EVAL_ERROR ) {
4176  ***      0                                  0               chomp $EVAL_ERROR;
4177  ***      0                                  0               $o->save_error("--progress $EVAL_ERROR");
4178                                                           }
4179                                                        }
4180                                                     }
4181                                                  
4182           5                                 38      $o->usage_or_errors();
4183                                                  
4184           5                                 48      msg("$PROGRAM_NAME started");
4185           5                                 18      my $exit_status = 0;
4186                                                  
4187                                                     # ########################################################################
4188                                                     # Connect to MySQL.
4189                                                     # ########################################################################
4190           5                                 36      my $dbh = get_cxn(
4191                                                        dsn          => $dsn,
4192                                                        DSNParser    => $dp,
4193                                                        OptionParser => $o,
4194                                                        AutoCommit   => 1,
4195                                                     );
4196                                                  
4197                                                     # ########################################################################
4198                                                     # Daemonize only after (potentially) asking for passwords for --ask-pass.
4199                                                     # ########################################################################
4200           5                                 20      my $daemon;
4201  ***      5     50                          20      if ( $o->get('daemonize') ) {
      ***            50                               
4202  ***      0                                  0         $daemon = new Daemon(o=>$o);
4203  ***      0                                  0         $daemon->daemonize();
4204  ***      0                                  0         MKDEBUG && _d('I am a daemon now');
4205                                                     }
4206                                                     elsif ( $o->get('pid') ) {
4207                                                        # We're not daemoninzing, it just handles PID stuff.
4208  ***      0                                  0         $daemon = new Daemon(o=>$o);
4209  ***      0                                  0         $daemon->make_PID_file();
4210                                                     }
4211                                                  
4212                                                     # ########################################################################
4213                                                     # Setup/init some vars.
4214                                                     # ########################################################################
4215  ***      5            33                   24      my $new_tbl = $o->get('new-table') || "__new_$old_tbl";
4216           5                                 39      my %tables  = (
4217                                                        db                => $db,
4218                                                        old_table         => $q->join_quote($db, $old_tbl),
4219                                                        new_table         => $q->join_quote($db, $new_tbl),
4220                                                        old_table_renamed => $q->join_quote($db, "__old_$old_tbl"),
4221                                                     );
4222           5                                 33      msg("Old table: $tables{old_table}");
4223           5                                 25      msg("New table: $tables{new_table}");
4224                                                  
4225           5                                 48      $tables{old_tbl_struct} = $tp->parse(
4226                                                        $du->get_create_table($dbh, $q, $db, $old_tbl));
4227                                                  
4228           5                                 57      my %common_modules = (
4229                                                        OptionParser  => $o,
4230                                                        DSNParser     => $dp,
4231                                                        Quoter        => $q,
4232                                                        TableParser   => $tp,
4233                                                        TableChunker  => $chunker,
4234                                                        MySQLDump     => $du,
4235                                                        VersionParser => $vp,
4236                                                     );
4237                                                  
4238                                                     # ########################################################################
4239                                                     # Create the capture-sync and copy-rows plugins.  Currently, we just have
4240                                                     # one method for each.
4241                                                     # ########################################################################
4242           5                                 61      my $capture_sync = new OSCCaptureSync();
4243           5                                 64      my $copy_rows    = new CopyRowsInsertSelect(Retry => new Retry());
4244                                                  
4245                                                     # More values are added later.  These are the minimum need to do --cleanup.
4246           5                                 39      my %plugin_args = (
4247                                                        dbh   => $dbh,
4248                                                        msg   => \&msg,  # so plugin can talk back to user
4249                                                        print => $o->get('print'),
4250                                                        where => $o->get('where'),
4251                                                        %tables,
4252                                                        %common_modules,
4253                                                     );
4254                                                  
4255  ***      5     50                          35      if ( my $sleep_time = $o->get('sleep') ) {
4256  ***      0                                  0         MKDEBUG && _d("Sleep time:", $sleep_time);
4257  ***      0                                  0         $sleep_time *= 1_000_000;  # convert to microseconds
4258                                                        $plugin_args{sleep} = sub {
4259  ***      0                    0             0            my ( $chunkno ) = @_;
4260  ***      0                                  0            MKDEBUG && _d("Sleeping after chunk", $chunkno);
4261  ***      0                                  0            usleep($sleep_time);
4262  ***      0                                  0         };
4263                                                     }
4264                                                  
4265                                                     # ########################################################################
4266                                                     # Just cleanup and exit.
4267                                                     # ########################################################################
4268           5    100                          26      if ( $o->get('cleanup-and-exit') ) {
4269           1                                  6         msg("Calling " . (ref $copy_rows). "::cleanup()");
4270           1                                 13         $copy_rows->cleanup(%plugin_args);
4271                                                  
4272           1                                  6         msg("Calling " . (ref $capture_sync) . "::cleanup()");
4273           1                                 10         $capture_sync->cleanup(%plugin_args);
4274                                                  
4275           1                                  9         msg("$PROGRAM_NAME ending for --cleanup-and-exit");
4276           1                                199         return 0;
4277                                                     }
4278                                                  
4279                                                     # ########################################################################
4280                                                     # Pre-checks.
4281                                                     # ########################################################################
4282           4                                 37      my $chunk = checks(%plugin_args);
4283           4                                 33      $plugin_args{chunk_column} = $chunk->{column};
4284           4                                 18      $plugin_args{chunk_index}  = $chunk->{index};
4285           4    100                          27      if ( $o->get('exit-after-checks') ) {
4286           1                                  6         msg("$PROGRAM_NAME ending for --exit-after-checks; all checks passed");
4287           1                                210         return 0;
4288                                                     }
4289                                                  
4290                                                     # #####################################################################
4291                                                     # Chunk the table.  If the checks pass, then this shouldn't fail.
4292                                                     # #####################################################################
4293           3                                 24      my %range_stats = $chunker->get_range_statistics(
4294                                                        dbh        => $dbh,
4295                                                        db         => $db,
4296                                                        tbl        => $old_tbl,
4297                                                        chunk_col  => $chunk->{column},
4298                                                        tbl_struct => $tables{old_tbl_struct},
4299                                                        where      => $o->get('where'),
4300                                                     );
4301           3                                 30      my @chunks = $chunker->calculate_chunks(
4302                                                        dbh        => $dbh,
4303                                                        db         => $db,
4304                                                        tbl        => $old_tbl,
4305                                                        chunk_col  => $chunk->{column},
4306                                                        tbl_struct => $tables{old_tbl_struct},
4307                                                        where      => $o->get('where'),
4308                                                        chunk_size => $o->get('chunk-size'),
4309                                                        %range_stats,
4310                                                     );
4311           3                                 16      $plugin_args{chunks}   = \@chunks;
4312           3                                 16      $plugin_args{Progress} = new Progress(
4313                                                        jobsize => scalar @chunks,
4314                                                        spec    => $o->get('progress'),
4315                                                        name    => "Copying rows",
4316                                                     );
4317           3                                 27      msg("$tables{old_table} chunked into " . scalar @chunks . " chunks");
4318                                                  
4319           3                                 10      eval {
4320           3                                 12         my $sql = "";
4321                                                        
4322                                                        # #####################################################################
4323                                                        # Create and alter the new table.
4324                                                        # #####################################################################
4325  ***      3     50                          13         if ( $o->get('create-new-table') ) {
4326           3                                 18            $sql = "CREATE TABLE $tables{new_table} LIKE $tables{old_table}";
4327           3                                 11            msg($sql);
4328  ***      3     50                          14            $dbh->do($sql) unless $o->get('print');
4329                                                        }
4330                                                  
4331           3    100                          47         if ( my $alter = $o->get('alter-new-table') ) {
4332           2                                  6            my @stmts;
4333  ***      2     50     33                   28            if ( -f $alter && -r $alter ) {
4334  ***      0                                  0               msg("Reading ALTER TABLE statements from file $alter");
4335  ***      0      0                           0               open my $fh, '<', $alter or die "Cannot open $alter: $OS_ERROR";
4336  ***      0                                  0               @stmts = <$fh>;
4337  ***      0                                  0               close $fh;
4338                                                           }
4339                                                           else {
4340           2                                 28               @stmts = split(';', $alter);
4341                                                           }
4342                                                  
4343           2                                 14            foreach my $stmt ( @stmts ) {
4344           2                                 18               $sql = "ALTER TABLE $tables{new_table} $stmt";
4345           2                                 11               msg($sql);
4346  ***      2     50                          11               $dbh->do($sql) unless $o->get('print');
4347                                                           } 
4348                                                        }
4349                                                  
4350                                                        # #####################################################################
4351                                                        # Determine what columns the two tables 
4352                                                        # #####################################################################
4353           3                                 19         my @columns;
4354                                                        # If --print is in effect, then chances are the new table wasn't
4355                                                        # created above, so we can't get it's struct.
4356  ***      3     50                          35         if ( !$o->get('print') ) {
4357           3                                 27            $tables{new_tbl_struct} = $tp->parse(
4358                                                                 $du->get_create_table($dbh, $q, $db, $new_tbl));
4359                                                  
4360           3                                 41            @columns = intersection([
4361                                                              $tables{old_tbl_struct}->{is_col},
4362                                                              $tables{new_tbl_struct}->{is_col},
4363                                                           ]);
4364                                                  
4365                                                           # Order columns according to new table because people like/expect
4366                                                           # to see things in a certain order (this has been an issue before).
4367                                                           # This just matters to us; does't make a difference to MySQL.
4368           3                                 15            my $col_posn = $tables{new_tbl_struct}->{col_posn};
4369           3                                  5            @columns = sort { $col_posn->{$a} <=> $col_posn->{$b} } @columns;
               6                                 21   
4370           3                                 25            msg("Shared columns: " . join(', ', @columns));
4371                                                        }
4372           3                                 16         $plugin_args{columns} = \@columns;
4373                                                  
4374                                                        # #####################################################################
4375                                                        # Start capturing changes to the new table.
4376                                                        # #####################################################################
4377           3                                 22         msg("Calling " . (ref $capture_sync) . "::capture()");
4378           3                                 46         $capture_sync->capture(%plugin_args);
4379                                                  
4380                                                        # #####################################################################
4381                                                        # Copy rows from new table to old table.
4382                                                        # #####################################################################
4383           3                                 54         msg("Calling " . (ref $copy_rows) . "::copy()");
4384           3                                 53         $copy_rows->copy(%plugin_args);
4385                                                  
4386                                                        # #####################################################################
4387                                                        # Sync tables.
4388                                                        # #####################################################################
4389           3                                 34         msg("Calling " . (ref $capture_sync) . "::sync()");
4390           3                                 44         $capture_sync->sync(%plugin_args);
4391                                                  
4392                                                        # #####################################################################
4393                                                        # Rename tables.
4394                                                        # #####################################################################
4395  ***      3     50                          24         if ( $o->get('rename-tables') ) {
4396           3                                 12            msg("Renaming the tables");
4397           3                                 32            $sql = "RENAME TABLE $tables{old_table} TO $tables{old_table_renamed},"
4398                                                                . " $tables{new_table} TO $tables{old_table}";
4399           3                                 11            msg($sql);
4400  ***      3     50                          14            $dbh->do($sql) unless $o->get('print');
4401           3                                 72            msg("Old table renamed to $tables{old_table_renamed}");
4402                                                        }
4403                                                  
4404                                                        # #####################################################################
4405                                                        # Cleanup.
4406                                                        # #####################################################################
4407           3                                 24         msg("Calling " . (ref $copy_rows). "::cleanup()");
4408           3                                 53         $copy_rows->cleanup(%plugin_args);
4409                                                  
4410           3                                 26         msg("Calling " . (ref $capture_sync) . "::cleanup()");
4411           3                                 32         $capture_sync->cleanup(%plugin_args);
4412                                                  
4413  ***      3    100     66                   36         if ( $o->get('rename-tables') &&  $o->get('drop-old-table') ) {
4414           2                                 17            $sql = "DROP TABLE $tables{old_table_renamed}";
4415           2                                138            msg($sql);
4416  ***      2     50                          16            $dbh->do($sql) unless $o->get('print');
4417                                                        }
4418                                                     };
4419  ***      3     50                          19      if ( $EVAL_ERROR ) {
4420  ***      0                                  0         warn "An error occurred:\n\n$EVAL_ERROR\n"
4421                                                           . "Some triggers, temp tables, etc. may not have been removed. "
4422                                                           . "Run with --cleanup-and-exit to remove these items.\n";
4423  ***      0                                  0         $exit_status = 1;
4424                                                     }
4425                                                  
4426           3                                 28      msg("$PROGRAM_NAME ended, exit status $exit_status");
4427           3                                824      return $exit_status;
4428                                                  }
4429                                                  
4430                                                  # ############################################################################
4431                                                  # Subroutines.
4432                                                  # ############################################################################
4433                                                  sub checks {
4434          10                   10         98390      my ( %args ) = @_;
4435          10                                116      my @required_args = qw(dbh old_table old_table_renamed old_tbl_struct new_table VersionParser Quoter TableParser OptionParser TableChunker);
4436          10                                 53      foreach my $arg ( @required_args ) {
4437  ***    100     50                         424         die "I need a $arg argument" unless $args{$arg};
4438                                                     }
4439          10                                 40      my ($dbh)                   = $args{dbh};
4440          10                                 56      my ($old_table, $new_table) = @args{qw(old_table new_table)};
4441          10                                 54      my ($vp, $q, $tp, $o)       = @args{qw(VersionParser Quoter TableParser OptionParser)};
4442                                                  
4443          10                                 55      my ($db, $old_tbl)   = $q->split_unquote($old_table);
4444          10                                 51      my (undef, $new_tbl) = $q->split_unquote($new_table);
4445                                                  
4446          10                                 52      my $sql = "";
4447                                                  
4448                                                     # Although triggers were introduced in 5.0.2, "Prior to MySQL 5.0.10,
4449                                                     # triggers cannot contain direct references to tables by name."
4450  ***     10     50                          73      if ( !$vp->version_ge($dbh, '5.0.10') ) {
4451  ***      0                                  0         die "This tool requires MySQL 5.0.10 or newer";
4452                                                     }
4453                                                  
4454                                                     # The old table must exist of course.
4455          10    100                          77      if ( !$tp->check_table(dbh=>$dbh, db=>$db, tbl=>$old_tbl) ) {
4456           1                                  3         die "The old table does not exist.  Create it an try again.\n";
4457                                                     }
4458                                                  
4459  ***      9     50                          64      if ( $o->get('rename-tables') ) {
4460           9                                 51         my (undef,$old_tbl_renamed) = $q->split_unquote($args{old_table_renamed});
4461           9    100                          51         if ( $tp->check_table(dbh=>$dbh, db=>$db, tbl=>$old_tbl_renamed) ) {
4462           1                                  4            die "The old renamed table $args{old_table_renamed} already exists, "
4463                                                              . "probably from a previous run.  See --drop-old-table for more "
4464                                                              . "information.\n";
4465                                                        }
4466                                                     }
4467                                                  
4468                                                     # The new table should not exist.  This could be an option, but for now
4469                                                     # we'll demand a clean slate.
4470           8    100                          47      if ( $tp->check_table(dbh=>$dbh, db=>$db, tbl=>$new_tbl) ) {
4471           1                                  3         die "The new table already exists.  Drop it and try again.\n";
4472                                                     }
4473                                                  
4474                                                     # There cannot be any triggers on the old table.
4475           7                                 40      $sql = "SHOW TRIGGERS FROM `$db` LIKE '$old_tbl'";
4476           7                                 35      msg($sql);
4477           7                                 17      my $triggers = $dbh->selectall_arrayref($sql);
4478  ***      7    100     66                 3637      if ( $triggers && @$triggers ) {
4479           1                                  3         die "The old table has triggers.  This tool needs to create its own "
4480                                                           . "triggers, so it requires that the old table does not already "
4481                                                           . "have any triggers.\n";
4482                                                     }
4483                                                  
4484                                                     # For now, we require that the old table has an exact-chunkable
4485                                                     # column (i.e. unique single-column).
4486           6                                 83      my ($exact, @chunkable_cols) = $args{TableChunker}->find_chunk_columns(
4487                                                        tbl_struct => $args{old_tbl_struct},
4488                                                        exact      => 1,
4489                                                     );
4490  ***      6    100     66                   64      if ( !$exact || !@chunkable_cols ) {
4491           1                                  3         die "The old table does not have a unique, single-column index";
4492                                                     }
4493                                                  
4494           5                                 53      msg("Old table chunk column/index: $chunkable_cols[0]->{column}/"
4495                                                        . "$chunkable_cols[0]->{index}");
4496                                                  
4497           5                                 38      $chunkable_cols[0]->{column_ddl}
4498                                                        = $args{old_tbl_struct}->{defs}->{$chunkable_cols[0]->{column}};
4499           5                                 46      $chunkable_cols[0]->{column_ddl} =~ s/AUTO_INCREMENT//i;
4500                                                  
4501           5                                 50      return $chunkable_cols[0];
4502                                                  }
4503                                                  
4504                                                  sub intersection {
4505           3                    3            12      my ( $hashes ) = @_;
4506           3                                 12      my %keys     = map { $_ => 1 } keys %{$hashes->[0]};
               9                                 41   
               3                                 16   
4507           3                                 17      my $n_hashes = (scalar @$hashes) - 1;
4508           3                                 14      my @isect    = grep { $keys{$_} } map { keys %{$hashes->[$_]} } 1..$n_hashes;
               9                                 34   
               3                                  8   
               3                                 16   
4509           3                                 22      return @isect;
4510                                                  }
4511                                                  
4512                                                  sub get_cxn {
4513           5                    5            49      my ( %args ) = @_;
4514           5                                 36      my ($dsn, $ac, $dp, $o) = @args{qw(dsn AutoCommit DSNParser OptionParser)};
4515                                                  
4516  ***      5     50                          25      if ( $o->get('ask-pass') ) {
4517  ***      0                                  0         $dsn->{p} = OptionParser::prompt_noecho("Enter password: "); 
4518                                                     }
4519           5                                 41      my $dbh = $dp->get_dbh($dp->get_cxn_params($dsn), {AutoCommit => $ac});
4520                                                  
4521  ***      5     50                          41      $dbh->do('SET SQL_LOG_BIN=0') unless $o->get('bin-log');
4522  ***      5     50                          22      $dbh->do('SET FOREIGN_KEY_CHECKS=0') unless $o->get('foreign-key-checks');
4523                                                  
4524           5                                 32      return $dbh;
4525                                                  }
4526                                                  
4527                                                  sub msg {
4528          92                   92           474      my ( $msg ) = @_;
4529          92                                348      chomp $msg;
4530          92    100                         667      print '# ', ts(time), " $msg\n" unless $quiet;
4531          92                                238      MKDEBUG && _d($msg);
4532          92                                260      return;
4533                                                  }
4534                                                  
4535                                                  # Only for tests which may not call main().
4536                                                  sub __set_quiet {
4537           1                    1            10      $quiet = $_[0];
4538                                                  }
4539                                                  
4540                                                  sub _d {
4541  ***      0                    0                    my ($package, undef, $line) = caller 0;
4542  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
4543  ***      0                                              map { defined $_ ? $_ : 'undef' }
4544                                                          @_;
4545  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
4546                                                  }
4547                                                  
4548                                                  # ############################################################################
4549                                                  # Run the program.
4550                                                  # ############################################################################
4551                                                  if ( !caller ) { exit main(@ARGV); }
4552                                                  
4553                                                  1; # Because this is a module as well as a script.
4554                                                  
4555                                                  # ############################################################################
4556                                                  # Documentation
4557                                                  # ############################################################################
4558                                                  =pod
4559                                                  
4560                                                  =head1 NAME
4561                                                  
4562                                                  mk-online-schema-change - Perform online, non-blocking schema changes to tables.
4563                                                  
4564                                                  =head1 SYNOPSIS
4565                                                  
4566                                                  Usage: mk-online-schema-change [OPTION...] DSN [FILE...]
4567                                                  
4568                                                  mk-online-schema-change performs online, non-blocking schema changes to tables.
4569                                                  
4570                                                    mk-online-schema-change h=localhost,D=db,t=tbl
4571                                                  
4572                                                  =head1 RISKS
4573                                                  
4574                                                  The following section is included to inform users about the potential risks,
4575                                                  whether known or unknown, of using this tool.  The two main categories of risks
4576                                                  are those created by the nature of the tool (e.g. read-only tools vs. read-write
4577                                                  tools) and those created by bugs.
4578                                                  
4579                                                  At the time of this release there are no known bugs that pose a serious risk.
4580                                                  
4581                                                  The authoritative source for updated information is always the online issue
4582                                                  tracking system.  Issues that affect this tool will be marked as such.  You can
4583                                                  see a list of such issues at the following URL:
4584                                                  L<http://www.maatkit.org/bugs/mk-online-schema-change>.
4585                                                  
4586                                                  See also L<"BUGS"> for more information on filing bugs and getting help.
4587                                                  
4588                                                  =head1 DESCRIPTION
4589                                                  
4590                                                  mk-online-schema-change performs online, non-blocking schema changes to tables.
4591                                                  
4592                                                  =head1 OPTIONS
4593                                                  
4594                                                  This tool accepts additional command-line arguments.  Refer to the
4595                                                  L<"SYNOPSIS"> and usage information for details.
4596                                                  
4597                                                  =over
4598                                                  
4599                                                  =item --alter-new-table
4600                                                  
4601                                                  type: string
4602                                                  
4603                                                  Semicolon-separated list of ALTER TABLE statments to execute on the new table.
4604                                                  
4605                                                  =item --ask-pass
4606                                                  
4607                                                  Prompt for a password when connecting to MySQL.
4608                                                  
4609                                                  =item --[no]bin-log
4610                                                  
4611                                                  default: yes
4612                                                  
4613                                                  Enable binary logging (C<SET SQL_LOG_BIN=1>).
4614                                                  
4615                                                  =item --charset
4616                                                  
4617                                                  short form: -A; type: string
4618                                                  
4619                                                  Default character set.  If the value is utf8, sets Perl's binmode on
4620                                                  STDOUT to utf8, passes the mysql_enable_utf8 option to DBD::mysql, and runs SET
4621                                                  NAMES UTF8 after connecting to MySQL.  Any other value sets binmode on STDOUT
4622                                                  without the utf8 layer, and runs SET NAMES after connecting to MySQL.
4623                                                  
4624                                                  =item --chunk-size
4625                                                  
4626                                                  type: size; default: 1000
4627                                                  
4628                                                  Chunk size.
4629                                                  
4630                                                  =item --cleanup-and-exit
4631                                                  
4632                                                  Cleanup and exit;
4633                                                  
4634                                                  =item --config
4635                                                  
4636                                                  type: Array
4637                                                  
4638                                                  Read this comma-separated list of config files; if specified, this must be the
4639                                                  first option on the command line.
4640                                                  
4641                                                  =item --[no]create-new-table
4642                                                  
4643                                                  default: yes
4644                                                  
4645                                                  Create the new table with C<CREATE TABLE LIKE>.
4646                                                  
4647                                                  =item --daemonize
4648                                                  
4649                                                  Fork to the background and detach from the shell.  POSIX operating systems
4650                                                  only.
4651                                                  
4652                                                  =item --database
4653                                                  
4654                                                  short form: -D; type: string
4655                                                  
4656                                                  Default database.
4657                                                  
4658                                                  =item --defaults-file
4659                                                  
4660                                                  short form: -F; type: string
4661                                                  
4662                                                  Only read mysql options from the given file.  You must give an absolute
4663                                                  pathname.
4664                                                  
4665                                                  =item --drop-old-table
4666                                                  
4667                                                  Drop the old table once the new table has been successfully synchronized.
4668                                                  
4669                                                  =item --exit-after-checks
4670                                                  
4671                                                  Run all checks then exit; do not begin online schema change.
4672                                                  
4673                                                  =item --[no]foreign-key-checks
4674                                                  
4675                                                  default: yes
4676                                                  
4677                                                  Enforce foreign key checks (FOREIGN_KEY_CHECKS=1).
4678                                                  
4679                                                  =item --help
4680                                                  
4681                                                  Show help and exit.
4682                                                  
4683                                                  =item --host
4684                                                  
4685                                                  short form: -h; type: string
4686                                                  
4687                                                  Connect to host.
4688                                                  
4689                                                  =item --log
4690                                                  
4691                                                  type: string
4692                                                  
4693                                                  Print all output to this file when daemonized.
4694                                                  
4695                                                  =item --new-table
4696                                                  
4697                                                  type: string
4698                                                  
4699                                                  Table name for new table.
4700                                                  
4701                                                  =item --password
4702                                                  
4703                                                  short form: -p; type: string
4704                                                  
4705                                                  Password to use when connecting.
4706                                                  
4707                                                  =item --pid
4708                                                  
4709                                                  type: string
4710                                                  
4711                                                  Create the given PID file when daemonized.  The file contains the process ID of
4712                                                  the daemonized instance.  The PID file is removed when the daemonized instance
4713                                                  exits.  The program checks for the existence of the PID file when starting; if
4714                                                  it exists and the process with the matching PID exists, the program exits.
4715                                                  
4716                                                  =item --port
4717                                                  
4718                                                  short form: -P; type: int
4719                                                  
4720                                                  Port number to use for connection.
4721                                                  
4722                                                  =item --print
4723                                                  
4724                                                  Don't execute SQL statements, just print them to STDOUT.
4725                                                  
4726                                                  =item --progress
4727                                                  
4728                                                  type: array; default: time,30
4729                                                  
4730                                                  Print progress reports to STDERR while copying rows.
4731                                                  
4732                                                  The value is a comma-separated list with two parts.  The first part can be
4733                                                  percentage, time, or iterations; the second part specifies how often an update
4734                                                  should be printed, in percentage, seconds, or number of iterations.
4735                                                  
4736                                                  =item --quiet
4737                                                  
4738                                                  short form: -q
4739                                                  
4740                                                  Do not print messages to STDOUT.
4741                                                  
4742                                                  =item --[no]rename-tables
4743                                                  
4744                                                  default: yes
4745                                                  
4746                                                  Rename new table to old table.
4747                                                  
4748                                                  =item --set-vars
4749                                                  
4750                                                  type: string; default: wait_timeout=10000
4751                                                  
4752                                                  Set these MySQL variables.  Immediately after connecting to MySQL, this string
4753                                                  will be appended to SET and executed.
4754                                                  
4755                                                  =item --sleep
4756                                                  
4757                                                  type: float; default: 0
4758                                                  
4759                                                  How long to sleep between chunks while copying rows.
4760                                                  
4761                                                  =item --socket
4762                                                  
4763                                                  short form: -S; type: string
4764                                                  
4765                                                  Socket file to use for connection.
4766                                                  
4767                                                  =item --user
4768                                                  
4769                                                  short form: -u; type: string
4770                                                  
4771                                                  User for login if not current user.
4772                                                  
4773                                                  =item --version
4774                                                  
4775                                                  Show version and exit.
4776                                                  
4777                                                  =item --where
4778                                                  
4779                                                  type: string
4780                                                  
4781                                                  WHERE condition to limit chunking range.
4782                                                  
4783                                                  =back
4784                                                  
4785                                                  =head1 DSN OPTIONS
4786                                                  
4787                                                  These DSN options are used to create a DSN.  Each option is given like
4788                                                  C<option=value>.  The options are case-sensitive, so P and p are not the
4789                                                  same option.  There cannot be whitespace before or after the C<=> and
4790                                                  if the value contains whitespace it must be quoted.  DSN options are
4791                                                  comma-separated.  See the L<maatkit> manpage for full details.
4792                                                  
4793                                                  =over
4794                                                  
4795                                                  =item * A
4796                                                  
4797                                                  dsn: charset; copy: yes
4798                                                  
4799                                                  Default character set.
4800                                                  
4801                                                  =item * D
4802                                                  
4803                                                  dsn: database; copy: yes
4804                                                  
4805                                                  Default database.
4806                                                  
4807                                                  =item * F
4808                                                  
4809                                                  dsn: mysql_read_default_file; copy: yes
4810                                                  
4811                                                  Only read default options from the given file
4812                                                  
4813                                                  =item * h
4814                                                  
4815                                                  dsn: host; copy: yes
4816                                                  
4817                                                  Connect to host.
4818                                                  
4819                                                  =item * p
4820                                                  
4821                                                  dsn: password; copy: yes
4822                                                  
4823                                                  Password to use when connecting.
4824                                                  
4825                                                  =item * P
4826                                                  
4827                                                  dsn: port; copy: yes
4828                                                  
4829                                                  Port number to use for connection.
4830                                                  
4831                                                  =item * S
4832                                                  
4833                                                  dsn: mysql_socket; copy: yes
4834                                                  
4835                                                  Socket file to use for connection.
4836                                                  
4837                                                  =item * t
4838                                                  
4839                                                  dsn: table; copy: no
4840                                                  
4841                                                  Table to alter.
4842                                                  
4843                                                  =item * u
4844                                                  
4845                                                  dsn: user; copy: yes
4846                                                  
4847                                                  User for login if not current user.
4848                                                  
4849                                                  =back
4850                                                  
4851                                                  =head1 DOWNLOADING
4852                                                  
4853                                                  You can download Maatkit from Google Code at
4854                                                  L<http://code.google.com/p/maatkit/>, or you can get any of the tools
4855                                                  easily with a command like the following:
4856                                                  
4857                                                     wget http://www.maatkit.org/get/toolname
4858                                                     or
4859                                                     wget http://www.maatkit.org/trunk/toolname
4860                                                  
4861                                                  Where C<toolname> can be replaced with the name (or fragment of a name) of any
4862                                                  of the Maatkit tools.  Once downloaded, they're ready to run; no installation is
4863                                                  needed.  The first URL gets the latest released version of the tool, and the
4864                                                  second gets the latest trunk code from Subversion.
4865                                                  
4866                                                  =head1 ENVIRONMENT
4867                                                  
4868                                                  The environment variable C<MKDEBUG> enables verbose debugging output in all of
4869                                                  the Maatkit tools:
4870                                                  
4871                                                     MKDEBUG=1 mk-....
4872                                                  
4873                                                  =head1 SYSTEM REQUIREMENTS
4874                                                  
4875                                                  You need Perl, DBI, DBD::mysql, and some core packages that ought to be
4876                                                  installed in any reasonably new version of Perl.
4877                                                  
4878                                                  =head1 BUGS
4879                                                  
4880                                                  For list of known bugs see L<http://www.maatkit.org/bugs/mk-online-schema-change>.
4881                                                  
4882                                                  Please use Google Code Issues and Groups to report bugs or request support:
4883                                                  L<http://code.google.com/p/maatkit/>.  You can also join #maatkit on Freenode to
4884                                                  discuss Maatkit.
4885                                                  
4886                                                  Please include the complete command-line used to reproduce the problem you are
4887                                                  seeing, the version of all MySQL servers involved, the complete output of the
4888                                                  tool when run with L<"--version">, and if possible, debugging output produced by
4889                                                  running with the C<MKDEBUG=1> environment variable.
4890                                                  
4891                                                  =head1 COPYRIGHT, LICENSE AND WARRANTY
4892                                                  
4893                                                  This program is copyright 2011-@CURRENTYEAR@ Percona Inc.
4894                                                  Feedback and improvements are welcome.
4895                                                  
4896                                                  THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
4897                                                  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
4898                                                  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
4899                                                  
4900                                                  This program is free software; you can redistribute it and/or modify it under
4901                                                  the terms of the GNU General Public License as published by the Free Software
4902                                                  Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
4903                                                  systems, you can issue `man perlgpl' or `man perlartistic' to read these
4904                                                  licenses.
4905                                                  
4906                                                  You should have received a copy of the GNU General Public License along with
4907                                                  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
4908                                                  Place, Suite 330, Boston, MA  02111-1307  USA.
4909                                                  
4910                                                  =head1 AUTHOR
4911                                                  
4912                                                  Daniel Nichter
4913                                                  
4914                                                  =head1 HISTORY AND ACKNOWLEDGEMENTS
4915                                                  
4916                                                  The "online schema change" concept was first implemented by Shlomi Noach
4917                                                  in his tool C<oak-online-alter-table>, part of
4918                                                  L<http://code.google.com/p/openarkkit/>.  Then, engineers at Facebook built
4919                                                  their version called C<OnlineSchemaChange.php>; see
4920                                                  L<http://www.facebook.com/notes/mysql-at-facebook/online-schema-change-for-mysql/430801045932>.  Searching for "online schema change" will return other
4921                                                  relevant pages about this concept.
4922                                                  
4923                                                  This implementation, C<mk-online-schema-change>, is a hybrid of Shlomi's
4924                                                  and Facebook's approach.  Shlomi's code is a full-featured tool with command
4925                                                  line options, documenation, etc., but at the time of writing it has a bug and
4926                                                  its continued support is not assured.  Facebook's tool has certain technical
4927                                                  advantages, but it's not a full-featured tool; it's more a custom job by
4928                                                  Facebook for Facebook.  C<mk-online-schema-change> is a full-featured tool
4929                                                  with stable development and support that largely employes Facebook's technical
4930                                                  approach.
4931                                                  
4932                                                  This implementation was made possible by a generous client of Percona Inc.
4933                                                  
4934                                                  =head1 ABOUT MAATKIT
4935                                                  
4936                                                  This tool is part of Maatkit, a toolkit for power users of MySQL.  Maatkit
4937                                                  was created by Baron Schwartz; Baron and Daniel Nichter are the primary
4938                                                  code contributors.  Both are employed by Percona.  Financial support for
4939                                                  Maatkit development is primarily provided by Percona and its clients. 
4940                                                  
4941                                                  =head1 VERSION
4942                                                  
4943                                                  This manual page documents Ver @VERSION@ Distrib @DISTRIB@ $Revision: 7322 $.
4944                                                  
4945                                                  =cut


Branches
--------

line  err      %   true  false   branch
----- --- ------ ------ ------   ------
51    ***      0      0      0   unless $args{$arg}
120   ***     50      0      6   unless open my $fh, '<', $file
123   ***     50      6      0   if ($contents =~ /^=head1 DSN OPTIONS/m)
133   ***     50    108      0   if ($val)
134          100      6     54   $val eq 'no' ? :
             100     48     60   $val eq 'yes' ? :
182   ***     50      0     12   unless open my $fh, '<', $file
190          100   7848     12   unless $para =~ /^=head1 $$self{'head1'}/
195          100     12     12   if $para =~ /^=over/
196          100      6      6   if $$self{'skip_rules'}
204   ***     50      0     12   unless $para
207          100    240     12   if (my($option) = $para =~ /^=item $$self{'item'}/)
214          100    192     48   if ($para =~ /: /) { }
218   ***     50      0    318   unless $$self{'attributes'}{$attrib}
222          100     54    138   if ($attribs{'short form'})
238   ***     50      0    240   if $para =~ /^=item/
240          100     24    216   if (my($base_option) = $option =~ /^\[no\](.*)/)
245          100     48    192   defined $attribs{'default'} ? :
      ***     50      0    240   $attribs{'group'} ? :
253   ***     50      0    270   unless $para
254          100     12    258   if ($para =~ /^=head1/)
258          100    240     18   if $para =~ /^=item /
262   ***     50      0     12   unless @specs
273          100    186      6   if (ref $opt) { }
278   ***     50      0    186   if (not $long)
283   ***     50      0    186   if exists $$self{'opts'}{$long}
286   ***     50      0    186   if (length $long == 1)
291          100     54    132   if ($short) { }
292   ***     50      0     54   if exists $$self{'short_opts'}{$short}
301          100     24    162   $$opt{'spec'} =~ /!/ ? :
302   ***     50      0    186   $$opt{'spec'} =~ /\+/ ? :
303   ***     50      0    186   $$opt{'desc'} =~ /required/ ? :
316          100     18    168   if $type and $type =~ /[HhAadzm]/
318          100     48    138   if (my($def) = $$opt{'desc'} =~ /default\b(?: ([^)]+))?/)
319   ***     50     48      0   defined $def ? :
323          100      6    180   if ($long eq 'config')
327   ***     50      0    186   if (my($dis) = $$opt{'desc'} =~ /(disables .*)/)
340   ***     50      0      6   if ($opt =~ /mutually exclusive|one and only one/)
345   ***     50      0      6   if ($opt =~ /at least one|one and only one/)
350   ***     50      0      6   if ($opt =~ /default to/)
355   ***     50      0      6   if ($opt =~ /restricted to option groups/)
364   ***     50      6      0   if ($opt =~ /accepts additional command-line arguments/)
370   ***     50      0      6   unless $rule_ok
387   ***      0      0      0   unless exists $$self{'opts'}{$long}
411   ***      0      0      0   unless exists $$self{'opts'}{$long}
431   ***      0      0      0   exists $$self{'short_opts'}{$opt} ? :
      ***     50     15      0   exists $$self{'opts'}{$opt} ? :
436   ***     50      0     15   if ($$opt{'is_cumulative'}) { }
451   ***     50      0    154   $$self{'opts'}{$long}{'is_cumulative'} ? :
             100     63    154   exists $$self{'defaults'}{$long} ? :
460   ***     50      0      7   if (@ARGV and $ARGV[0] eq '--config')
464   ***     50      7      0   if ($self->has('config'))
470   ***     50     28      0   if ($EVAL_ERROR)
471   ***     50      0     28   $self->got('config') ? :
486   ***     50      0      7   unless GetOptions map({$$_{'spec'}, sub {
	$self->_set_option(@_);
}
;} grep({$$_{'long'} ne 'config';} values %{$$self{'opts'};}))
489   ***     50      0      7   if (exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'})
490   ***      0      0      0   unless printf "%s  Ver %s Distrib %s Changeset %s\n", $$self{'program_name'}, $main::VERSION, $main::DISTRIB, $main::SVN_REV
496   ***     50      0      7   if (@ARGV and $$self{'strict'})
502   ***      0      0      0   if (@set > 1)
513   ***      0      0      0   if (@set == 0)
532   ***     50      0    217   unless $long
534          100     15    202   if ($$opt{'got'}) { }
      ***     50      0    202   elsif ($$opt{'is_required'}) { }
535   ***     50      0     15   if (exists $$self{'disables'}{$long})
542   ***     50      0     15   if (exists $$self{'allowed_groups'}{$long})
554   ***      0      0      0   if $restricted_opt eq $long
555   ***      0      0      0   if $$self{'opts'}{$restricted_opt}{'got'}
560   ***      0      0      0   if (@restricted_opts)
562   ***      0      0      0   if (@restricted_opts == 1) { }
583   ***     50    217      0   if ($$opt{'parsed'}) { }
591   ***     50      0      7   if @long == $long_last
601   ***     50      0    217   unless $opt
603          100     91    126   if (not $$opt{'type'})
610   ***     50      0    126   if ($val and $$opt{'type'} eq 'm') { }
      ***     50      0    126   elsif ($val and $$opt{'type'} eq 'd') { }
             100      7    119   elsif ($val and $$opt{'type'} eq 'z') { }
      ***     50      0    119   elsif ($$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h') { }
             100     14    105   elsif ($$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a') { }
613   ***      0      0      0   if (not $suffix)
619   ***      0      0      0   if ($suffix =~ /[smhd]/) { }
620   ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***      0      0      0   $suffix eq 's' ? :
635   ***      0      0      0   if ($from_key)
637   ***      0      0      0   if ($$self{'opts'}{$from_key}{'parsed'}) { }
670          100     45    140   length $opt == 1 ? :
671   ***     50      0    185   unless $long and exists $$self{'opts'}{$long}
678   ***     50      0     28   length $opt == 1 ? :
679   ***     50      0     28   unless $long and exists $$self{'opts'}{$long}
686          100     45      7   length $opt == 1 ? :
687          100     47      5   defined $long ? :
692   ***      0      0      0   length $opt == 1 ? :
693   ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
712   ***      0      0      0   unless $$self{'usage'}
718   ***      0      0      0   unless $$self{'description'}
723   ***      0      0      0   unless $ENV{'DONT_BREAK_LINES'}
733   ***     50      5      0   if (not $$self{'description'} or not $$self{'usage'})
742   ***     50      0      5   if ($$self{'opts'}{'help'}{'got'}) { }
      ***     50      0      5   elsif (scalar @{$$self{'errors'};}) { }
743   ***      0      0      0   unless print $self->print_usage
744   ***      0      0      0   unless $return
747   ***      0      0      0   unless print $self->print_errors
748   ***      0      0      0   unless $return
757   ***      0      0      0   if (my(@errors) = @{$$self{'errors'};})
766   ***      0      0      0   unless $$self{'got_opts'}
769   ***      0      0      0   $$_{'is_negatable'} ? :
      ***      0      0      0   $$_{'type'} ? :
777   ***      0      0      0   $$self{'opts'}{$_}{'is_negatable'} ? :
      ***      0      0      0   $$self{'opts'}{$_}{'type'} ? :
797   ***      0      0      0   $group eq 'default' ? :
803   ***      0      0      0   $$opt{'is_negatable'} ? :
807   ***      0      0      0   $$opt{'type'} ? :
809   ***      0      0      0   if ($$opt{'type'} and $$opt{'type'} eq 'm')
818   ***      0      0      0   if ($short) { }
829   ***      0      0      0   if (my(@rules) = @{$$self{'rules'};})
833   ***      0      0      0   if ($$self{'DSNParser'})
841   ***      0      0      0   $val ? :
      ***      0      0      0   $type =~ /A|a/ ? :
      ***      0      0      0   $type =~ /H|h/ ? :
      ***      0      0      0   $type eq 'd' ? :
      ***      0      0      0   !defined($val) ? :
      ***      0      0      0   $bool ? :
853   ***      0      0      0   if ref $_[0] eq 'OptionParser'
856   ***      0      0      0   unless print $prompt
864   ***      0      0      0   unless print "\n"
867   ***      0      0      0   if ($EVAL_ERROR)
889   ***     50     28      0   unless open my $fh, '<', $filename
897   ***      0      0      0   if $line =~ /^\s*(?:\#|\;|$)/
900   ***      0      0      0   if ($line eq '--')
905   ***      0      0      0   if ($parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/) { }
      ***      0      0      0   elsif ($line =~ /./) { }
923   ***      0      0      0   unless open my $fh, '<', $file
927   ***      0      0      0   unless $para =~ /^=pod$/m
931   ***      0      0      0   unless $para =~ /$regex/
936   ***      0      0      0   unless close $fh
950   ***      0      0      0   $ref eq 'ARRAY' ? :
      ***      0      0      0   $ref eq 'HASH' ? :
      ***      0      0      0   !$ref ? :
966   ***     50      0      7   if (lc($val || '') eq 'null')
974   ***     50      7      0   if (defined $num) { }
975   ***     50      0      7   if ($factor)
991          100     54    132   $$attribs{'short form'} ? :
             100     24    162   $$attribs{'negatable'} ? :
      ***     50      0    186   $$attribs{'cumulative'} ? :
             100    108     78   $$attribs{'type'} ? :
1004  ***     50      0      5   unless open my $fh, '<', $file
1007  ***     50      0      5   unless $para
1016  ***     50      0      5   unless $usage and $desc
1035  ***      0      0      0   defined $_ ? :
1078         100      5      5   if (not $$self{$dbh})
1082  ***     50     10      0   $$self{$dbh} ge $self->parse($target) ? :
1089  ***      0      0      0   unless $dbh
1100  ***      0      0      0   if ($innodb)
1102  ***      0      0      0   if ($$innodb{'support'} =~ /YES|DEFAULT/i) { }
1105  ***      0      0      0   !$vars ? :
1119  ***      0      0      0   defined $_ ? :
1160  ***     50      0      9   unless $args{$arg}
1166  ***     50      0     81   if (not $$opt{'key'} or not $$opt{'desc'})
1186         100      5     34   if (@_ > 2)
1195  ***     50      0     13   if (not $dsn)
1207  ***     50     27      0   if (my($prop_key, $prop_val) = $dsn_part =~ /^(.)=(.*)$/) { }
1219         100      5    112   if (not defined $final_props{$key} and defined $$prev{$key} and $$opts{$key}{'copy'})
1225         100     85     32   if (not defined $final_props{$key})
1232  ***     50      0     27   unless exists $$opts{$key}
1237  ***     50      0     13   if (my $required = $self->prop('required'))
1239  ***      0      0      0   unless $final_props{$key}
1251  ***     50      0      5   unless ref $o eq 'OptionParser'
1254         100     40      5   if $o->has($_)
1264  ***      0      0      0   unless ref $dsn
1265  ***      0      0      0   $props ? :
1266  ***      0      0      0   $_ eq 'p' ? :
1267  ***      0      0      0   if defined $$dsn{$_}
1268  ***      0      0      0   unless not $props
1281  ***      0      0      0   $opts{$key}{'copy'} ? :
1295  ***     50      0      8   if ($driver eq 'Pg') { }
1327  ***     50      0      8   $cxn_string =~ /charset=utf8/ ? :
1336  ***     50      0      8   if ($$opts{'mysql_use_result'})
1340  ***     50      0      8   if (not $have_dbi)
1359  ***     50      8      0   if ($cxn_string =~ /mysql/i)
1366  ***     50      0      8   $sql_mode ? :
1373  ***     50      0      8   if (my($charset) = $cxn_string =~ /charset=(\w+)/)
1378  ***      0      0      0   if ($charset eq 'utf8') { }
1379  ***      0      0      0   unless binmode STDOUT, ':utf8'
1383  ***      0      0      0   unless binmode STDOUT
1387         100      5      3   if ($self->prop('set-vars'))
1394  ***     50      0      8   if (not $dbh and $EVAL_ERROR)
1396  ***      0      0      0   if ($EVAL_ERROR =~ /not a compiled character set|character set utf8/) { }
      ***      0      0      0   elsif ($EVAL_ERROR =~ m[locate DBD/mysql]i) { }
1409  ***      0      0      0   if (not $tries)
1431  ***      0      0      0   if (my($host) = ($$dbh{'mysql_hostinfo'} || '') =~ /^(\w+) via/)
1448  ***      0      0      0   ($$thing{'Type'} || '') eq 'st' ? :
      ***      0      0      0   unless printf "# Active %sh: %s %s %s\n", $$thing{'Type'} || 'undef', "\t" x $level, $thing, ($$thing{'Type'} || '') eq 'st' ? $$thing{'Statement'} || '' : ''
1458  ***      0      0      0   unless $dsn_1
1459  ***      0      0      0   unless $dsn_2
1463  ***      0      0      0   if ($args{'overwrite'}) { }
1464  ***      0      0      0   defined $$dsn_1{$key} ? :
1467  ***      0      0      0   defined $$dsn_2{$key} ? :
1476  ***      0      0      0   defined $_ ? :
1510  ***      0      0      0   unless $args{$arg}
1513  ***      0      0      0   $o->has('log') ? :
      ***      0      0      0   $o->has('pid') ? :
1529  ***      0      0      0   unless defined(my $pid = fork)
1530  ***      0      0      0   if ($pid)
1538  ***      0      0      0   unless POSIX::setsid()
1539  ***      0      0      0   unless chdir '/'
1545  ***      0      0      0   if (-t STDIN)
1547  ***      0      0      0   unless open STDIN, '/dev/null'
1551  ***      0      0      0   if ($$self{'log_file'}) { }
1553  ***      0      0      0   unless open STDOUT, '>>', $$self{'log_file'}
1557  ***      0      0      0   unless open STDERR, '>&STDOUT'
1561  ***      0      0      0   if (-t STDOUT)
1563  ***      0      0      0   unless open STDOUT, '>', '/dev/null'
1566  ***      0      0      0   if (-t STDERR)
1568  ***      0      0      0   unless open STDERR, '>', '/dev/null'
1579  ***      0      0      0   $self ? :
1581  ***      0      0      0   if ($PID_file and -f $PID_file) { }
1584  ***      0      0      0   if $EVAL_ERROR
1586  ***      0      0      0   if ($pid) { }
1588  ***      0      0      0   if ($pid_is_alive) { }
1610  ***      0      0      0   if (exists $$self{'child'})
1622  ***      0      0      0   if (not $PID_file)
1629  ***      0      0      0   unless open my $PID_FH, '>', $PID_file
1631  ***      0      0      0   unless print $PID_FH $PID
1633  ***      0      0      0   unless close $PID_FH
1642  ***      0      0      0   if ($$self{'PID_file'} and -f $$self{'PID_file'}) { }
1643  ***      0      0      0   unless unlink $$self{'PID_file'}
1656  ***      0      0      0   if ($$self{'PID_owner'} || 0) == $PID
1663  ***      0      0      0   defined $_ ? :
1708  ***     50      0     10   unless defined $val
1709  ***     50      0     10   if $val eq ''
1710  ***     50      0     10   if $val =~ /^0x[0-9a-fA-F]+$/
1720         100     15     29   if (not $tbl)
1729  ***     50      0     27   unless $like
1736  ***     50      0     15   unless $db_tbl
1738  ***     50     15      0   if (not $tbl)
1742  ***     50     15      0   if $db and not $db =~ /^`/
1743  ***     50     15      0   if $tbl and not $tbl =~ /^`/
1744  ***     50     15      0   $db ? :
1796  ***      0      0      0   defined $args{'p_ms'} ? :
1797  ***      0      0      0   defined $args{'p_s'} ? :
1800  ***      0      0      0   if $t < 0
1802  ***      0      0      0   if $t =~ /e/
1806  ***      0      0      0   if ($t > 0 and $t <= 0.000999) { }
      ***      0      0      0   elsif ($t >= 0.001 and $t <= 0.999999) { }
      ***      0      0      0   elsif ($t >= 1) { }
1827  ***      0      0      0   $p ? :
1834  ***      0      0      0   unless $secs
1836  ***      0      0      0   $secs >= 3600 ? :
      ***      0      0      0   $secs >= 86400 ? :
1841  ***      0      0      0   $fmt eq 'h' ? :
      ***      0      0      0   $fmt eq 'd' ? :
1860  ***      0      0      0   unless defined $val
1864  ***      0      0      0   if ($suffix =~ /[smhd]/) { }
1865  ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***      0      0      0   $suffix eq 's' ? :
1870  ***      0      0      0   if $prefix and $prefix eq '-'
1880  ***      0      0      0   defined $args{'p'} ? :
1881  ***      0      0      0   defined $args{'d'} ? :
1888  ***      0      0      0   $num =~ /\./ || $n ? :
1897  ***     50      0     73   $gmt ? :
1903  ***     50      0     73   if (my($us) = $time =~ /(\.\d+)$/)
1913  ***      0      0      0   if (my($y, $m, $d, $h, $i, $s, $f) = $val =~ /^$mysql_ts$/)
1916  ***      0      0      0   defined $f ? :
      ***      0      0      0   defined $f ? :
1925  ***      0      0      0   if (my($y, $m, $d, $h, $i, $s, $us) = $val =~ /^$proper_ts$/)
1926  ***      0      0      0   $gmt ? :
1929  ***      0      0      0   if (defined $us)
1941  ***      0      0      0   if (my($n, $suffix) = $val =~ /^$n_ts$/) { }
      ***      0      0      0   elsif ($val =~ /^\d{9,}/) { }
      ***      0      0      0   elsif (my($ymd, $hms) = $val =~ /^(\d{6})(?:\s+(\d+:\d+:\d+))?/) { }
      ***      0      0      0   elsif (($ymd, $hms) = $val =~ /^(\d{4}-\d\d-\d\d)(?:[T ](\d+:\d+:\d+))?/) { }
1942  ***      0      0      0   $suffix eq 'd' ? :
      ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***      0      0      0   $suffix eq 's' ? :
1956  ***      0      0      0   unless $hms
1961  ***      0      0      0   unless $hms
1966  ***      0      0      0   if $callback and ref $callback eq 'CODE'
1982  ***      0      0      0   unless $string
1988  ***      0      0      0   $comp & 1 ? :
1997  ***      0      0      0   defined $_ ? :
2034  ***     50      0      6   unless $args{$arg}
2042  ***     50      0     10   unless $ddl
2043  ***     50     10      0   if (ref $ddl eq 'ARRAY')
2044  ***     50     10      0   if (lc $$ddl[0] eq 'table') { }
2054  ***     50      0     10   if (not $ddl =~ /CREATE (?:TEMPORARY )?TABLE `/)
2060  ***     50     10      0   if $name
2078  ***     50      0     29   unless $type
2080         100      9     20   if ($type =~ /(?:(?:tiny|big|medium|small)?int|float|double|decimal|year)/)
2084         100     20      9   if (not $def =~ /NOT NULL/)
2088         100      9     20   $def =~ /AUTO_INCREMENT/i ? :
2122  ***      0      0      0   unless ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'} or $$tbl{'keys'}{$a}{'is_nullable'} <=> $$tbl{'keys'}{$b}{'is_nullable'}
2136  ***      0      0      0   if ($index)
2139  ***      0      0      0   if (not $best)
2140  ***      0      0      0   if ($index) { }
2153  ***      0      0      0   unless $where
2159  ***      0      0      0   if ($$expl{'possible_keys'}) { }
2163  ***      0      0      0   if ($$expl{'key'})
2183  ***     50      0     81   unless $args{$arg}
2197  ***     50      0     27   if ($EVAL_ERROR)
2201         100     16     11   if (not $$row[0] or $$row[0] ne $tbl)
2207  ***     50     11      0   unless $args{'all_privs'}
2214  ***      0      0      0   if ($EVAL_ERROR)
2218  ***      0      0      0   if (not scalar keys %$row)
2229  ***      0      0      0   $EVAL_ERROR ? :
2234  ***      0      0      0   if (not $privs =~ /select/ && $privs =~ /insert/ && $privs =~ /update/ && $can_delete)
2260  ***     50      0      9   if $key =~ /FOREIGN/
2265  ***     50      9      0   if (not $engine =~ /MEMORY|HEAP/)
2272  ***     50      0      9   if ($$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000' and $engine =~ /HEAP|MEMORY/i)
2279  ***     50      9      0   $key =~ /PRIMARY|UNIQUE/ ? :
2303         100      2      7   if ($engine =~ /InnoDB/i and not $clustered_key)
2305  ***     50      2      0   if ($$this_key{'name'} eq 'PRIMARY') { }
      ***      0      0      0   elsif ($$this_key{'is_unique'} and not $$this_key{'is_nullable'}) { }
2329  ***      0      0      0   if (not $parent =~ /\./ and $$opts{'database'})
2358  ***      0      0      0   if (($$tbl_struct{'engine'} || '') =~ /InnoDB/i) { }
2368  ***      0      0      0   unless $key_ddl =~ /,$/
2375  ***      0      0      0   if (@sec_indexes)
2392  ***      0      0      0   defined $_ ? :
2456  ***      0      0      0   if ($what eq 'table') { }
      ***      0      0      0   elsif ($what eq 'triggers') { }
      ***      0      0      0   elsif ($what eq 'view') { }
2458  ***      0      0      0   unless $ddl
2459  ***      0      0      0   if ($$ddl[0] eq 'table') { }
2473  ***      0      0      0   if ($trgs and @$trgs) { }
2476  ***      0      0      0   if ($$trg{'sql_mode'})
2480  ***      0      0      0   if ($$trg{'definer'})
2512  ***     50      0     10   if (not $new)
2524  ***     50     10      0   if (not $$self{'cache'} or not $$self{'tables'}{$db}{$tbl})
2537  ***     50      0     10   if ($EVAL_ERROR)
2547  ***     50     10      0   if ($key) { }
2563  ***      0      0      0   if (not $$self{'cache'} or not $$self{'columns'}{$db}{$tbl})
2593  ***      0      0      0   if (not $$self{'cache'} or not $$self{'triggers'}{$db})
2606  ***      0      0      0   if ($sth->rows)
2619  ***      0      0      0   if ($tbl)
2627  ***      0      0      0   if (not $$self{'cache'} or not $$self{'databases'} or $like)
2630  ***      0      0      0   if ($like)
2638  ***      0      0      0   unless $like
2646  ***      0      0      0   if (not $$self{'cache'} or not $$self{'table_status'}{$db} or $like)
2649  ***      0      0      0   if ($like)
2664  ***      0      0      0   unless $like
2672  ***      0      0      0   if (not $$self{'cache'} or not $$self{'table_list'}{$db} or $like)
2675  ***      0      0      0   if ($like)
2683  ***      0      0      0   ($$_[1] || '') eq 'VIEW' ? :
2690  ***      0      0      0   unless $like
2698  ***      0      0      0   defined $_ ? :
2736  ***     50      0     12   unless $args{$arg}
2755  ***     50      0      6   unless $args{$arg}
2762  ***     50      0      5   unless $$index{'type'} eq 'BTREE'
2764  ***     50      0      5   if grep {defined $_;} @{$$index{'col_prefixes'};}
2766  ***     50      5      0   if ($args{'exact'})
2767  ***     50      0      5   unless $$index{'is_unique'} and @{$$index{'cols'};} == 1
2781  ***     50      0      5   unless $$self{'int_types'}{$col_type} or $$self{'real_types'}{$col_type} or $col_type =~ /char/
2788         100      5      1   if $args{'exact'} and scalar @candidate_cols
2798         100      5      1   if ($$tbl_struct{'keys'}{'PRIMARY'})
2821  ***     50      0     21   unless defined $args{$arg}
2828  ***     50      0      3   if (not $args{'rows_in_range'})
2833         100      2      1   if ($args{'rows_in_range'} < $args{'chunk_size'})
2846  ***     50      1      0   if ($$tbl_struct{'is_numeric'}{$chunk_col} or $col_type =~ /date|time/) { }
      ***      0      0      0   elsif ($col_type =~ /char/) { }
2860  ***     50      1      0   if ($start_point < $end_point) { }
2862  ***     50      0      1   if $chunker{'have_zero_chunk'}
2869         100      1      4   if ($iter++ == 0) { }
2870  ***     50      0      1   $chunker{'have_zero_chunk'} ? :
2882  ***     50      1      0   if (@chunks) { }
2883  ***     50      0      1   $chunk_range eq 'openclosed' ? :
2888  ***      0      0      0   $nullable ? :
2890  ***     50      0      1   if ($nullable)
2906  ***     50      0      7   unless defined $args{$arg}
2913  ***     50      1      0   if ($col_type =~ /(?:int|year|float|double|decimal)$/) { }
      ***      0      0      0   elsif ($col_type =~ /^(?:timestamp|date|time)$/) { }
      ***      0      0      0   elsif ($col_type eq 'datetime') { }
2936  ***     50      0      1   if ($EVAL_ERROR)
2937  ***      0      0      0   if ($EVAL_ERROR =~ /don't know how to chunk/) { }
2941  ***      0      0      0   defined $args{$_} ? :
2954  ***     50      0      1   if (not defined $start_point)
2958  ***     50      0      1   if (not defined $end_point or $end_point < $start_point)
2965  ***     50      0      1   if ($args{'zero_chunk'})
2966  ***      0      0      0   if ($start_point != $end_point and $start_point >= 0) { }
2991  ***     50      1      0   if ($$self{'int_types'}{$col_type})
2995  ***     50      0      1   if ($args{'exact'})
3014  ***      0      0      0   unless defined $args{$arg}
3040  ***      0      0      0   if (($args{'tbl_struct'}{'charset'} || '') eq 'latin1') { }
3053  ***      0      0      0   if $sorted_latin1_chars[$i] >= $min_col_ord
3056  ***      0      0      0   if $sorted_latin1_chars[$i] >= $max_col_ord
3107  ***      0      0      0   if ($n_values >= $args{'chunk_size'})
3144  ***      0      0      0   unless $args{$arg}
3155  ***      0      0      0   if ($wanted_col and $wanted_idx) { }
      ***      0      0      0   elsif ($wanted_col) { }
      ***      0      0      0   elsif ($wanted_idx) { }
3157  ***      0      0      0   if ($wanted_col eq $$chunkable_col{'column'} and $wanted_idx eq $$chunkable_col{'index'})
3167  ***      0      0      0   if ($wanted_col eq $$chunkable_col{'column'})
3176  ***      0      0      0   if ($wanted_idx eq $$chunkable_col{'index'})
3192  ***      0      0      0   unless $args{$arg}
3201  ***      0      0      0   if ($suffix) { }
      ***      0      0      0   elsif ($num) { }
3202  ***      0      0      0   $suffix eq 'M' ? :
      ***      0      0      0   $suffix eq 'k' ? :
3214  ***      0      0      0   if ($suffix or $args{'avg_row_length'})
3217  ***      0      0      0   if (not defined $n_rows)
3218  ***      0      0      0   $avg_row_length ? :
3229  ***     50      0     15   unless $args{$arg}
3243  ***     50      0      3   $args{'index_hint'} ? :
      ***     50      0      3   $where ? :
3261  ***     50      0      3   if ($EVAL_ERROR)
3266  ***     50      0      3   $args{'index_hint'} ? :
      ***     50      0      3   $where ? :
3282  ***      0      0      0   unless defined $args{$arg}
3291  ***      0      0      0   if ($args{'where'} and grep {$_;} @{$args{'where'};})
3314  ***     50      0      4   unless defined $args{$arg}
3320  ***     50      0      2   unless defined $val
3330  ***     50      2      0   if ($col_type =~ /(?:int|year|float|double|decimal)$/) { }
      ***      0      0      0   elsif ($col_type =~ /^(?:timestamp|date|time)$/) { }
      ***      0      0      0   elsif ($col_type eq 'datetime') { }
3356  ***     50      0      5   if $start =~ /e/
3357  ***     50      0      5   if $end =~ /e/
3362  ***     50      5      0   if ($end > $start) { }
3408  ***      0      0      0   unless $check eq $time
3425  ***     50      0     12   unless $args{$arg}
3430  ***     50      0      3   $args{'where'} ? :
3437  ***     50      3      0   if (defined $valid_min)
3444  ***      0      0      0   defined $real_min ? :
      ***     50      0      3   unless defined $valid_min
3450  ***     50      3      0   if (defined $valid_max)
3457  ***      0      0      0   defined $real_max ? :
      ***     50      0      3   unless defined $valid_max
3469  ***     50      0     24   unless $args{$arg}
3474  ***     50      0      6   unless defined $val
3476  ***     50      0      6   $col_type =~ /time|date/ ? :
3479  ***     50      6      0   if (not $validate)
3484  ***      0      0      0   if defined &$validate($dbh, $val)
3500  ***      0      0      0   unless $args{$arg}
3503  ***      0      0      0   defined $args{'tries'} ? :
3506  ***      0      0      0   unless defined $val
3508  ***      0      0      0   $endpoint =~ /max/i ? :
      ***      0      0      0   $endpoint =~ /min/i ? :
3511  ***      0      0      0   $args{'index_hint'} ? :
      ***      0      0      0   $args{'where'} ? :
3524  ***      0      0      0   if (not defined $next_val)
3528  ***      0      0      0   if (defined &$validate($dbh, $next_val))
3552  ***      0      0      0   if ($EVAL_ERROR)
3562  ***      0      0      0   unless $args{$arg}
3565  ***      0      0      0   defined $args{'tries'} ? :
3569  ***      0      0      0   $col_type =~ /time|date/ ? :
3571  ***      0      0      0   if (not &$is_nonzero($dbh, $val))
3573  ***      0      0      0   $args{'index_hint'} ? :
      ***      0      0      0   $args{'where'} ? :
3585  ***      0      0      0   if (&$is_nonzero($dbh, $next_val))
3603  ***      0      0      0   unless defined $args{$arg}
3607  ***      0      0      0   if $n == 0
3610  ***      0      0      0   if ($highest_power == 0)
3631  ***      0      0      0   defined $_ ? :
3667  ***     50      0      3   unless defined $args{$arg}
3669  ***     50      3      0   if (not $args{'report'} or not $args{'interval'})
3670  ***     50      3      0   if ($args{'spec'} and @{$args{'spec'};} == 2) { }
3697  ***     50      5      0   if $_[0] eq 'Progress'
3699  ***     50      0      5   if (@$spec != 2)
3702  ***     50      0      5   if (not $$spec[0] =~ /^(?:percentage|time|iterations)$/)
3706  ***     50      0      5   if (not $$spec[1] =~ /^\d+$/)
3727  ***     50      7      0   if ($$self{'report'} eq 'time' and $$self{'interval'} > $now - $$self{'last_reported'}) { }
      ***      0      0      0   elsif ($$self{'report'} eq 'iterations' and ($$self{'iterations'} - 1) % $$self{'interval'} > 0) { }
3742  ***      0      0      0   if $completed > $jobsize
3744  ***      0      0      0   $completed > 0 ? :
3746  ***      0      0      0   if ($$self{'report'} eq 'percentage' and $self->fraction_modulo($$self{'fraction'}) >= $self->fraction_modulo($fraction))
3758  ***      0      0      0   if ($completed > 0 and $completed <= $jobsize and $elapsed > 0)
3760  ***      0      0      0   if ($rate > 0)
3777  ***      0      0      0   defined $_ ? :
3809  ***      0      0      0   unless $args{$arg}
3823  ***     50      0     18   unless $args{$arg}
3830  ***     50      9      0   unless $args{'print'}
3840  ***     50      0     12   unless $args{$arg}
3869  ***      0      0      0   unless $args{$arg}
3878  ***     50      0     12   unless $args{$arg}
3885  ***     50     12      0   unless $args{'print'}
3893  ***      0      0      0   defined $_ ? :
3925  ***     50      0      5   unless $args{$arg}
3939  ***     50      0     18   unless $args{$arg}
3948  ***     50      0      7   if (not $$chunks[$chunkno])
3953  ***     50      0      7   $args{'where'} ? :
      ***     50      0      7   $args{'engine_flags'} ? :
3959  ***     50      0      7   if ($args{'print'}) { }
3972         100      2      7   if ($EVAL_ERROR)
3974  ***     50      2      0   if ($EVAL_ERROR =~ /Lock wait timeout exceeded/)
3976  ***     50      0      2   if ($args{'tryno'} > 1)
3989  ***     50      7      0   if $pr
3991  ***     50      0      7   if $sleep and $chunkno < $n_chunks
4004  ***      0      0      0   defined $_ ? :
4044  ***     50      0     14   unless $args{$arg}
4057         100      7      2   if (defined $result)
4059  ***     50      0      7   if (my $on_success = $args{'on_success'})
4066  ***     50      0      2   if ($EVAL_ERROR)
4068  ***      0      0      0   unless $args{'retry_on_die'}
4071  ***     50      2      0   if ($tryno < $tries)
4078  ***      0      0      0   if (my $on_failure = $args{'on_failure'})
4088  ***      0      0      0   defined $_ ? :
4148  ***     50      0      5   if (-f $arg) { }
4152  ***     50      0      5   if $dsn
4159  ***     50      5      0   if (not $o->get('help'))
4160  ***     50      0      5   if (not $db)
4165  ***     50      0      5   if (not $$dsn{'t'})
4169  ***     50      0      5   if ($old_tbl and $old_tbl eq ($o->get('new-table') || ''))
4173  ***     50      5      0   if ($o->get('progress'))
4175  ***     50      0      5   if ($EVAL_ERROR)
4201  ***     50      0      5   if ($o->get('daemonize')) { }
      ***     50      0      5   elsif ($o->get('pid')) { }
4255  ***     50      0      5   if (my $sleep_time = $o->get('sleep'))
4268         100      1      4   if ($o->get('cleanup-and-exit'))
4285         100      1      3   if ($o->get('exit-after-checks'))
4325  ***     50      3      0   if ($o->get('create-new-table'))
4328  ***     50      3      0   unless $o->get('print')
4331         100      2      1   if (my $alter = $o->get('alter-new-table'))
4333  ***     50      0      2   if (-f $alter and -r $alter) { }
4335  ***      0      0      0   unless open my $fh, '<', $alter
4346  ***     50      2      0   unless $o->get('print')
4356  ***     50      3      0   if (not $o->get('print'))
4395  ***     50      3      0   if ($o->get('rename-tables'))
4400  ***     50      3      0   unless $o->get('print')
4413         100      2      1   if ($o->get('rename-tables') and $o->get('drop-old-table'))
4416  ***     50      2      0   unless $o->get('print')
4419  ***     50      0      3   if ($EVAL_ERROR)
4437  ***     50      0    100   unless $args{$arg}
4450  ***     50      0     10   if (not $vp->version_ge($dbh, '5.0.10'))
4455         100      1      9   if (not $tp->check_table('dbh', $dbh, 'db', $db, 'tbl', $old_tbl))
4459  ***     50      9      0   if ($o->get('rename-tables'))
4461         100      1      8   if ($tp->check_table('dbh', $dbh, 'db', $db, 'tbl', $old_tbl_renamed))
4470         100      1      7   if ($tp->check_table('dbh', $dbh, 'db', $db, 'tbl', $new_tbl))
4478         100      1      6   if ($triggers and @$triggers)
4490         100      1      5   if (not $exact or not @chunkable_cols)
4516  ***     50      0      5   if ($o->get('ask-pass'))
4521  ***     50      0      5   unless $o->get('bin-log')
4522  ***     50      0      5   unless $o->get('foreign-key-checks')
4530         100     73     19   unless $quiet
4542  ***      0      0      0   defined $_ ? :


Conditions
----------

and 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
2788  ***     50      0      6   $args{'exact'} and scalar @candidate_cols

and 3 conditions

line  err      %     !l  l&&!r   l&&r   expr
----- --- ------ ------ ------ ------   ----
316          100     78     90     18   $type and $type =~ /[HhAadzm]/
460   ***     66      1      6      0   @ARGV and $ARGV[0] eq '--config'
489   ***     33      0      7      0   exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'}
496   ***     66      2      5      0   @ARGV and $$self{'strict'}
610   ***     66     91     35      0   $val and $$opt{'type'} eq 'm'
      ***     66     91     35      0   $val and $$opt{'type'} eq 'd'
             100     91     28      7   $val and $$opt{'type'} eq 'z'
      ***     66     84     35      0   defined $val and $$opt{'type'} eq 'h'
             100     84     21      7   defined $val and $$opt{'type'} eq 'a'
671   ***     33      0      0    185   $long and exists $$self{'opts'}{$long}
679   ***     33      0      0     28   $long and exists $$self{'opts'}{$long}
693   ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
809   ***      0      0      0      0   $$opt{'type'} and $$opt{'type'} eq 'm'
905   ***      0      0      0      0   $parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/
1006  ***     66      0      5   2990   defined($para = <$fh>) and not $para =~ /^=head1 SYNOPSIS/
1016  ***     33      0      0      5   $usage and $desc
1219         100     27     85      5   not defined $final_props{$key} and defined $$prev{$key}
      ***     66    112      0      5   not defined $final_props{$key} and defined $$prev{$key} and $$opts{$key}{'copy'}
1352  ***     66      8      0      8   not $dbh and $tries--
1394  ***     33      8      0      0   not $dbh and $EVAL_ERROR
1581  ***      0      0      0      0   $PID_file and -f $PID_file
1642  ***      0      0      0      0   $$self{'PID_file'} and -f $$self{'PID_file'}
1742  ***     33      0      0     15   $db and not $db =~ /^`/
1743  ***     33      0      0     15   $tbl and not $tbl =~ /^`/
1806  ***      0      0      0      0   $t > 0 and $t <= 0.000999
      ***      0      0      0      0   $t >= 0.001 and $t <= 0.999999
1870  ***      0      0      0      0   $prefix and $prefix eq '-'
1884  ***      0      0      0      0   $num >= $d and $n < @units - 1
1966  ***      0      0      0      0   $callback and ref $callback eq 'CODE'
2234  ***      0      0      0      0   $privs =~ /select/ && $privs =~ /insert/
      ***      0      0      0      0   $privs =~ /select/ && $privs =~ /insert/ && $privs =~ /update/
      ***      0      0      0      0   $privs =~ /select/ && $privs =~ /insert/ && $privs =~ /update/ && $can_delete
2272  ***     33      9      0      0   $$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000'
      ***     33      9      0      0   $$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000' and $engine =~ /HEAP|MEMORY/i
2303  ***     66      7      0      2   $engine =~ /InnoDB/i and not $clustered_key
2305  ***      0      0      0      0   $$this_key{'is_unique'} and not $$this_key{'is_nullable'}
2329  ***      0      0      0      0   not $parent =~ /\./ and $$opts{'database'}
2473  ***      0      0      0      0   $trgs and @$trgs
2767  ***     33      0      0      5   $$index{'is_unique'} and @{$$index{'cols'};} == 1
2966  ***      0      0      0      0   $start_point != $end_point and $start_point >= 0
3053  ***      0      0      0      0   $first_char = $i and last
3056  ***      0      0      0      0   $last_char = $i and last
3155  ***      0      0      0      0   $wanted_col and $wanted_idx
3157  ***      0      0      0      0   $wanted_col eq $$chunkable_col{'column'} and $wanted_idx eq $$chunkable_col{'index'}
3291  ***      0      0      0      0   $args{'where'} and grep {$_;} @{$args{'where'};}
3670  ***     33      0      0      3   $args{'spec'} and @{$args{'spec'};} == 2
3727  ***     33      0      0      7   $$self{'report'} eq 'time' and $$self{'interval'} > $now - $$self{'last_reported'}
      ***      0      0      0      0   $$self{'report'} eq 'iterations' and ($$self{'iterations'} - 1) % $$self{'interval'} > 0
3746  ***      0      0      0      0   $$self{'report'} eq 'percentage' and $self->fraction_modulo($$self{'fraction'}) >= $self->fraction_modulo($fraction)
3758  ***      0      0      0      0   $completed > 0 and $completed <= $jobsize
      ***      0      0      0      0   $completed > 0 and $completed <= $jobsize and $elapsed > 0
3991  ***     33      7      0      0   $sleep and $chunkno < $n_chunks
4169  ***     33      0      5      0   $old_tbl and $old_tbl eq ($o->get('new-table') || '')
4333  ***     33      2      0      0   -f $alter and -r $alter
4413  ***     66      0      1      2   $o->get('rename-tables') and $o->get('drop-old-table')
4478  ***     66      0      6      1   $triggers and @$triggers

or 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
41    ***     50      0      3   $ENV{'MKDEBUG'} || 0
55    ***     50     12      0   $program_name ||= $PROGRAM_NAME
56    ***     50     12      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'} || '.'
116   ***     50      0      5   $$self{'file'} || '/home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change'
             100      1      5   $file ||= $$self{'file'} || '/home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change'
181   ***      0      0      0   $$self{'file'} || '/home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change'
      ***     50     12      0   $file ||= $$self{'file'} || '/home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change'
305   ***     50    186      0   $$opt{'group'} ||= 'default'
615   ***      0      0      0   $s || 's'
624   ***      0      0      0   $prefix || ''
654   ***      0      0      0   $val || ''
657   ***     50     14      0   $val || ''
713   ***      0      0      0   $$self{'usage'} || ''
719   ***      0      0      0   $$self{'description'} || $$self{'program_name'} || ''
731   ***     50      0      5   $$self{'file'} || '/home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change'
811   ***      0      0      0   $s ||= 's'
839   ***      0      0      0   $$opt{'type'} || ''
966   ***     50      7      0   $val || ''
980   ***     50      0      7   $pre || ''
1000  ***      0      0      0   $$self{'file'} || '/home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change'
1062  ***     50      0      3   $ENV{'MKDEBUG'} || 0
1145  ***     50      0      3   $ENV{'MKDEBUG'} || 0
1175         100     75      6   $$opt{'copy'} || 0
1200         100      5      8   $prev ||= {}
1201  ***     50      0     13   $defaults ||= {}
1281  ***      0      0      0   $opts{$key}{'desc'} || '[No description]'
1294  ***     50      0      8   $self->prop('dbidriver') || ''
1298  ***      0      0      0   $$info{'D'} || ''
1304         100      5      3   $$info{'D'} || ''
1326  ***     50      8      0   $opts ||= {}
1431  ***      0      0      0   $$dbh{'mysql_hostinfo'} || ''
1447  ***      0      0      0   $level ||= 0
1448  ***      0      0      0   $$thing{'Type'} || 'undef'
      ***      0      0      0   $$thing{'Type'} || ''
      ***      0      0      0   $$thing{'Statement'} || ''
1505  ***     50      0      3   $ENV{'MKDEBUG'} || 0
1656  ***      0      0      0   $$self{'PID_owner'} || 0
1690  ***     50      0      3   $ENV{'MKDEBUG'} || 0
1770  ***     50      0      3   $ENV{'MKDEBUG'} || 0
1826  ***      0      0      0   $args{'p'} || 0
1828  ***      0      0      0   $of ||= 1
1833  ***      0      0      0   $secs ||= 0
1863  ***      0      0      0   $suffix || $default_suffix || 's'
2028  ***     50      0      3   $ENV{'MKDEBUG'} || 0
2248  ***     50     20      0   $engine || undef
2271  ***     50      0      9   $type || $special || 'BTREE'
2358  ***      0      0      0   $$tbl_struct{'engine'} || ''
2360  ***      0      0      0   $clustered_key ||= ''
2419  ***     50      0      3   $ENV{'MKDEBUG'} || 0
2683  ***      0      0      0   $$_[1] || ''
2724  ***     50      0      3   $ENV{'MKDEBUG'} || 0
2879  ***     50      0      1   lc $args{'chunk_range'} || 'open'
3040  ***      0      0      0   $args{'tbl_struct'}{'charset'} || ''
3115  ***      0      0      0   floor($n_values / $n_chunks) || 1
3297  ***      0      0      0   $args{'index_hint'} || ''
3616  ***      0      0      0   $base ** $power || 1
3662  ***     50      0      3   $ENV{'MKDEBUG'} || 0
3678  ***     50      3      0   $args{'name'} || 'Progress'
3803  ***     50      0      3   $ENV{'MKDEBUG'} || 0
3919  ***     50      0      3   $ENV{'MKDEBUG'} || 0
4030  ***     50      0      3   $ENV{'MKDEBUG'} || 0
4047  ***     50      7      0   $args{'tries'} || 3
4119  ***     50      0      3   $ENV{'MKDEBUG'} || 0
4157  ***     50      5      0   $$dsn{'t'} || ''
      ***     50      5      0   $$dsn{'D'} || ''
4169  ***     50      0      5   $o->get('new-table') || ''

or 3 conditions

line  err      %      l  !l&&r !l&&!r   expr
----- --- ------ ------ ------ ------   ----
56    ***     33     12      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'}
      ***     33     12      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'}
610   ***     33      0      0    119   $$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h'
             100      7      7    105   $$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a'
719   ***      0      0      0      0   $$self{'description'} || $$self{'program_name'}
731   ***     33      0      5      0   $file ||= $$self{'file'} || '/home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change'
733   ***     33      5      0      0   not $$self{'description'} or not $$self{'usage'}
736   ***     33      0      5      0   $$self{'description'} ||= $synop{'description'}
737   ***     33      0      5      0   $$self{'usage'} ||= $synop{'usage'}
1000  ***     33      5      0      0   $file ||= $$self{'file'} || '/home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change'
1105  ***      0      0      0      0   $$vars{'Value'} || $$vars{'value'}
1166  ***     33      0      0     81   not $$opt{'key'} or not $$opt{'desc'}
1317  ***      0      0      0      0   $$dsn{'h'} ||= $$vars{'hostname'}{'Value'}
1318  ***      0      0      0      0   $$dsn{'S'} ||= $$vars{'socket'}{'Value'}
1319  ***      0      0      0      0   $$dsn{'P'} ||= $$vars{'port'}{'Value'}
1320  ***      0      0      0      0   $$dsn{'u'} ||= $user
1321  ***      0      0      0      0   $$dsn{'D'} ||= $db
1836  ***      0      0      0      0   $fmt ||= $secs >= 86400 ? 'd' : ($secs >= 3600 ? 'h' : 'm')
1863  ***      0      0      0      0   $suffix || $default_suffix
1888  ***      0      0      0      0   $num =~ /\./ || $n
2122  ***      0      0      0      0   ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'}
      ***      0      0      0      0   ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'} or $$tbl{'keys'}{$a}{'is_nullable'} <=> $$tbl{'keys'}{$b}{'is_nullable'}
2201  ***     66     16      0     11   not $$row[0] or $$row[0] ne $tbl
2222  ***      0      0      0      0   $$row{'privileges'} || $$row{'Privileges'}
2271  ***     33      0      0      9   $type || $special
2524  ***     33     10      0      0   not $$self{'cache'} or not $$self{'tables'}{$db}{$tbl}
2563  ***      0      0      0      0   not $$self{'cache'} or not $$self{'columns'}{$db}{$tbl}
2593  ***      0      0      0      0   not $$self{'cache'} or not $$self{'triggers'}{$db}
2627  ***      0      0      0      0   not $$self{'cache'} or not $$self{'databases'}
      ***      0      0      0      0   not $$self{'cache'} or not $$self{'databases'} or $like
2646  ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_status'}{$db}
      ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_status'}{$db} or $like
2660  ***      0      0      0      0   $tbl{'type'} || $tbl{'comment'}
      ***      0      0      0      0   $tbl{'engine'} ||= $tbl{'type'} || $tbl{'comment'}
2672  ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_list'}{$db}
      ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_list'}{$db} or $like
2781  ***     33      5      0      0   $$self{'int_types'}{$col_type} or $$self{'real_types'}{$col_type}
      ***     33      5      0      0   $$self{'int_types'}{$col_type} or $$self{'real_types'}{$col_type} or $col_type =~ /char/
2846  ***     33      1      0      0   $$tbl_struct{'is_numeric'}{$chunk_col} or $col_type =~ /date|time/
2958  ***     33      0      0      1   not defined $end_point or $end_point < $start_point
2994  ***     33      1      0      0   $interval ||= $args{'chunk_size'}
3214  ***      0      0      0      0   $suffix or $args{'avg_row_length'}
3669  ***     33      3      0      0   not $args{'report'} or not $args{'interval'}
3679  ***     33      0      3      0   $args{'start'} ||= time
3718  ***      0      0      0      0   $start || time
3724  ***     33      0      7      0   $now ||= time
4215  ***     33      0      5      0   $o->get('new-table') || "__new_$old_tbl"
4490  ***     66      1      0      5   not $exact or not @chunkable_cols


Covered Subroutines
-------------------

Subroutine                 Count Location                                                                           
-------------------------- ----- -----------------------------------------------------------------------------------
BEGIN                          3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1057
BEGIN                          3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1058
BEGIN                          3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1060
BEGIN                          3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1062
BEGIN                          3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1142
BEGIN                          3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1143
BEGIN                          3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1144
BEGIN                          3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1145
BEGIN                          3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1147
BEGIN                          3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1499
BEGIN                          3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1500
BEGIN                          3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1502
BEGIN                          3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1503
BEGIN                          3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1505
BEGIN                          3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1686
BEGIN                          3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1687
BEGIN                          3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1688
BEGIN                          3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1690
BEGIN                          3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1764
BEGIN                          3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1765
BEGIN                          3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1766
BEGIN                          3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1767
BEGIN                          3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1768
BEGIN                          3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1770
BEGIN                          3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:19  
BEGIN                          3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:20  
BEGIN                          3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2020
BEGIN                          3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2021
BEGIN                          3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2022
BEGIN                          3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2023
BEGIN                          3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2028
BEGIN                          3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2414
BEGIN                          3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2415
BEGIN                          3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2417
BEGIN                          3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2419
BEGIN                          3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2721
BEGIN                          3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2722
BEGIN                          3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2723
BEGIN                          3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2724
BEGIN                          3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2726
BEGIN                          3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2727
BEGIN                          3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2728
BEGIN                          3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3653
BEGIN                          3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3654
BEGIN                          3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3656
BEGIN                          3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3657
BEGIN                          3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3662
BEGIN                          3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:37  
BEGIN                          3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:38  
BEGIN                          3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3800
BEGIN                          3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3801
BEGIN                          3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3802
BEGIN                          3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3803
BEGIN                          3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:39  
BEGIN                          3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3916
BEGIN                          3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3917
BEGIN                          3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3918
BEGIN                          3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3919
BEGIN                          3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:40  
BEGIN                          3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:4027
BEGIN                          3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:4028
BEGIN                          3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:4029
BEGIN                          3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:4030
BEGIN                          3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:41  
BEGIN                          3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:4110
BEGIN                          3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:4111
BEGIN                          3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:4112
BEGIN                          3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:4119
BEGIN                          3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:43  
DSNParser                      5 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:170 
__ANON__                      54 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:130 
__ANON__                       2 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3965
__ANON__                       9 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3968
__ANON__                      15 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:484 
__set_quiet                    1 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:4537
_check_opts                    7 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:527 
_chunk_numeric                 1 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2903
_get_participants              6 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:384 
_get_valid_end_point           6 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3466
_make_triggers                 3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3837
_parse_attribs               186 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:989 
_parse_size                    7 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:964 
_parse_specs                   6 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:269 
_parse_synopsis                5 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:999 
_pod_to_specs                 12 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:180 
_read_config_file             28 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:888 
_set_option                   15 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:430 
_use_db                       10 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2511
_validate_type               217 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:600 
calculate_chunks               3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2818
capture                        3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3820
check_table                   27 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2180
checks                        10 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:4434
cleanup                        4 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3875
cleanup                        4 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3998
copy                           3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3936
find_chunk_columns             6 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2753
get                          185 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:669 
get_create_table              10 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2523
get_cxn                        5 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:4513
get_cxn_params                 8 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1291
get_dbh                        8 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1325
get_defaults_files             6 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:175 
get_engine                    20 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2245
get_keys                      10 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2252
get_opts                       7 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:447 
get_range_statistics           3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3226
get_specs                      6 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:115 
get_valid_end_points           3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3422
got                           28 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:677 
has                           52 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:685 
intersection                   3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:4505
join_quote                    15 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1735
literal_like                  27 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1728
main                           5 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:4124
msg                           92 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:4528
new                            6 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1065
new                            9 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1158
new                            6 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1693
new                            6 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2031
new                            6 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2446
new                            6 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2734
new                            3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3665
new                            5 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3806
new                            5 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3922
new                            5 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:4033
new                           12 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:48  
parse                         15 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1070
parse                         13 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1194
parse                         10 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2041
parse_options                  5 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1250
prop                          39 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1185
quote                         82 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1698
quote_val                     10 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1706
range_num                      5 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3352
retry                          7 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:4041
split_unquote                 44 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1717
sync                           3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3866
ts                            73 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1896
update                         7 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3722
usage_or_errors                5 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:730 
validate_spec                  5 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3697
value_to_number                2 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3311
version_ge                    10 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1077

Uncovered Subroutines
---------------------

Subroutine                 Count Location                                                                           
-------------------------- ----- -----------------------------------------------------------------------------------
DESTROY                        0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1654
__ANON__                       0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3118
__ANON__                       0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3569
__ANON__                       0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3685
__ANON__                       0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3985
__ANON__                       0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3989
__ANON__                       0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:4259
_chunk_char                    0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3011
_d                             0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1034
_d                             0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1118
_d                             0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1475
_d                             0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1662
_d                             0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1996
_d                             0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2391
_d                             0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2697
_d                             0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3630
_d                             0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3776
_d                             0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3892
_d                             0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:4003
_d                             0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:4087
_d                             0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:4541
_make_PID_file                 0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1619
_remove_PID_file               0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1641
_validate_temporal_value       0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3542
any_unix_timestamp             0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1939
as_string                      0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1263
base_count                     0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3600
check_PID_file                 0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1578
clone                          0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:941 
copy                           0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1457
crc32                          0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1981
daemonize                      0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1526
descr                          0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:717 
disconnect                     0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1440
dump                           0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2454
errors                         0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:706 
fill_in_dsn                    0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1313
find_best_index                0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2134
find_possible_keys             0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2152
fraction_modulo                0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3769
get_columns                    0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2561
get_databases                  0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2626
get_defaults                   0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:420 
get_first_chunkable_column     0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3142
get_first_valid_value          0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3497
get_fks                        0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2319
get_groups                     0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:425 
get_hostname                   0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1430
get_nonzero_value              0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3559
get_table_list                 0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2671
get_table_status               0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2645
get_tmp_table                  0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2581
get_triggers                   0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2592
inject_chunks                  0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3280
innodb_version                 0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1088
make_PID_file                  0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1609
make_checksum                  0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1974
micro_t                        0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1795
new                            0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1508
opts                           0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:396 
parse_timestamp                0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1912
percentage_of                  0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1825
print_active_handles           0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1446
print_errors                   0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:755 
print_usage                    0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:765 
prompt_noecho                  0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:853 
range_date                     0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3378
range_datetime                 0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3385
range_time                     0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3371
range_timestamp                0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3393
read_para_after                0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:922 
remove_auto_increment          0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2348
remove_secondary_indexes       0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2354
save_error                     0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:700 
secs_to_time                   0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1832
set                            0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:691 
set_callback                   0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3712
set_defaults                   0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:408 
short_opts                     0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:402 
shorten                        0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1879
size_to_rows                   0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3189
sort_indexes                   0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2115
start                          0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3717
time_to_secs                   0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1859
timestampdiff                  0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3400
unix_timestamp                 0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1924
usage                          0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1274
usage                          0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:711 


