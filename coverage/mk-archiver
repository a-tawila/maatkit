---------------------------- ------ ------ ------ ------ ------ ------ ------
File                           stmt   bran   cond    sub    pod   time  total
---------------------------- ------ ------ ------ ------ ------ ------ ------
...k/mk-archiver/mk-archiver   50.5   38.1   31.6   55.3    n/a  100.0   44.9
Total                          50.5   38.1   31.6   55.3    n/a  100.0   44.9
---------------------------- ------ ------ ------ ------ ------ ------ ------


Run:          -e
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Wed Mar 16 19:21:25 2011
Finish:       Wed Mar 16 19:21:25 2011

Run:          ./101_basics.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Wed Mar 16 19:21:27 2011
Finish:       Wed Mar 16 19:21:43 2011

Run:          ./102_dest.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Wed Mar 16 19:21:46 2011
Finish:       Wed Mar 16 19:21:59 2011

Run:          ./103_file.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Wed Mar 16 19:22:02 2011
Finish:       Wed Mar 16 19:22:04 2011

Run:          ./104_purge.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Wed Mar 16 19:22:08 2011
Finish:       Wed Mar 16 19:22:11 2011

Run:          ./105_plugin.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Wed Mar 16 19:22:14 2011
Finish:       Wed Mar 16 19:22:39 2011

Run:          ./106_gt_n.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Wed Mar 16 19:22:42 2011
Finish:       Wed Mar 16 19:22:43 2011

Run:          ./107_res_fk.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Wed Mar 16 19:22:46 2011
Finish:       Wed Mar 16 19:22:50 2011

Run:          ./108_check_slave_lag.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Wed Mar 16 19:22:54 2011
Finish:       Wed Mar 16 19:22:59 2011

Run:          ./109_standard_options.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Wed Mar 16 19:23:02 2011
Finish:       Wed Mar 16 19:23:07 2011

Run:          ./110_bulk_delete.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Wed Mar 16 19:23:10 2011
Finish:       Wed Mar 16 19:23:32 2011

Run:          ./111_bulk_insert.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Wed Mar 16 19:23:35 2011
Finish:       Wed Mar 16 19:23:37 2011

Run:          ./112_indexes.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Wed Mar 16 19:23:41 2011
Finish:       Wed Mar 16 19:24:29 2011

Run:          ./113_safe_auto_increment.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Wed Mar 16 19:24:33 2011
Finish:       Wed Mar 16 19:24:33 2011

Run:          ./114_delete_more.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Wed Mar 16 19:24:37 2011
Finish:       Wed Mar 16 19:24:44 2011

Run:          ./115_compact_col_vals.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Wed Mar 16 19:24:47 2011
Finish:       Wed Mar 16 19:24:51 2011

Run:          ./116_bulk_regular_insert.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Wed Mar 16 19:24:54 2011
Finish:       Wed Mar 16 19:24:57 2011

Run:          ./201_issue_655.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Wed Mar 16 19:25:01 2011
Finish:       Wed Mar 16 19:25:01 2011

Run:          ./202_issue_131.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Wed Mar 16 19:25:04 2011
Finish:       Wed Mar 16 19:25:05 2011

Run:          ./203_issue_524.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Wed Mar 16 19:25:08 2011
Finish:       Wed Mar 16 19:25:08 2011

Run:          ./204_issue_1166.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Wed Mar 16 19:25:12 2011
Finish:       Wed Mar 16 19:25:12 2011

Run:          ./205_issue_1152.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Wed Mar 16 19:25:16 2011
Finish:       Wed Mar 16 19:25:17 2011

/home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver

line  err   stmt   bran   cond    sub    pod   time   code
1                                                     #!/usr/bin/env perl
2                                                     
3                                                     # This is mk-archiver, a program to archive records from one MySQL table to
4                                                     # a file and/or another table.
5                                                     #
6                                                     # This program is copyright 2007-@CURRENTYEAR@ Baron Schwartz.
7                                                     # Feedback and improvements are welcome.
8                                                     #
9                                                     # THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
10                                                    # WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
11                                                    # MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
12                                                    #
13                                                    # This program is free software; you can redistribute it and/or modify it under
14                                                    # the terms of the GNU General Public License as published by the Free Software
15                                                    # Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
16                                                    # systems, you can issue `man perlgpl' or `man perlartistic' to read these
17                                                    # licenses.
18                                                    #
19                                                    # You should have received a copy of the GNU General Public License along with
20                                                    # this program; if not, write to the Free Software Foundation, Inc., 59 Temple
21                                                    # Place, Suite 330, Boston, MA  02111-1307  USA.
22                                                    
23            21                   21           162   use strict;
              21                                 51   
              21                                142   
24            21                   21           134   use warnings FATAL => 'all';
              21                                 50   
              21                                158   
25                                                    
26                                                    our $VERSION = '@VERSION@';
27                                                    our $DISTRIB = '@DISTRIB@';
28                                                    our $SVN_REV = sprintf("%d", (q$Revision: 7328 $ =~ m/(\d+)/g, 0));
29                                                    
30                                                    # ###########################################################################
31                                                    # OptionParser package 7102
32                                                    # This package is a copy without comments from the original.  The original
33                                                    # with comments and its test file can be found in the SVN repository at,
34                                                    #   trunk/common/OptionParser.pm
35                                                    #   trunk/common/t/OptionParser.t
36                                                    # See http://code.google.com/p/maatkit/wiki/Developers for more information.
37                                                    # ###########################################################################
38                                                    
39                                                    package OptionParser;
40                                                    
41            21                   21           134   use strict;
              21                                 59   
              21                                 92   
42            21                   21           135   use warnings FATAL => 'all';
              21                                 59   
              21                                100   
43            21                   21           133   use List::Util qw(max);
              21                                 63   
              21                                262   
44            21                   21           130   use English qw(-no_match_vars);
              21                                 50   
              21                                136   
45    ***     21            50     21           151   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              21                                 74   
              21                                308   
46                                                    
47            21                   21           241   use Getopt::Long;
              21                                 69   
              21                                141   
48                                                    
49                                                    my $POD_link_re = '[LC]<"?([^">]+)"?>';
50                                                    
51                                                    sub new {
52            86                   86          1158      my ( $class, %args ) = @_;
53            86                                520      my @required_args = qw();
54            86                                767      foreach my $arg ( @required_args ) {
55    ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
56                                                       }
57                                                    
58            86                               1701      my ($program_name) = $PROGRAM_NAME =~ m/([.A-Za-z-]+)$/;
59    ***     86            33                  569      $program_name ||= $PROGRAM_NAME;
60    ***     86            33                 1191      my $home = $ENV{HOME} || $ENV{HOMEPATH} || $ENV{USERPROFILE} || '.';
      ***                   33                        
      ***                   50                        
61                                                    
62            86                               1198      my %attributes = (
63                                                          'type'       => 1,
64                                                          'short form' => 1,
65                                                          'group'      => 1,
66                                                          'default'    => 1,
67                                                          'cumulative' => 1,
68                                                          'negatable'  => 1,
69                                                       );
70                                                    
71            86                               6420      my $self = {
72                                                          head1             => 'OPTIONS',        # These args are used internally
73                                                          skip_rules        => 0,                # to instantiate another Option-
74                                                          item              => '--(.*)',         # Parser obj that parses the
75                                                          attributes        => \%attributes,     # DSN OPTIONS section.  Tools
76                                                          parse_attributes  => \&_parse_attribs, # don't tinker with these args.
77                                                    
78                                                          %args,
79                                                    
80                                                          strict            => 1,  # disabled by a special rule
81                                                          program_name      => $program_name,
82                                                          opts              => {},
83                                                          got_opts          => 0,
84                                                          short_opts        => {},
85                                                          defaults          => {},
86                                                          groups            => {},
87                                                          allowed_groups    => {},
88                                                          errors            => [],
89                                                          rules             => [],  # desc of rules for --help
90                                                          mutex             => [],  # rule: opts are mutually exclusive
91                                                          atleast1          => [],  # rule: at least one opt is required
92                                                          disables          => {},  # rule: opt disables other opts 
93                                                          defaults_to       => {},  # rule: opt defaults to value of other opt
94                                                          DSNParser         => undef,
95                                                          default_files     => [
96                                                             "/etc/maatkit/maatkit.conf",
97                                                             "/etc/maatkit/$program_name.conf",
98                                                             "$home/.maatkit.conf",
99                                                             "$home/.$program_name.conf",
100                                                         ],
101                                                         types             => {
102                                                            string => 's', # standard Getopt type
103                                                            int    => 'i', # standard Getopt type
104                                                            float  => 'f', # standard Getopt type
105                                                            Hash   => 'H', # hash, formed from a comma-separated list
106                                                            hash   => 'h', # hash as above, but only if a value is given
107                                                            Array  => 'A', # array, similar to Hash
108                                                            array  => 'a', # array, similar to hash
109                                                            DSN    => 'd', # DSN
110                                                            size   => 'z', # size with kMG suffix (powers of 2^10)
111                                                            time   => 'm', # time, with an optional suffix of s/h/m/d
112                                                         },
113                                                      };
114                                                   
115           86                               1378      return bless $self, $class;
116                                                   }
117                                                   
118                                                   sub get_specs {
119           43                   43           247      my ( $self, $file ) = @_;
120   ***     43            50                  878      $file ||= $self->{file} || __FILE__;
      ***                   33                        
121           43                                540      my @specs = $self->_pod_to_specs($file);
122           43                               2344      $self->_parse_specs(@specs);
123                                                   
124   ***     43     50                        2265      open my $fh, "<", $file or die "Cannot open $file: $OS_ERROR";
125           43                                181      my $contents = do { local $/ = undef; <$fh> };
              43                                403   
              43                              20148   
126           43                                530      close $fh;
127   ***     43     50                        4728      if ( $contents =~ m/^=head1 DSN OPTIONS/m ) {
128           43                                171         MKDEBUG && _d('Parsing DSN OPTIONS');
129           43                                433         my $dsn_attribs = {
130                                                            dsn  => 1,
131                                                            copy => 1,
132                                                         };
133                                                         my $parse_dsn_attribs = sub {
134          559                  559          3257            my ( $self, $option, $attribs ) = @_;
135          903                               3773            map {
136          559                               3371               my $val = $attribs->{$_};
137   ***    903     50                        5737               if ( $val ) {
138          903    100                        5378                  $val    = $val eq 'yes' ? 1
                    100                               
139                                                                          : $val eq 'no'  ? 0
140                                                                          :                 $val;
141          903                               7924                  $attribs->{$_} = $val;
142                                                               }
143                                                            } keys %$attribs;
144                                                            return {
145          559                               9907               key => $option,
146                                                               %$attribs,
147                                                            };
148           43                                703         };
149           43                                713         my $dsn_o = new OptionParser(
150                                                            description       => 'DSN OPTIONS',
151                                                            head1             => 'DSN OPTIONS',
152                                                            dsn               => 0,         # XXX don't infinitely recurse!
153                                                            item              => '\* (.)',  # key opts are a single character
154                                                            skip_rules        => 1,         # no rules before opts
155                                                            attributes        => $dsn_attribs,
156                                                            parse_attributes  => $parse_dsn_attribs,
157                                                         );
158          559                               7654         my @dsn_opts = map {
159           43                                347            my $opts = {
160                                                               key  => $_->{spec}->{key},
161                                                               dsn  => $_->{spec}->{dsn},
162                                                               copy => $_->{spec}->{copy},
163                                                               desc => $_->{desc},
164                                                            };
165          559                               2436            $opts;
166                                                         } $dsn_o->_pod_to_specs($file);
167           43                               1849         $self->{DSNParser} = DSNParser->new(opts => \@dsn_opts);
168                                                      }
169                                                   
170           43                                136      return;
171                                                   }
172                                                   
173                                                   sub DSNParser {
174           43                   43           208      my ( $self ) = @_;
175           43                                260      return $self->{DSNParser};
176                                                   };
177                                                   
178                                                   sub get_defaults_files {
179           43                   43           228      my ( $self ) = @_;
180           43                                175      return @{$self->{default_files}};
              43                                699   
181                                                   }
182                                                   
183                                                   sub _pod_to_specs {
184           86                   86           598      my ( $self, $file ) = @_;
185   ***     86             0                  530      $file ||= $self->{file} || __FILE__;
      ***                   33                        
186   ***     86     50                        4007      open my $fh, '<', $file or die "Cannot open $file: $OS_ERROR";
187                                                   
188           86                                410      my @specs = ();
189           86                                335      my @rules = ();
190           86                                286      my $para;
191                                                   
192           86                                891      local $INPUT_RECORD_SEPARATOR = '';
193           86                               2470      while ( $para = <$fh> ) {
194        60931    100                      697132         next unless $para =~ m/^=head1 $self->{head1}/;
195           86                                402         last;
196                                                      }
197                                                   
198           86                                758      while ( $para = <$fh> ) {
199          473    100                        3269         last if $para =~ m/^=over/;
200          387    100                        2563         next if $self->{skip_rules};
201          344                               1255         chomp $para;
202          344                               2929         $para =~ s/\s+/ /g;
203          344                               7111         $para =~ s/$POD_link_re/$1/go;
204          344                               1082         MKDEBUG && _d('Option rule:', $para);
205          344                               4201         push @rules, $para;
206                                                      }
207                                                   
208   ***     86     50                         530      die "POD has no $self->{head1} section" unless $para;
209                                                   
210           86                                338      do {
211         3225    100                       41573         if ( my ($option) = $para =~ m/^=item $self->{item}/ ) {
212         3139                              11437            chomp $para;
213         3139                               8528            MKDEBUG && _d($para);
214         3139                              10043            my %attribs;
215                                                   
216         3139                              15548            $para = <$fh>; # read next paragraph, possibly attributes
217                                                   
218         3139    100                       16558            if ( $para =~ m/: / ) { # attributes
219         1935                              12641               $para =~ s/\s+\Z//g;
220         2881                              19436               %attribs = map {
221         1935                              12914                     my ( $attrib, $val) = split(/: /, $_);
222   ***   2881     50                       21169                     die "Unrecognized attribute for --$option: $attrib"
223                                                                        unless $self->{attributes}->{$attrib};
224         2881                              20797                     ($attrib, $val);
225                                                                  } split(/; /, $para);
226         1935    100                       12182               if ( $attribs{'short form'} ) {
227          344                               2339                  $attribs{'short form'} =~ s/-//;
228                                                               }
229         1935                              11058               $para = <$fh>; # read next paragraph, probably short help desc
230                                                            }
231                                                            else {
232         1204                               3799               MKDEBUG && _d('Option has no attributes');
233                                                            }
234                                                   
235         3139                              25429            $para =~ s/\s+\Z//g;
236         3139                              24347            $para =~ s/\s+/ /g;
237         3139                              22086            $para =~ s/$POD_link_re/$1/go;
238                                                   
239         3139                              16216            $para =~ s/\.(?:\n.*| [A-Z].*|\Z)//s;
240         3139                               9084            MKDEBUG && _d('Short help:', $para);
241                                                   
242   ***   3139     50                       16700            die "No description after option spec $option" if $para =~ m/^=item/;
243                                                   
244         3139    100                       21021            if ( my ($base_option) =  $option =~ m/^\[no\](.*)/ ) {
245          129                                482               $option = $base_option;
246          129                                672               $attribs{'negatable'} = 1;
247                                                            }
248                                                   
249         3139    100                       25793            push @specs, {
      ***            50                               
250                                                               spec  => $self->{parse_attributes}->($self, $option, \%attribs), 
251                                                               desc  => $para
252                                                                  . (defined $attribs{default} ? " (default $attribs{default})" : ''),
253                                                               group => ($attribs{'group'} ? $attribs{'group'} : 'default'),
254                                                            };
255                                                         }
256         3225                              36452         while ( $para = <$fh> ) {
257   ***   7697     50                       34828            last unless $para;
258         7697    100                       40009            if ( $para =~ m/^=head1/ ) {
259           86                                401               $para = undef; # Can't 'last' out of a do {} block.
260           86                                635               last;
261                                                            }
262         7611    100                       68429            last if $para =~ m/^=item /;
263                                                         }
264                                                      } while ( $para );
265                                                   
266   ***     86     50                         594      die "No valid specs in $self->{head1}" unless @specs;
267                                                   
268           86                               1536      close $fh;
269           86                                402      return @specs, @rules;
270                                                   }
271                                                   
272                                                   sub _parse_specs {
273           43                   43           894      my ( $self, @specs ) = @_;
274           43                                347      my %disables; # special rule that requires deferred checking
275                                                   
276           43                                347      foreach my $opt ( @specs ) {
277         2924    100                       14183         if ( ref $opt ) { # It's an option spec, not a rule.
278                                                            MKDEBUG && _d('Parsing opt spec:',
279         2580                               7242               map { ($_, '=>', $opt->{$_}) } keys %$opt);
280                                                   
281         2580                              24572            my ( $long, $short ) = $opt->{spec} =~ m/^([\w-]+)(?:\|([^!+=]*))?/;
282   ***   2580     50                       14075            if ( !$long ) {
283   ***      0                                  0               die "Cannot parse long option from spec $opt->{spec}";
284                                                            }
285         2580                              12336            $opt->{long} = $long;
286                                                   
287   ***   2580     50                       16097            die "Duplicate long option --$long" if exists $self->{opts}->{$long};
288         2580                              15135            $self->{opts}->{$long} = $opt;
289                                                   
290   ***   2580     50                       13457            if ( length $long == 1 ) {
291   ***      0                                  0               MKDEBUG && _d('Long opt', $long, 'looks like short opt');
292   ***      0                                  0               $self->{short_opts}->{$long} = $long;
293                                                            }
294                                                   
295         2580    100                       11075            if ( $short ) {
296   ***    344     50                        2172               die "Duplicate short option -$short"
297                                                                  if exists $self->{short_opts}->{$short};
298          344                               2391               $self->{short_opts}->{$short} = $long;
299          344                               1655               $opt->{short} = $short;
300                                                            }
301                                                            else {
302         2236                              10511               $opt->{short} = undef;
303                                                            }
304                                                   
305         2580    100                       18239            $opt->{is_negatable}  = $opt->{spec} =~ m/!/        ? 1 : 0;
306   ***   2580     50                       17053            $opt->{is_cumulative} = $opt->{spec} =~ m/\+/       ? 1 : 0;
307         2580    100                       19448            $opt->{is_required}   = $opt->{desc} =~ m/required/ ? 1 : 0;
308                                                   
309   ***   2580            50                14098            $opt->{group} ||= 'default';
310         2580                              17333            $self->{groups}->{ $opt->{group} }->{$long} = 1;
311                                                   
312         2580                              10938            $opt->{value} = undef;
313         2580                              11007            $opt->{got}   = 0;
314                                                   
315         2580                              16831            my ( $type ) = $opt->{spec} =~ m/=(.)/;
316         2580                              12054            $opt->{type} = $type;
317         2580                               7105            MKDEBUG && _d($long, 'type:', $type);
318                                                   
319                                                   
320         2580    100    100                24513            $opt->{spec} =~ s/=./=s/ if ( $type && $type =~ m/[HhAadzm]/ );
321                                                   
322         2580    100                       21173            if ( (my ($def) = $opt->{desc} =~ m/default\b(?: ([^)]+))?/) ) {
323   ***    430     50                        3319               $self->{defaults}->{$long} = defined $def ? $def : 1;
324          430                               1446               MKDEBUG && _d($long, 'default:', $def);
325                                                            }
326                                                   
327         2580    100                       13506            if ( $long eq 'config' ) {
328           43                                401               $self->{defaults}->{$long} = join(',', $self->get_defaults_files());
329                                                            }
330                                                   
331         2580    100                       17706            if ( (my ($dis) = $opt->{desc} =~ m/(disables .*)/) ) {
332           43                                243               $disables{$long} = $dis;
333           43                                143               MKDEBUG && _d('Deferring check of disables rule for', $opt, $dis);
334                                                            }
335                                                   
336         2580                              16881            $self->{opts}->{$long} = $opt;
337                                                         }
338                                                         else { # It's an option rule, not a spec.
339          344                                991            MKDEBUG && _d('Parsing rule:', $opt); 
340          344                               1128            push @{$self->{rules}}, $opt;
             344                               2090   
341          344                               2086            my @participants = $self->_get_participants($opt);
342          344                               1368            my $rule_ok = 0;
343                                                   
344          344    100                        3435            if ( $opt =~ m/mutually exclusive|one and only one/ ) {
345          258                                897               $rule_ok = 1;
346          258                               1056               push @{$self->{mutex}}, \@participants;
             258                               1547   
347          258                                848               MKDEBUG && _d(@participants, 'are mutually exclusive');
348                                                            }
349          344    100                        2802            if ( $opt =~ m/at least one|one and only one/ ) {
350           43                                178               $rule_ok = 1;
351           43                                161               push @{$self->{atleast1}}, \@participants;
              43                                305   
352           43                                169               MKDEBUG && _d(@participants, 'require at least one');
353                                                            }
354          344    100                        2035            if ( $opt =~ m/default to/ ) {
355           43                                173               $rule_ok = 1;
356           43                                375               $self->{defaults_to}->{$participants[0]} = $participants[1];
357           43                                168               MKDEBUG && _d($participants[0], 'defaults to', $participants[1]);
358                                                            }
359   ***    344     50                        1831            if ( $opt =~ m/restricted to option groups/ ) {
360   ***      0                                  0               $rule_ok = 1;
361   ***      0                                  0               my ($groups) = $opt =~ m/groups ([\w\s\,]+)/;
362   ***      0                                  0               my @groups = split(',', $groups);
363   ***      0                                  0               %{$self->{allowed_groups}->{$participants[0]}} = map {
      ***      0                                  0   
364   ***      0                                  0                  s/\s+//;
365   ***      0                                  0                  $_ => 1;
366                                                               } @groups;
367                                                            }
368   ***    344     50                        1810            if( $opt =~ m/accepts additional command-line arguments/ ) {
369   ***      0                                  0               $rule_ok = 1;
370   ***      0                                  0               $self->{strict} = 0;
371   ***      0                                  0               MKDEBUG && _d("Strict mode disabled by rule");
372                                                            }
373                                                   
374   ***    344     50                        2163            die "Unrecognized option rule: $opt" unless $rule_ok;
375                                                         }
376                                                      }
377                                                   
378           43                                380      foreach my $long ( keys %disables ) {
379           43                                296         my @participants = $self->_get_participants($disables{$long});
380           43                                312         $self->{disables}->{$long} = \@participants;
381           43                                241         MKDEBUG && _d('Option', $long, 'disables', @participants);
382                                                      }
383                                                   
384           43                                474      return; 
385                                                   }
386                                                   
387                                                   sub _get_participants {
388          387                  387          2224      my ( $self, $str ) = @_;
389          387                               1360      my @participants;
390          387                               4092      foreach my $long ( $str =~ m/--(?:\[no\])?([\w-]+)/g ) {
391   ***    774     50                        5022         die "Option --$long does not exist while processing rule $str"
392                                                            unless exists $self->{opts}->{$long};
393          774                               4131         push @participants, $long;
394                                                      }
395          387                               1311      MKDEBUG && _d('Participants for', $str, ':', @participants);
396          387                               2887      return @participants;
397                                                   }
398                                                   
399                                                   sub opts {
400   ***      0                    0             0      my ( $self ) = @_;
401   ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
402   ***      0                                  0      return %opts;
403                                                   }
404                                                   
405                                                   sub short_opts {
406   ***      0                    0             0      my ( $self ) = @_;
407   ***      0                                  0      my %short_opts = %{$self->{short_opts}};
      ***      0                                  0   
408   ***      0                                  0      return %short_opts;
409                                                   }
410                                                   
411                                                   sub set_defaults {
412   ***      0                    0             0      my ( $self, %defaults ) = @_;
413   ***      0                                  0      $self->{defaults} = {};
414   ***      0                                  0      foreach my $long ( keys %defaults ) {
415   ***      0      0                           0         die "Cannot set default for nonexistent option $long"
416                                                            unless exists $self->{opts}->{$long};
417   ***      0                                  0         $self->{defaults}->{$long} = $defaults{$long};
418   ***      0                                  0         MKDEBUG && _d('Default val for', $long, ':', $defaults{$long});
419                                                      }
420   ***      0                                  0      return;
421                                                   }
422                                                   
423                                                   sub get_defaults {
424   ***      0                    0             0      my ( $self ) = @_;
425   ***      0                                  0      return $self->{defaults};
426                                                   }
427                                                   
428                                                   sub get_groups {
429   ***      0                    0             0      my ( $self ) = @_;
430   ***      0                                  0      return $self->{groups};
431                                                   }
432                                                   
433                                                   sub _set_option {
434          206                  206          1122      my ( $self, $opt, $val ) = @_;
435   ***    206      0                         534      my $long = exists $self->{opts}->{$opt}       ? $opt
      ***            50                               
436                                                               : exists $self->{short_opts}->{$opt} ? $self->{short_opts}->{$opt}
437                                                               : die "Getopt::Long gave a nonexistent option: $opt";
438                                                   
439          206                                490      $opt = $self->{opts}->{$long};
440   ***    206     50                        1500      if ( $opt->{is_cumulative} ) {
441   ***      0                                  0         $opt->{value}++;
442                                                      }
443                                                      else {
444          206                                942         $opt->{value} = $val;
445                                                      }
446          206                                818      $opt->{got} = 1;
447          206                                937      MKDEBUG && _d('Got option', $long, '=', $val);
448                                                   }
449                                                   
450                                                   sub get_opts {
451           43                   43           275      my ( $self ) = @_; 
452                                                   
453           43                                170      foreach my $long ( keys %{$self->{opts}} ) {
              43                               1254   
454         2580                              13976         $self->{opts}->{$long}->{got} = 0;
455   ***   2580     50                       29118         $self->{opts}->{$long}->{value}
                    100                               
456                                                            = exists $self->{defaults}->{$long}       ? $self->{defaults}->{$long}
457                                                            : $self->{opts}->{$long}->{is_cumulative} ? 0
458                                                            : undef;
459                                                      }
460           43                                427      $self->{got_opts} = 0;
461                                                   
462           43                                238      $self->{errors} = [];
463                                                   
464   ***     43     50     33                  829      if ( @ARGV && $ARGV[0] eq "--config" ) {
465   ***      0                                  0         shift @ARGV;
466   ***      0                                  0         $self->_set_option('config', shift @ARGV);
467                                                      }
468   ***     43     50                         483      if ( $self->has('config') ) {
469           43                                158         my @extra_args;
470           43                                457         foreach my $filename ( split(',', $self->get('config')) ) {
471          172                                608            eval {
472          172                               1117               push @extra_args, $self->_read_config_file($filename);
473                                                            };
474   ***    172     50                        1189            if ( $EVAL_ERROR ) {
475   ***    172     50                        1013               if ( $self->got('config') ) {
476   ***      0                                  0                  die $EVAL_ERROR;
477                                                               }
478                                                               elsif ( MKDEBUG ) {
479                                                                  _d($EVAL_ERROR);
480                                                               }
481                                                            }
482                                                         }
483           43                                307         unshift @ARGV, @extra_args;
484                                                      }
485                                                   
486           43                                699      Getopt::Long::Configure('no_ignore_case', 'bundling');
487                                                      GetOptions(
488         2537                  206         23041         map    { $_->{spec} => sub { $self->_set_option(@_); } }
             206                               1271   
            2580                              13609   
489           43                                500         grep   { $_->{long} ne 'config' } # --config is handled specially above.
490   ***     43     50                         197         values %{$self->{opts}}
491                                                      ) or $self->save_error('Error parsing options');
492                                                   
493   ***     43     50     33                 5357      if ( exists $self->{opts}->{version} && $self->{opts}->{version}->{got} ) {
494   ***      0      0                           0         printf("%s  Ver %s Distrib %s Changeset %s\n",
495                                                            $self->{program_name}, $main::VERSION, $main::DISTRIB, $main::SVN_REV)
496                                                               or die "Cannot print: $OS_ERROR";
497   ***      0                                  0         exit 0;
498                                                      }
499                                                   
500   ***     43     50     33                  354      if ( @ARGV && $self->{strict} ) {
501   ***      0                                  0         $self->save_error("Unrecognized command-line options @ARGV");
502                                                      }
503                                                   
504           43                                163      foreach my $mutex ( @{$self->{mutex}} ) {
              43                                353   
505          258                               1069         my @set = grep { $self->{opts}->{$_}->{got} } @$mutex;
             516                               3242   
506   ***    258     50                        1530         if ( @set > 1 ) {
507   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
508   ***      0                                  0                         @{$mutex}[ 0 .. scalar(@$mutex) - 2] )
509                                                                    . ' and --'.$self->{opts}->{$mutex->[-1]}->{long}
510                                                                    . ' are mutually exclusive.';
511   ***      0                                  0            $self->save_error($err);
512                                                         }
513                                                      }
514                                                   
515           43                                180      foreach my $required ( @{$self->{atleast1}} ) {
              43                                273   
516           43                                224         my @set = grep { $self->{opts}->{$_}->{got} } @$required;
             129                                819   
517           43    100                         327         if ( @set == 0 ) {
518            2                                 34            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
               1                                 11   
519            1                                 22                         @{$required}[ 0 .. scalar(@$required) - 2] )
520                                                                    .' or --'.$self->{opts}->{$required->[-1]}->{long};
521            1                                 16            $self->save_error("Specify at least one of $err");
522                                                         }
523                                                      }
524                                                   
525           43                                180      $self->_check_opts( keys %{$self->{opts}} );
              43                                965   
526           43                                448      $self->{got_opts} = 1;
527           43                                161      return;
528                                                   }
529                                                   
530                                                   sub _check_opts {
531           43                   43          1061      my ( $self, @long ) = @_;
532           43                                343      my $long_last = scalar @long;
533           43                                265      while ( @long ) {
534           43                                463         foreach my $i ( 0..$#long ) {
535         2580                              10060            my $long = $long[$i];
536   ***   2580     50                       11070            next unless $long;
537         2580                              12144            my $opt  = $self->{opts}->{$long};
538         2580    100                       18184            if ( $opt->{got} ) {
                    100                               
539          205    100                        1242               if ( exists $self->{disables}->{$long} ) {
540            2                                  8                  my @disable_opts = @{$self->{disables}->{$long}};
               2                                 17   
541            2                                 16                  map { $self->{opts}->{$_}->{value} = undef; } @disable_opts;
               2                                 15   
542            2                                  8                  MKDEBUG && _d('Unset options', @disable_opts,
543                                                                     'because', $long,'disables them');
544                                                               }
545                                                   
546   ***    205     50                        1207               if ( exists $self->{allowed_groups}->{$long} ) {
547                                                   
548   ***      0                                  0                  my @restricted_groups = grep {
549   ***      0                                  0                     !exists $self->{allowed_groups}->{$long}->{$_}
550   ***      0                                  0                  } keys %{$self->{groups}};
551                                                   
552   ***      0                                  0                  my @restricted_opts;
553   ***      0                                  0                  foreach my $restricted_group ( @restricted_groups ) {
554   ***      0                                  0                     RESTRICTED_OPT:
555   ***      0                                  0                     foreach my $restricted_opt (
556                                                                        keys %{$self->{groups}->{$restricted_group}} )
557                                                                     {
558   ***      0      0                           0                        next RESTRICTED_OPT if $restricted_opt eq $long;
559   ***      0      0                           0                        push @restricted_opts, $restricted_opt
560                                                                           if $self->{opts}->{$restricted_opt}->{got};
561                                                                     }
562                                                                  }
563                                                   
564   ***      0      0                           0                  if ( @restricted_opts ) {
565   ***      0                                  0                     my $err;
566   ***      0      0                           0                     if ( @restricted_opts == 1 ) {
567   ***      0                                  0                        $err = "--$restricted_opts[0]";
568                                                                     }
569                                                                     else {
570   ***      0                                  0                        $err = join(', ',
571   ***      0                                  0                                  map { "--$self->{opts}->{$_}->{long}" }
572   ***      0                                  0                                  grep { $_ } 
573                                                                                  @restricted_opts[0..scalar(@restricted_opts) - 2]
574                                                                               )
575                                                                             . ' or --'.$self->{opts}->{$restricted_opts[-1]}->{long};
576                                                                     }
577   ***      0                                  0                     $self->save_error("--$long is not allowed with $err");
578                                                                  }
579                                                               }
580                                                   
581                                                            }
582                                                            elsif ( $opt->{is_required} ) { 
583            2                                 17               $self->save_error("Required option --$long must be specified");
584                                                            }
585                                                   
586         2580                              11743            $self->_validate_type($opt);
587   ***   2580     50                       11722            if ( $opt->{parsed} ) {
588         2580                              11423               delete $long[$i];
589                                                            }
590                                                            else {
591   ***      0                                  0               MKDEBUG && _d('Temporarily failed to parse', $long);
592                                                            }
593                                                         }
594                                                   
595   ***     43     50                         398         die "Failed to parse options, possibly due to circular dependencies"
596                                                            if @long == $long_last;
597           43                                270         $long_last = @long;
598                                                      }
599                                                   
600           43                                227      return;
601                                                   }
602                                                   
603                                                   sub _validate_type {
604         2580                 2580         11121      my ( $self, $opt ) = @_;
605   ***   2580     50                       11803      return unless $opt;
606                                                   
607         2580    100                       14008      if ( !$opt->{type} ) {
608         1376                               5529         $opt->{parsed} = 1;
609         1376                               4629         return;
610                                                      }
611                                                   
612         1204                               4798      my $val = $opt->{value};
613                                                   
614         1204    100    100                38392      if ( $val && $opt->{type} eq 'm' ) {  # type time
                    100    100                        
      ***            50     66                        
      ***            50     66                        
      ***           100     33                        
                           100                        
                           100                        
615           86                                243         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a time value');
616           86                               1169         my ( $prefix, $num, $suffix ) = $val =~ m/([+-]?)(\d+)([a-z])?$/;
617   ***     86     50                         552         if ( !$suffix ) {
618   ***      0                                  0            my ( $s ) = $opt->{desc} =~ m/\(suffix (.)\)/;
619   ***      0             0                    0            $suffix = $s || 's';
620   ***      0                                  0            MKDEBUG && _d('No suffix given; using', $suffix, 'for',
621                                                               $opt->{long}, '(value:', $val, ')');
622                                                         }
623   ***     86     50                         644         if ( $suffix =~ m/[smhd]/ ) {
624   ***     86      0                         467            $val = $suffix eq 's' ? $num            # Seconds
      ***             0                               
      ***            50                               
625                                                                 : $suffix eq 'm' ? $num * 60       # Minutes
626                                                                 : $suffix eq 'h' ? $num * 3600     # Hours
627                                                                 :                  $num * 86400;   # Days
628   ***     86            50                 1082            $opt->{value} = ($prefix || '') . $val;
629           86                                301            MKDEBUG && _d('Setting option', $opt->{long}, 'to', $val);
630                                                         }
631                                                         else {
632   ***      0                                  0            $self->save_error("Invalid time suffix for --$opt->{long}");
633                                                         }
634                                                      }
635                                                      elsif ( $val && $opt->{type} eq 'd' ) {  # type DSN
636           61                                179         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a DSN');
637           61                                258         my $prev = {};
638           61                                389         my $from_key = $self->{defaults_to}->{ $opt->{long} };
639           61    100                         300         if ( $from_key ) {
640           19                                 63            MKDEBUG && _d($opt->{long}, 'DSN copies from', $from_key, 'DSN');
641   ***     19     50                         152            if ( $self->{opts}->{$from_key}->{parsed} ) {
642           19                                119               $prev = $self->{opts}->{$from_key}->{value};
643                                                            }
644                                                            else {
645   ***      0                                  0               MKDEBUG && _d('Cannot parse', $opt->{long}, 'until',
646                                                                  $from_key, 'parsed');
647   ***      0                                  0               return;
648                                                            }
649                                                         }
650           61                                652         my $defaults = $self->{DSNParser}->parse_options($self);
651           61                                379         $opt->{value} = $self->{DSNParser}->parse($val, $prev, $defaults);
652                                                      }
653                                                      elsif ( $val && $opt->{type} eq 'z' ) {  # type size
654   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a size value');
655   ***      0                                  0         $self->_parse_size($opt, $val);
656                                                      }
657                                                      elsif ( $opt->{type} eq 'H' || (defined $val && $opt->{type} eq 'h') ) {
658   ***      0             0                    0         $opt->{value} = { map { $_ => 1 } split(/(?<!\\),\s*/, ($val || '')) };
      ***      0                                  0   
659                                                      }
660                                                      elsif ( $opt->{type} eq 'A' || (defined $val && $opt->{type} eq 'a') ) {
661   ***     47            50                  959         $opt->{value} = [ split(/(?<!\\),\s*/, ($val || '')) ];
662                                                      }
663                                                      else {
664         1010                               2918         MKDEBUG && _d('Nothing to validate for option',
665                                                            $opt->{long}, 'type', $opt->{type}, 'value', $val);
666                                                      }
667                                                   
668         1204                               5100      $opt->{parsed} = 1;
669         1204                               4136      return;
670                                                   }
671                                                   
672                                                   sub get {
673         4488                 4488         27085      my ( $self, $opt ) = @_;
674         4488    100                       29196      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
675   ***   4488     50     33                63668      die "Option $opt does not exist"
676                                                         unless $long && exists $self->{opts}->{$long};
677         4488                              62351      return $self->{opts}->{$long}->{value};
678                                                   }
679                                                   
680                                                   sub got {
681          214                  214          1257      my ( $self, $opt ) = @_;
682   ***    214     50                        1296      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
683   ***    214     50     33                 2843      die "Option $opt does not exist"
684                                                         unless $long && exists $self->{opts}->{$long};
685          214                               1947      return $self->{opts}->{$long}->{got};
686                                                   }
687                                                   
688                                                   sub has {
689          836                  836          3857      my ( $self, $opt ) = @_;
690          836    100                        5522      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
691          836    100                        7940      return defined $long ? exists $self->{opts}->{$long} : 0;
692                                                   }
693                                                   
694                                                   sub set {
695            5                    5            31      my ( $self, $opt, $val ) = @_;
696   ***      5     50                          32      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
697   ***      5     50     33                   71      die "Option $opt does not exist"
698                                                         unless $long && exists $self->{opts}->{$long};
699            5                                 29      $self->{opts}->{$long}->{value} = $val;
700            5                                 19      return;
701                                                   }
702                                                   
703                                                   sub save_error {
704            3                    3            22      my ( $self, $error ) = @_;
705            3                                 18      push @{$self->{errors}}, $error;
               3                                 21   
706            3                                 17      return;
707                                                   }
708                                                   
709                                                   sub errors {
710   ***      0                    0             0      my ( $self ) = @_;
711   ***      0                                  0      return $self->{errors};
712                                                   }
713                                                   
714                                                   sub usage {
715   ***      0                    0             0      my ( $self ) = @_;
716   ***      0      0                           0      warn "No usage string is set" unless $self->{usage}; # XXX
717   ***      0             0                    0      return "Usage: " . ($self->{usage} || '') . "\n";
718                                                   }
719                                                   
720                                                   sub descr {
721   ***      0                    0             0      my ( $self ) = @_;
722   ***      0      0                           0      warn "No description string is set" unless $self->{description}; # XXX
723   ***      0             0                    0      my $descr  = ($self->{description} || $self->{program_name} || '')
      ***                    0                        
724                                                                 . "  For more details, please use the --help option, "
725                                                                 . "or try 'perldoc $PROGRAM_NAME' "
726                                                                 . "for complete documentation.";
727   ***      0      0                           0      $descr = join("\n", $descr =~ m/(.{0,80})(?:\s+|$)/g)
728                                                         unless $ENV{DONT_BREAK_LINES};
729   ***      0                                  0      $descr =~ s/ +$//mg;
730   ***      0                                  0      return $descr;
731                                                   }
732                                                   
733                                                   sub usage_or_errors {
734           42                   42           244      my ( $self, $file, $return ) = @_;
735   ***     42            50                  754      $file ||= $self->{file} || __FILE__;
      ***                   33                        
736                                                   
737   ***     42     50     33                  354      if ( !$self->{description} || !$self->{usage} ) {
738           42                                119         MKDEBUG && _d("Getting description and usage from SYNOPSIS in", $file);
739           42                                411         my %synop = $self->_parse_synopsis($file);
740   ***     42            33                 1114         $self->{description} ||= $synop{description};
741   ***     42            33                  312         $self->{usage}       ||= $synop{usage};
742           42                                180         MKDEBUG && _d("Description:", $self->{description},
743                                                            "\nUsage:", $self->{usage});
744                                                      }
745                                                   
746   ***     42     50                         353      if ( $self->{opts}->{help}->{got} ) {
      ***     42     50                         306   
747   ***      0      0                           0         print $self->print_usage() or die "Cannot print usage: $OS_ERROR";
748   ***      0      0                           0         exit 0 unless $return;
749                                                      }
750                                                      elsif ( scalar @{$self->{errors}} ) {
751   ***      0      0                           0         print $self->print_errors() or die "Cannot print errors: $OS_ERROR";
752   ***      0      0                           0         exit 0 unless $return;
753                                                      }
754                                                   
755           42                                180      return;
756                                                   }
757                                                   
758                                                   sub print_errors {
759   ***      0                    0             0      my ( $self ) = @_;
760   ***      0                                  0      my $usage = $self->usage() . "\n";
761   ***      0      0                           0      if ( (my @errors = @{$self->{errors}}) ) {
      ***      0                                  0   
762   ***      0                                  0         $usage .= join("\n  * ", 'Errors in command-line arguments:', @errors)
763                                                                 . "\n";
764                                                      }
765   ***      0                                  0      return $usage . "\n" . $self->descr();
766                                                   }
767                                                   
768                                                   sub print_usage {
769   ***      0                    0             0      my ( $self ) = @_;
770   ***      0      0                           0      die "Run get_opts() before print_usage()" unless $self->{got_opts};
771   ***      0                                  0      my @opts = values %{$self->{opts}};
      ***      0                                  0   
772                                                   
773   ***      0      0                           0      my $maxl = max(
      ***             0                               
774                                                         map {
775   ***      0                                  0            length($_->{long})               # option long name
776                                                            + ($_->{is_negatable} ? 4 : 0)   # "[no]" if opt is negatable
777                                                            + ($_->{type} ? 2 : 0)           # "=x" where x is the opt type
778                                                         }
779                                                         @opts);
780                                                   
781   ***      0      0                           0      my $maxs = max(0,
      ***             0                               
782                                                         map {
783   ***      0                                  0            length($_)
784                                                            + ($self->{opts}->{$_}->{is_negatable} ? 4 : 0)
785                                                            + ($self->{opts}->{$_}->{type} ? 2 : 0)
786                                                         }
787   ***      0                                  0         values %{$self->{short_opts}});
788                                                   
789   ***      0                                  0      my $lcol = max($maxl, ($maxs + 3));
790   ***      0                                  0      my $rcol = 80 - $lcol - 6;
791   ***      0                                  0      my $rpad = ' ' x ( 80 - $rcol );
792                                                   
793   ***      0                                  0      $maxs = max($lcol - 3, $maxs);
794                                                   
795   ***      0                                  0      my $usage = $self->descr() . "\n" . $self->usage();
796                                                   
797   ***      0                                  0      my @groups = reverse sort grep { $_ ne 'default'; } keys %{$self->{groups}};
      ***      0                                  0   
      ***      0                                  0   
798   ***      0                                  0      push @groups, 'default';
799                                                   
800   ***      0                                  0      foreach my $group ( reverse @groups ) {
801   ***      0      0                           0         $usage .= "\n".($group eq 'default' ? 'Options' : $group).":\n\n";
802   ***      0                                  0         foreach my $opt (
      ***      0                                  0   
803   ***      0                                  0            sort { $a->{long} cmp $b->{long} }
804                                                            grep { $_->{group} eq $group }
805                                                            @opts )
806                                                         {
807   ***      0      0                           0            my $long  = $opt->{is_negatable} ? "[no]$opt->{long}" : $opt->{long};
808   ***      0                                  0            my $short = $opt->{short};
809   ***      0                                  0            my $desc  = $opt->{desc};
810                                                   
811   ***      0      0                           0            $long .= $opt->{type} ? "=$opt->{type}" : "";
812                                                   
813   ***      0      0      0                    0            if ( $opt->{type} && $opt->{type} eq 'm' ) {
814   ***      0                                  0               my ($s) = $desc =~ m/\(suffix (.)\)/;
815   ***      0             0                    0               $s    ||= 's';
816   ***      0                                  0               $desc =~ s/\s+\(suffix .\)//;
817   ***      0                                  0               $desc .= ".  Optional suffix s=seconds, m=minutes, h=hours, "
818                                                                      . "d=days; if no suffix, $s is used.";
819                                                            }
820   ***      0                                  0            $desc = join("\n$rpad", grep { $_ } $desc =~ m/(.{0,$rcol})(?:\s+|$)/g);
      ***      0                                  0   
821   ***      0                                  0            $desc =~ s/ +$//mg;
822   ***      0      0                           0            if ( $short ) {
823   ***      0                                  0               $usage .= sprintf("  --%-${maxs}s -%s  %s\n", $long, $short, $desc);
824                                                            }
825                                                            else {
826   ***      0                                  0               $usage .= sprintf("  --%-${lcol}s  %s\n", $long, $desc);
827                                                            }
828                                                         }
829                                                      }
830                                                   
831   ***      0                                  0      $usage .= "\nOption types: s=string, i=integer, f=float, h/H/a/A=comma-separated list, d=DSN, z=size, m=time\n";
832                                                   
833   ***      0      0                           0      if ( (my @rules = @{$self->{rules}}) ) {
      ***      0                                  0   
834   ***      0                                  0         $usage .= "\nRules:\n\n";
835   ***      0                                  0         $usage .= join("\n", map { "  $_" } @rules) . "\n";
      ***      0                                  0   
836                                                      }
837   ***      0      0                           0      if ( $self->{DSNParser} ) {
838   ***      0                                  0         $usage .= "\n" . $self->{DSNParser}->usage();
839                                                      }
840   ***      0                                  0      $usage .= "\nOptions and values after processing arguments:\n\n";
841   ***      0                                  0      foreach my $opt ( sort { $a->{long} cmp $b->{long} } @opts ) {
      ***      0                                  0   
842   ***      0                                  0         my $val   = $opt->{value};
843   ***      0             0                    0         my $type  = $opt->{type} || '';
844   ***      0                                  0         my $bool  = $opt->{spec} =~ m/^[\w-]+(?:\|[\w-])?!?$/;
845   ***      0      0                           0         $val      = $bool              ? ( $val ? 'TRUE' : 'FALSE' )
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
846                                                                   : !defined $val      ? '(No value)'
847                                                                   : $type eq 'd'       ? $self->{DSNParser}->as_string($val)
848                                                                   : $type =~ m/H|h/    ? join(',', sort keys %$val)
849                                                                   : $type =~ m/A|a/    ? join(',', @$val)
850                                                                   :                    $val;
851   ***      0                                  0         $usage .= sprintf("  --%-${lcol}s  %s\n", $opt->{long}, $val);
852                                                      }
853   ***      0                                  0      return $usage;
854                                                   }
855                                                   
856                                                   sub prompt_noecho {
857   ***      0      0             0             0      shift @_ if ref $_[0] eq __PACKAGE__;
858   ***      0                                  0      my ( $prompt ) = @_;
859   ***      0                                  0      local $OUTPUT_AUTOFLUSH = 1;
860   ***      0      0                           0      print $prompt
861                                                         or die "Cannot print: $OS_ERROR";
862   ***      0                                  0      my $response;
863   ***      0                                  0      eval {
864   ***      0                                  0         require Term::ReadKey;
865   ***      0                                  0         Term::ReadKey::ReadMode('noecho');
866   ***      0                                  0         chomp($response = <STDIN>);
867   ***      0                                  0         Term::ReadKey::ReadMode('normal');
868   ***      0      0                           0         print "\n"
869                                                            or die "Cannot print: $OS_ERROR";
870                                                      };
871   ***      0      0                           0      if ( $EVAL_ERROR ) {
872   ***      0                                  0         die "Cannot read response; is Term::ReadKey installed? $EVAL_ERROR";
873                                                      }
874   ***      0                                  0      return $response;
875                                                   }
876                                                   
877                                                   if ( MKDEBUG ) {
878                                                      print '# ', $^X, ' ', $], "\n";
879                                                      my $uname = `uname -a`;
880                                                      if ( $uname ) {
881                                                         $uname =~ s/\s+/ /g;
882                                                         print "# $uname\n";
883                                                      }
884                                                      printf("# %s  Ver %s Distrib %s Changeset %s line %d\n",
885                                                         $PROGRAM_NAME, ($main::VERSION || ''), ($main::DISTRIB || ''),
886                                                         ($main::SVN_REV || ''), __LINE__);
887                                                      print('# Arguments: ',
888                                                         join(' ', map { my $a = "_[$_]_"; $a =~ s/\n/\n# /g; $a; } @ARGV), "\n");
889                                                   }
890                                                   
891                                                   sub _read_config_file {
892          172                  172           966      my ( $self, $filename ) = @_;
893   ***    172     50                         516      open my $fh, "<", $filename or die "Cannot open $filename: $OS_ERROR\n";
894   ***      0                                  0      my @args;
895   ***      0                                  0      my $prefix = '--';
896   ***      0                                  0      my $parse  = 1;
897                                                   
898                                                      LINE:
899   ***      0                                  0      while ( my $line = <$fh> ) {
900   ***      0                                  0         chomp $line;
901   ***      0      0                           0         next LINE if $line =~ m/^\s*(?:\#|\;|$)/;
902   ***      0                                  0         $line =~ s/\s+#.*$//g;
903   ***      0                                  0         $line =~ s/^\s+|\s+$//g;
904   ***      0      0                           0         if ( $line eq '--' ) {
905   ***      0                                  0            $prefix = '';
906   ***      0                                  0            $parse  = 0;
907   ***      0                                  0            next LINE;
908                                                         }
909   ***      0      0      0                    0         if ( $parse
      ***             0                               
910                                                            && (my($opt, $arg) = $line =~ m/^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/)
911                                                         ) {
912   ***      0                                  0            push @args, grep { defined $_ } ("$prefix$opt", $arg);
      ***      0                                  0   
913                                                         }
914                                                         elsif ( $line =~ m/./ ) {
915   ***      0                                  0            push @args, $line;
916                                                         }
917                                                         else {
918   ***      0                                  0            die "Syntax error in file $filename at line $INPUT_LINE_NUMBER";
919                                                         }
920                                                      }
921   ***      0                                  0      close $fh;
922   ***      0                                  0      return @args;
923                                                   }
924                                                   
925                                                   sub read_para_after {
926   ***      0                    0             0      my ( $self, $file, $regex ) = @_;
927   ***      0      0                           0      open my $fh, "<", $file or die "Can't open $file: $OS_ERROR";
928   ***      0                                  0      local $INPUT_RECORD_SEPARATOR = '';
929   ***      0                                  0      my $para;
930   ***      0                                  0      while ( $para = <$fh> ) {
931   ***      0      0                           0         next unless $para =~ m/^=pod$/m;
932   ***      0                                  0         last;
933                                                      }
934   ***      0                                  0      while ( $para = <$fh> ) {
935   ***      0      0                           0         next unless $para =~ m/$regex/;
936   ***      0                                  0         last;
937                                                      }
938   ***      0                                  0      $para = <$fh>;
939   ***      0                                  0      chomp($para);
940   ***      0      0                           0      close $fh or die "Can't close $file: $OS_ERROR";
941   ***      0                                  0      return $para;
942                                                   }
943                                                   
944                                                   sub clone {
945   ***      0                    0             0      my ( $self ) = @_;
946                                                   
947   ***      0                                  0      my %clone = map {
948   ***      0                                  0         my $hashref  = $self->{$_};
949   ***      0                                  0         my $val_copy = {};
950   ***      0                                  0         foreach my $key ( keys %$hashref ) {
951   ***      0                                  0            my $ref = ref $hashref->{$key};
952   ***      0                                  0            $val_copy->{$key} = !$ref           ? $hashref->{$key}
953   ***      0                                  0                              : $ref eq 'HASH'  ? { %{$hashref->{$key}} }
954   ***      0      0                           0                              : $ref eq 'ARRAY' ? [ @{$hashref->{$key}} ]
      ***             0                               
      ***             0                               
955                                                                              : $hashref->{$key};
956                                                         }
957   ***      0                                  0         $_ => $val_copy;
958                                                      } qw(opts short_opts defaults);
959                                                   
960   ***      0                                  0      foreach my $scalar ( qw(got_opts) ) {
961   ***      0                                  0         $clone{$scalar} = $self->{$scalar};
962                                                      }
963                                                   
964   ***      0                                  0      return bless \%clone;     
965                                                   }
966                                                   
967                                                   sub _parse_size {
968   ***      0                    0             0      my ( $self, $opt, $val ) = @_;
969                                                   
970   ***      0      0      0                    0      if ( lc($val || '') eq 'null' ) {
971   ***      0                                  0         MKDEBUG && _d('NULL size for', $opt->{long});
972   ***      0                                  0         $opt->{value} = 'null';
973   ***      0                                  0         return;
974                                                      }
975                                                   
976   ***      0                                  0      my %factor_for = (k => 1_024, M => 1_048_576, G => 1_073_741_824);
977   ***      0                                  0      my ($pre, $num, $factor) = $val =~ m/^([+-])?(\d+)([kMG])?$/;
978   ***      0      0                           0      if ( defined $num ) {
979   ***      0      0                           0         if ( $factor ) {
980   ***      0                                  0            $num *= $factor_for{$factor};
981   ***      0                                  0            MKDEBUG && _d('Setting option', $opt->{y},
982                                                               'to num', $num, '* factor', $factor);
983                                                         }
984   ***      0             0                    0         $opt->{value} = ($pre || '') . $num;
985                                                      }
986                                                      else {
987   ***      0                                  0         $self->save_error("Invalid size for --$opt->{long}");
988                                                      }
989   ***      0                                  0      return;
990                                                   }
991                                                   
992                                                   sub _parse_attribs {
993         2580                 2580         15252      my ( $self, $option, $attribs ) = @_;
994         2580                              12352      my $types = $self->{types};
995         2580    100                       62375      return $option
                    100                               
      ***            50                               
                    100                               
996                                                         . ($attribs->{'short form'} ? '|' . $attribs->{'short form'}   : '' )
997                                                         . ($attribs->{'negatable'}  ? '!'                              : '' )
998                                                         . ($attribs->{'cumulative'} ? '+'                              : '' )
999                                                         . ($attribs->{'type'}       ? '=' . $types->{$attribs->{type}} : '' );
1000                                                  }
1001                                                  
1002                                                  sub _parse_synopsis {
1003          42                   42           256      my ( $self, $file ) = @_;
1004  ***     42             0                  364      $file ||= $self->{file} || __FILE__;
      ***                   33                        
1005          42                                122      MKDEBUG && _d("Parsing SYNOPSIS in", $file);
1006                                                  
1007          42                                385      local $INPUT_RECORD_SEPARATOR = '';  # read paragraphs
1008  ***     42     50                        2614      open my $fh, "<", $file or die "Cannot open $file: $OS_ERROR";
1009          42                                148      my $para;
1010  ***     42            66               210292      1 while defined($para = <$fh>) && $para !~ m/^=head1 SYNOPSIS/;
1011  ***     42     50                         228      die "$file does not contain a SYNOPSIS section" unless $para;
1012          42                                150      my @synop;
1013          42                                285      for ( 1..2 ) {  # 1 for the usage, 2 for the description
1014          84                                461         my $para = <$fh>;
1015          84                                519         push @synop, $para;
1016                                                     }
1017          42                                581      close $fh;
1018          42                                132      MKDEBUG && _d("Raw SYNOPSIS text:", @synop);
1019          42                                288      my ($usage, $desc) = @synop;
1020  ***     42     50     33                  692      die "The SYNOPSIS section in $file is not formatted properly"
1021                                                        unless $usage && $desc;
1022                                                  
1023          42                                858      $usage =~ s/^\s*Usage:\s+(.+)/$1/;
1024          42                                198      chomp $usage;
1025                                                  
1026          42                                389      $desc =~ s/\n/ /g;
1027          42                                527      $desc =~ s/\s{2,}/ /g;
1028          42                                520      $desc =~ s/\. ([A-Z][a-z])/.  $1/g;
1029          42                                554      $desc =~ s/\s+$//;
1030                                                  
1031                                                     return (
1032          42                                165         description => $desc,
1033                                                        usage       => $usage,
1034                                                     );
1035                                                  };
1036                                                  
1037                                                  sub _d {
1038  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1039  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1040  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1041                                                          @_;
1042  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1043                                                  }
1044                                                  
1045                                                  1;
1046                                                  
1047                                                  # ###########################################################################
1048                                                  # End OptionParser package
1049                                                  # ###########################################################################
1050                                                  
1051                                                  # ###########################################################################
1052                                                  # TableParser package 7156
1053                                                  # This package is a copy without comments from the original.  The original
1054                                                  # with comments and its test file can be found in the SVN repository at,
1055                                                  #   trunk/common/TableParser.pm
1056                                                  #   trunk/common/t/TableParser.t
1057                                                  # See http://code.google.com/p/maatkit/wiki/Developers for more information.
1058                                                  # ###########################################################################
1059                                                  
1060                                                  package TableParser;
1061                                                  
1062          21                   21           240   use strict;
              21                                 60   
              21                                161   
1063          21                   21           137   use warnings FATAL => 'all';
              21                                 51   
              21                                149   
1064          21                   21           132   use English qw(-no_match_vars);
              21                                 48   
              21                                159   
1065          21                   21           138   use Data::Dumper;
              21                                 54   
              21                                176   
1066                                                  $Data::Dumper::Indent    = 1;
1067                                                  $Data::Dumper::Sortkeys  = 1;
1068                                                  $Data::Dumper::Quotekeys = 0;
1069                                                  
1070  ***     21            50     21           140   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              21                                 59   
              21                                350   
1071                                                  
1072                                                  sub new {
1073          42                   42           443      my ( $class, %args ) = @_;
1074          42                                244      my @required_args = qw(Quoter);
1075          42                                321      foreach my $arg ( @required_args ) {
1076  ***     42     50                         332         die "I need a $arg argument" unless $args{$arg};
1077                                                     }
1078          42                                334      my $self = { %args };
1079          42                                552      return bless $self, $class;
1080                                                  }
1081                                                  
1082                                                  sub parse {
1083          61                   61           390      my ( $self, $ddl, $opts ) = @_;
1084  ***     61     50                         332      return unless $ddl;
1085  ***     61     50                         397      if ( ref $ddl eq 'ARRAY' ) {
1086  ***     61     50                         403         if ( lc $ddl->[0] eq 'table' ) {
1087          61                                328            $ddl = $ddl->[1];
1088                                                        }
1089                                                        else {
1090                                                           return {
1091  ***      0                                  0               engine => 'VIEW',
1092                                                           };
1093                                                        }
1094                                                     }
1095                                                  
1096  ***     61     50                         778      if ( $ddl !~ m/CREATE (?:TEMPORARY )?TABLE `/ ) {
1097  ***      0                                  0         die "Cannot parse table definition; is ANSI quoting "
1098                                                           . "enabled or SQL_QUOTE_SHOW_CREATE disabled?";
1099                                                     }
1100                                                  
1101          61                                697      my ($name)     = $ddl =~ m/CREATE (?:TEMPORARY )?TABLE\s+(`.+?`)/;
1102  ***     61     50                         754      (undef, $name) = $self->{Quoter}->split_unquote($name) if $name;
1103                                                  
1104          61                               1869      $ddl =~ s/(`[^`]+`)/\L$1/g;
1105                                                  
1106          61                                540      my $engine = $self->get_engine($ddl);
1107                                                  
1108          61                               1977      my @defs   = $ddl =~ m/^(\s+`.*?),?$/gm;
1109          61                                322      my @cols   = map { $_ =~ m/`([^`]+)`/ } @defs;
             234                               1557   
1110          61                                214      MKDEBUG && _d('Table cols:', join(', ', map { "`$_`" } @cols));
1111                                                  
1112          61                                194      my %def_for;
1113          61                                504      @def_for{@cols} = @defs;
1114                                                  
1115          61                                230      my (@nums, @null);
1116          61                                239      my (%type_for, %is_nullable, %is_numeric, %is_autoinc);
1117          61                                369      foreach my $col ( @cols ) {
1118         234                                930         my $def = $def_for{$col};
1119         234                               1854         my ( $type ) = $def =~ m/`[^`]+`\s([a-z]+)/;
1120  ***    234     50                        1141         die "Can't determine column type for $def" unless $type;
1121         234                                956         $type_for{$col} = $type;
1122         234    100                        1657         if ( $type =~ m/(?:(?:tiny|big|medium|small)?int|float|double|decimal|year)/ ) {
1123         164                                670            push @nums, $col;
1124         164                                704            $is_numeric{$col} = 1;
1125                                                        }
1126         234    100                        1358         if ( $def !~ m/NOT NULL/ ) {
1127         100                                380            push @null, $col;
1128         100                                404            $is_nullable{$col} = 1;
1129                                                        }
1130         234    100                        1626         $is_autoinc{$col} = $def =~ m/AUTO_INCREMENT/i ? 1 : 0;
1131                                                     }
1132                                                  
1133          61                                562      my ($keys, $clustered_key) = $self->get_keys($ddl, $opts, \%is_nullable);
1134                                                  
1135          61                                603      my ($charset) = $ddl =~ m/DEFAULT CHARSET=(\w+)/;
1136                                                  
1137                                                     return {
1138         234                               1313         name           => $name,
1139                                                        cols           => \@cols,
1140         234                               2700         col_posn       => { map { $cols[$_] => $_ } 0..$#cols },
1141          61                                774         is_col         => { map { $_ => 1 } @cols },
1142                                                        null_cols      => \@null,
1143                                                        is_nullable    => \%is_nullable,
1144                                                        is_autoinc     => \%is_autoinc,
1145                                                        clustered_key  => $clustered_key,
1146                                                        keys           => $keys,
1147                                                        defs           => \%def_for,
1148                                                        numeric_cols   => \@nums,
1149                                                        is_numeric     => \%is_numeric,
1150                                                        engine         => $engine,
1151                                                        type_for       => \%type_for,
1152                                                        charset        => $charset,
1153                                                     };
1154                                                  }
1155                                                  
1156                                                  sub sort_indexes {
1157          39                   39           191      my ( $self, $tbl ) = @_;
1158                                                  
1159                                                     my @indexes
1160  ***      0                                  0         = sort {
1161          67                                408            (($a ne 'PRIMARY') <=> ($b ne 'PRIMARY'))
1162                                                           || ( !$tbl->{keys}->{$a}->{is_unique} <=> !$tbl->{keys}->{$b}->{is_unique} )
1163                                                           || ( $tbl->{keys}->{$a}->{is_nullable} <=> $tbl->{keys}->{$b}->{is_nullable} )
1164  ***     28     50     33                  289            || ( scalar(@{$tbl->{keys}->{$a}->{cols}}) <=> scalar(@{$tbl->{keys}->{$b}->{cols}}) )
      ***      0            33                    0   
1165                                                        }
1166                                                        grep {
1167          39                                424            $tbl->{keys}->{$_}->{type} eq 'BTREE'
1168                                                        }
1169          39                                166         sort keys %{$tbl->{keys}};
1170                                                  
1171          39                                259      MKDEBUG && _d('Indexes sorted best-first:', join(', ', @indexes));
1172          39                                289      return @indexes;
1173                                                  }
1174                                                  
1175                                                  sub find_best_index {
1176          39                   39           211      my ( $self, $tbl, $index ) = @_;
1177          39                                131      my $best;
1178  ***     39     50                         202      if ( $index ) {
1179  ***      0                                  0         ($best) = grep { uc $_ eq uc $index } keys %{$tbl->{keys}};
      ***      0                                  0   
      ***      0                                  0   
1180                                                     }
1181  ***     39     50                         214      if ( !$best ) {
1182  ***     39     50                         190         if ( $index ) {
1183  ***      0                                  0            die "Index '$index' does not exist in table";
1184                                                        }
1185                                                        else {
1186          39                                277            ($best) = $self->sort_indexes($tbl);
1187                                                        }
1188                                                     }
1189          39                                128      MKDEBUG && _d('Best index found is', $best);
1190          39                                195      return $best;
1191                                                  }
1192                                                  
1193                                                  sub find_possible_keys {
1194  ***      0                    0             0      my ( $self, $dbh, $database, $table, $quoter, $where ) = @_;
1195  ***      0      0                           0      return () unless $where;
1196  ***      0                                  0      my $sql = 'EXPLAIN SELECT * FROM ' . $quoter->quote($database, $table)
1197                                                        . ' WHERE ' . $where;
1198  ***      0                                  0      MKDEBUG && _d($sql);
1199  ***      0                                  0      my $expl = $dbh->selectrow_hashref($sql);
1200  ***      0                                  0      $expl = { map { lc($_) => $expl->{$_} } keys %$expl };
      ***      0                                  0   
1201  ***      0      0                           0      if ( $expl->{possible_keys} ) {
1202  ***      0                                  0         MKDEBUG && _d('possible_keys =', $expl->{possible_keys});
1203  ***      0                                  0         my @candidates = split(',', $expl->{possible_keys});
1204  ***      0                                  0         my %possible   = map { $_ => 1 } @candidates;
      ***      0                                  0   
1205  ***      0      0                           0         if ( $expl->{key} ) {
1206  ***      0                                  0            MKDEBUG && _d('MySQL chose', $expl->{key});
1207  ***      0                                  0            unshift @candidates, grep { $possible{$_} } split(',', $expl->{key});
      ***      0                                  0   
1208  ***      0                                  0            MKDEBUG && _d('Before deduping:', join(', ', @candidates));
1209  ***      0                                  0            my %seen;
1210  ***      0                                  0            @candidates = grep { !$seen{$_}++ } @candidates;
      ***      0                                  0   
1211                                                        }
1212  ***      0                                  0         MKDEBUG && _d('Final list:', join(', ', @candidates));
1213  ***      0                                  0         return @candidates;
1214                                                     }
1215                                                     else {
1216  ***      0                                  0         MKDEBUG && _d('No keys in possible_keys');
1217  ***      0                                  0         return ();
1218                                                     }
1219                                                  }
1220                                                  
1221                                                  sub check_table {
1222  ***      0                    0             0      my ( $self, %args ) = @_;
1223  ***      0                                  0      my @required_args = qw(dbh db tbl);
1224  ***      0                                  0      foreach my $arg ( @required_args ) {
1225  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
1226                                                     }
1227  ***      0                                  0      my ($dbh, $db, $tbl) = @args{@required_args};
1228  ***      0                                  0      my $q      = $self->{Quoter};
1229  ***      0                                  0      my $db_tbl = $q->quote($db, $tbl);
1230  ***      0                                  0      MKDEBUG && _d('Checking', $db_tbl);
1231                                                  
1232  ***      0                                  0      my $sql = "SHOW TABLES FROM " . $q->quote($db)
1233                                                             . ' LIKE ' . $q->literal_like($tbl);
1234  ***      0                                  0      MKDEBUG && _d($sql);
1235  ***      0                                  0      my $row;
1236  ***      0                                  0      eval {
1237  ***      0                                  0         $row = $dbh->selectrow_arrayref($sql);
1238                                                     };
1239  ***      0      0                           0      if ( $EVAL_ERROR ) {
1240  ***      0                                  0         MKDEBUG && _d($EVAL_ERROR);
1241  ***      0                                  0         return 0;
1242                                                     }
1243  ***      0      0      0                    0      if ( !$row->[0] || $row->[0] ne $tbl ) {
1244  ***      0                                  0         MKDEBUG && _d('Table does not exist');
1245  ***      0                                  0         return 0;
1246                                                     }
1247                                                  
1248  ***      0                                  0      MKDEBUG && _d('Table exists; no privs to check');
1249  ***      0      0                           0      return 1 unless $args{all_privs};
1250                                                  
1251  ***      0                                  0      $sql = "SHOW FULL COLUMNS FROM $db_tbl";
1252  ***      0                                  0      MKDEBUG && _d($sql);
1253  ***      0                                  0      eval {
1254  ***      0                                  0         $row = $dbh->selectrow_hashref($sql);
1255                                                     };
1256  ***      0      0                           0      if ( $EVAL_ERROR ) {
1257  ***      0                                  0         MKDEBUG && _d($EVAL_ERROR);
1258  ***      0                                  0         return 0;
1259                                                     }
1260  ***      0      0                           0      if ( !scalar keys %$row ) {
1261  ***      0                                  0         MKDEBUG && _d('Table has no columns:', Dumper($row));
1262  ***      0                                  0         return 0;
1263                                                     }
1264  ***      0             0                    0      my $privs = $row->{privileges} || $row->{Privileges};
1265                                                  
1266  ***      0                                  0      $sql = "DELETE FROM $db_tbl LIMIT 0";
1267  ***      0                                  0      MKDEBUG && _d($sql);
1268  ***      0                                  0      eval {
1269  ***      0                                  0         $dbh->do($sql);
1270                                                     };
1271  ***      0      0                           0      my $can_delete = $EVAL_ERROR ? 0 : 1;
1272                                                  
1273  ***      0                                  0      MKDEBUG && _d('User privs on', $db_tbl, ':', $privs,
1274                                                        ($can_delete ? 'delete' : ''));
1275                                                  
1276  ***      0      0      0                    0      if ( !($privs =~ m/select/ && $privs =~ m/insert/ && $privs =~ m/update/
      ***                    0                        
      ***                    0                        
1277                                                            && $can_delete) ) {
1278  ***      0                                  0         MKDEBUG && _d('User does not have all privs');
1279  ***      0                                  0         return 0;
1280                                                     }
1281                                                  
1282  ***      0                                  0      MKDEBUG && _d('User has all privs');
1283  ***      0                                  0      return 1;
1284                                                  }
1285                                                  
1286                                                  sub get_engine {
1287         122                  122           702      my ( $self, $ddl, $opts ) = @_;
1288         122                               2542      my ( $engine ) = $ddl =~ m/\).*?(?:ENGINE|TYPE)=(\w+)/;
1289         122                                373      MKDEBUG && _d('Storage engine:', $engine);
1290  ***    122            50                  804      return $engine || undef;
1291                                                  }
1292                                                  
1293                                                  sub get_keys {
1294          61                   61           424      my ( $self, $ddl, $opts, $is_nullable ) = @_;
1295          61                                340      my $engine        = $self->get_engine($ddl);
1296          61                                236      my $keys          = {};
1297          61                                219      my $clustered_key = undef;
1298                                                  
1299                                                     KEY:
1300          61                                974      foreach my $key ( $ddl =~ m/^  ((?:[A-Z]+ )?KEY .*)$/gm ) {
1301                                                  
1302  ***     85     50                         466         next KEY if $key =~ m/FOREIGN/;
1303                                                  
1304          85                                295         my $key_ddl = $key;
1305          85                                219         MKDEBUG && _d('Parsed key:', $key_ddl);
1306                                                  
1307  ***     85     50                         661         if ( $engine !~ m/MEMORY|HEAP/ ) {
1308          85                                413            $key =~ s/USING HASH/USING BTREE/;
1309                                                        }
1310                                                  
1311          85                                831         my ( $type, $cols ) = $key =~ m/(?:USING (\w+))? \((.+)\)/;
1312          85                                522         my ( $special ) = $key =~ m/(FULLTEXT|SPATIAL)/;
1313  ***     85            33                 1453         $type = $type || $special || 'BTREE';
      ***                   50                        
1314  ***     85     50     33                  763         if ( $opts->{mysql_version} && $opts->{mysql_version} lt '004001000'
      ***                   33                        
1315                                                           && $engine =~ m/HEAP|MEMORY/i )
1316                                                        {
1317  ***      0                                  0            $type = 'HASH'; # MySQL pre-4.1 supports only HASH indexes on HEAP
1318                                                        }
1319                                                  
1320          85                                825         my ($name) = $key =~ m/(PRIMARY|`[^`]*`)/;
1321          85    100                         636         my $unique = $key =~ m/PRIMARY|UNIQUE/ ? 1 : 0;
1322          85                                255         my @cols;
1323          85                                244         my @col_prefixes;
1324          85                                711         foreach my $col_def ( $cols =~ m/`[^`]+`(?:\(\d+\))?/g ) {
1325         100                                752            my ($name, $prefix) = $col_def =~ m/`([^`]+)`(?:\((\d+)\))?/;
1326         100                                449            push @cols, $name;
1327         100                                509            push @col_prefixes, $prefix;
1328                                                        }
1329          85                                459         $name =~ s/`//g;
1330                                                  
1331          85                                269         MKDEBUG && _d( $name, 'key cols:', join(', ', map { "`$_`" } @cols));
1332                                                  
1333         100                                574         $keys->{$name} = {
1334                                                           name         => $name,
1335                                                           type         => $type,
1336                                                           colnames     => $cols,
1337                                                           cols         => \@cols,
1338                                                           col_prefixes => \@col_prefixes,
1339                                                           is_unique    => $unique,
1340         100                               1380            is_nullable  => scalar(grep { $is_nullable->{$_} } @cols),
1341          85                                619            is_col       => { map { $_ => 1 } @cols },
1342                                                           ddl          => $key_ddl,
1343                                                        };
1344                                                  
1345          85    100    100                 1302         if ( $engine =~ m/InnoDB/i && !$clustered_key ) {
1346          46                                202            my $this_key = $keys->{$name};
1347  ***     46     50      0                  274            if ( $this_key->{name} eq 'PRIMARY' ) {
      ***             0                               
1348          46                                181               $clustered_key = 'PRIMARY';
1349                                                           }
1350                                                           elsif ( $this_key->{is_unique} && !$this_key->{is_nullable} ) {
1351  ***      0                                  0               $clustered_key = $this_key->{name};
1352                                                           }
1353          46                                214            MKDEBUG && $clustered_key && _d('This key is the clustered key');
1354                                                        }
1355                                                     }
1356                                                  
1357          61                                443      return $keys, $clustered_key;
1358                                                  }
1359                                                  
1360                                                  sub get_fks {
1361  ***      0                    0             0      my ( $self, $ddl, $opts ) = @_;
1362  ***      0                                  0      my $fks = {};
1363                                                  
1364  ***      0                                  0      foreach my $fk (
1365                                                        $ddl =~ m/CONSTRAINT .* FOREIGN KEY .* REFERENCES [^\)]*\)/mg )
1366                                                     {
1367  ***      0                                  0         my ( $name ) = $fk =~ m/CONSTRAINT `(.*?)`/;
1368  ***      0                                  0         my ( $cols ) = $fk =~ m/FOREIGN KEY \(([^\)]+)\)/;
1369  ***      0                                  0         my ( $parent, $parent_cols ) = $fk =~ m/REFERENCES (\S+) \(([^\)]+)\)/;
1370                                                  
1371  ***      0      0      0                    0         if ( $parent !~ m/\./ && $opts->{database} ) {
1372  ***      0                                  0            $parent = "`$opts->{database}`.$parent";
1373                                                        }
1374                                                  
1375  ***      0                                  0         $fks->{$name} = {
1376                                                           name           => $name,
1377                                                           colnames       => $cols,
1378  ***      0                                  0            cols           => [ map { s/[ `]+//g; $_; } split(',', $cols) ],
      ***      0                                  0   
1379                                                           parent_tbl     => $parent,
1380                                                           parent_colnames=> $parent_cols,
1381  ***      0                                  0            parent_cols    => [ map { s/[ `]+//g; $_; } split(',', $parent_cols) ],
      ***      0                                  0   
1382                                                           ddl            => $fk,
1383                                                        };
1384                                                     }
1385                                                  
1386  ***      0                                  0      return $fks;
1387                                                  }
1388                                                  
1389                                                  sub remove_auto_increment {
1390  ***      0                    0             0      my ( $self, $ddl ) = @_;
1391  ***      0                                  0      $ddl =~ s/(^\).*?) AUTO_INCREMENT=\d+\b/$1/m;
1392  ***      0                                  0      return $ddl;
1393                                                  }
1394                                                  
1395                                                  sub remove_secondary_indexes {
1396  ***      0                    0             0      my ( $self, $ddl ) = @_;
1397  ***      0                                  0      my $sec_indexes_ddl;
1398  ***      0                                  0      my $tbl_struct = $self->parse($ddl);
1399                                                  
1400  ***      0      0      0                    0      if ( ($tbl_struct->{engine} || '') =~ m/InnoDB/i ) {
1401  ***      0                                  0         my $clustered_key = $tbl_struct->{clustered_key};
1402  ***      0             0                    0         $clustered_key  ||= '';
1403                                                  
1404  ***      0                                  0         my @sec_indexes   = map {
1405  ***      0                                  0            my $key_def = $_->{ddl};
1406  ***      0                                  0            $key_def =~ s/([\(\)])/\\$1/g;
1407  ***      0                                  0            $ddl =~ s/\s+$key_def//i;
1408                                                  
1409  ***      0                                  0            my $key_ddl = "ADD $_->{ddl}";
1410  ***      0      0                           0            $key_ddl   .= ',' unless $key_ddl =~ m/,$/;
1411  ***      0                                  0            $key_ddl;
1412                                                        }
1413  ***      0                                  0         grep { $_->{name} ne $clustered_key }
1414  ***      0                                  0         values %{$tbl_struct->{keys}};
1415  ***      0                                  0         MKDEBUG && _d('Secondary indexes:', Dumper(\@sec_indexes));
1416                                                  
1417  ***      0      0                           0         if ( @sec_indexes ) {
1418  ***      0                                  0            $sec_indexes_ddl = join(' ', @sec_indexes);
1419  ***      0                                  0            $sec_indexes_ddl =~ s/,$//;
1420                                                        }
1421                                                  
1422  ***      0                                  0         $ddl =~ s/,(\n\) )/$1/s;
1423                                                     }
1424                                                     else {
1425  ***      0                                  0         MKDEBUG && _d('Not removing secondary indexes from',
1426                                                           $tbl_struct->{engine}, 'table');
1427                                                     }
1428                                                  
1429  ***      0                                  0      return $ddl, $sec_indexes_ddl, $tbl_struct;
1430                                                  }
1431                                                  
1432                                                  sub _d {
1433  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1434  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1435  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1436                                                          @_;
1437  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1438                                                  }
1439                                                  
1440                                                  1;
1441                                                  
1442                                                  # ###########################################################################
1443                                                  # End TableParser package
1444                                                  # ###########################################################################
1445                                                  
1446                                                  # ###########################################################################
1447                                                  # DSNParser package 6785
1448                                                  # This package is a copy without comments from the original.  The original
1449                                                  # with comments and its test file can be found in the SVN repository at,
1450                                                  #   trunk/common/DSNParser.pm
1451                                                  #   trunk/common/t/DSNParser.t
1452                                                  # See http://code.google.com/p/maatkit/wiki/Developers for more information.
1453                                                  # ###########################################################################
1454                                                  
1455                                                  package DSNParser;
1456                                                  
1457          21                   21           186   use strict;
              21                                 76   
              21                                128   
1458          21                   21           128   use warnings FATAL => 'all';
              21                                 52   
              21                                128   
1459          21                   21           127   use English qw(-no_match_vars);
              21                                 62   
              21                                131   
1460  ***     21            50     21           138   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              21                                 56   
              21                                317   
1461                                                  
1462          21                   21           146   use Data::Dumper;
              21                                 52   
              21                                118   
1463                                                  $Data::Dumper::Indent    = 0;
1464                                                  $Data::Dumper::Quotekeys = 0;
1465                                                  
1466                                                  eval {
1467                                                     require DBI;
1468                                                  };
1469                                                  my $have_dbi = $EVAL_ERROR ? 0 : 1;
1470                                                  
1471                                                  
1472                                                  sub new {
1473          64                   64           991      my ( $class, %args ) = @_;
1474          64                                580      foreach my $arg ( qw(opts) ) {
1475  ***     64     50                         685         die "I need a $arg argument" unless $args{$arg};
1476                                                     }
1477          64                                382      my $self = {
1478                                                        opts => {}  # h, P, u, etc.  Should come from DSN OPTIONS section in POD.
1479                                                     };
1480          64                                376      foreach my $opt ( @{$args{opts}} ) {
              64                                399   
1481  ***    748     50     33                 8974         if ( !$opt->{key} || !$opt->{desc} ) {
1482  ***      0                                  0            die "Invalid DSN option: ", Dumper($opt);
1483                                                        }
1484                                                        MKDEBUG && _d('DSN option:',
1485                                                           join(', ',
1486         748                               2715               map { "$_=" . (defined $opt->{$_} ? ($opt->{$_} || '') : 'undef') }
1487                                                                 keys %$opt
1488                                                           )
1489                                                        );
1490         748           100                 9860         $self->{opts}->{$opt->{key}} = {
1491                                                           dsn  => $opt->{dsn},
1492                                                           desc => $opt->{desc},
1493                                                           copy => $opt->{copy} || 0,
1494                                                        };
1495                                                     }
1496          64                               1879      return bless $self, $class;
1497                                                  }
1498                                                  
1499                                                  sub prop {
1500         362                  362          2052      my ( $self, $prop, $value ) = @_;
1501         362    100                        2146      if ( @_ > 2 ) {
1502          43                                115         MKDEBUG && _d('Setting', $prop, 'property');
1503          43                                212         $self->{$prop} = $value;
1504                                                     }
1505         362                               2977      return $self->{$prop};
1506                                                  }
1507                                                  
1508                                                  sub parse {
1509         147                  147          2861      my ( $self, $dsn, $prev, $defaults ) = @_;
1510         147    100                         874      if ( !$dsn ) {
1511          61                                176         MKDEBUG && _d('No DSN to parse');
1512          61                                302         return;
1513                                                     }
1514          86                                288      MKDEBUG && _d('Parsing', $dsn);
1515          86           100                  495      $prev     ||= {};
1516  ***     86            50                  504      $defaults ||= {};
1517          86                                310      my %given_props;
1518          86                                297      my %final_props;
1519          86                                397      my $opts = $self->{opts};
1520                                                  
1521          86                                844      foreach my $dsn_part ( split(/,/, $dsn) ) {
1522  ***    251     50                        2586         if ( my ($prop_key, $prop_val) = $dsn_part =~  m/^(.)=(.*)$/ ) {
1523         251                               1492            $given_props{$prop_key} = $prop_val;
1524                                                        }
1525                                                        else {
1526  ***      0                                  0            MKDEBUG && _d('Interpreting', $dsn_part, 'as h=', $dsn_part);
1527  ***      0                                  0            $given_props{h} = $dsn_part;
1528                                                        }
1529                                                     }
1530                                                  
1531          86                                662      foreach my $key ( keys %$opts ) {
1532        1018                               2537         MKDEBUG && _d('Finding value for', $key);
1533        1018                               4197         $final_props{$key} = $given_props{$key};
1534        1018    100    100                11237         if (   !defined $final_props{$key}
      ***                   66                        
1535                                                             && defined $prev->{$key} && $opts->{$key}->{copy} )
1536                                                        {
1537          38                                177            $final_props{$key} = $prev->{$key};
1538          38                                118            MKDEBUG && _d('Copying value for', $key, 'from previous DSN');
1539                                                        }
1540        1018    100                        5088         if ( !defined $final_props{$key} ) {
1541         729                               2826            $final_props{$key} = $defaults->{$key};
1542         729                               2495            MKDEBUG && _d('Copying value for', $key, 'from defaults');
1543                                                        }
1544                                                     }
1545                                                  
1546          86                                591      foreach my $key ( keys %given_props ) {
1547  ***    251     50                        1421         die "Unknown DSN option '$key' in '$dsn'.  For more details, "
1548                                                              . "please use the --help option, or try 'perldoc $PROGRAM_NAME' "
1549                                                              . "for complete documentation."
1550                                                           unless exists $opts->{$key};
1551                                                     }
1552  ***     86     50                         603      if ( (my $required = $self->prop('required')) ) {
1553  ***      0                                  0         foreach my $key ( keys %$required ) {
1554  ***      0      0                           0            die "Missing required DSN option '$key' in '$dsn'.  For more details, "
1555                                                                 . "please use the --help option, or try 'perldoc $PROGRAM_NAME' "
1556                                                                 . "for complete documentation."
1557                                                              unless $final_props{$key};
1558                                                        }
1559                                                     }
1560                                                  
1561          86                                710      return \%final_props;
1562                                                  }
1563                                                  
1564                                                  sub parse_options {
1565          61                   61           300      my ( $self, $o ) = @_;
1566  ***     61     50                         427      die 'I need an OptionParser object' unless ref $o eq 'OptionParser';
1567  ***      0                                  0      my $dsn_string
1568                                                        = join(',',
1569         793    100                        3499             map  { "$_=".$o->get($_); }
1570          61                                615             grep { $o->has($_) && $o->get($_) }
1571          61                                245             keys %{$self->{opts}}
1572                                                          );
1573          61                                337      MKDEBUG && _d('DSN string made from options:', $dsn_string);
1574          61                                439      return $self->parse($dsn_string);
1575                                                  }
1576                                                  
1577                                                  sub as_string {
1578           9                    9            64      my ( $self, $dsn, $props ) = @_;
1579  ***      9     50                          84      return $dsn unless ref $dsn;
1580  ***      9     50                          68      my %allowed = $props ? map { $_=>1 } @$props : ();
      ***      0                                  0   
1581  ***     27     50                         308      return join(',',
1582         153    100                        1551         map  { "$_=" . ($_ eq 'p' ? '...' : $dsn->{$_})  }
1583  ***    153     50                         970         grep { defined $dsn->{$_} && $self->{opts}->{$_} }
1584           9                                277         grep { !$props || $allowed{$_}                   }
1585                                                        sort keys %$dsn );
1586                                                  }
1587                                                  
1588                                                  sub usage {
1589  ***      0                    0             0      my ( $self ) = @_;
1590  ***      0                                  0      my $usage
1591                                                        = "DSN syntax is key=value[,key=value...]  Allowable DSN keys:\n\n"
1592                                                        . "  KEY  COPY  MEANING\n"
1593                                                        . "  ===  ====  =============================================\n";
1594  ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
1595  ***      0                                  0      foreach my $key ( sort keys %opts ) {
1596  ***      0      0      0                    0         $usage .= "  $key    "
1597                                                               .  ($opts{$key}->{copy} ? 'yes   ' : 'no    ')
1598                                                               .  ($opts{$key}->{desc} || '[No description]')
1599                                                               . "\n";
1600                                                     }
1601  ***      0                                  0      $usage .= "\n  If the DSN is a bareword, the word is treated as the 'h' key.\n";
1602  ***      0                                  0      return $usage;
1603                                                  }
1604                                                  
1605                                                  sub get_cxn_params {
1606          86                   86           713      my ( $self, $info ) = @_;
1607          86                                304      my $dsn;
1608          86                                286      my %opts = %{$self->{opts}};
              86                               1462   
1609  ***     86            50                  669      my $driver = $self->prop('dbidriver') || '';
1610  ***     86     50                         479      if ( $driver eq 'Pg' ) {
1611  ***      0                                  0         $dsn = 'DBI:Pg:dbname=' . ( $info->{D} || '' ) . ';'
1612  ***      0                                  0            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
1613  ***      0             0                    0                        grep { defined $info->{$_} }
1614                                                                       qw(h P));
1615                                                     }
1616                                                     else {
1617         113                               1074         $dsn = 'DBI:mysql:' . ( $info->{D} || '' ) . ';'
1618         430                               1972            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
1619          86           100                  998                        grep { defined $info->{$_} }
1620                                                                       qw(F h P S A))
1621                                                           . ';mysql_read_default_group=client';
1622                                                     }
1623          86                                316      MKDEBUG && _d($dsn);
1624          86                               1126      return ($dsn, $info->{u}, $info->{p});
1625                                                  }
1626                                                  
1627                                                  sub fill_in_dsn {
1628  ***      0                    0             0      my ( $self, $dbh, $dsn ) = @_;
1629  ***      0                                  0      my $vars = $dbh->selectall_hashref('SHOW VARIABLES', 'Variable_name');
1630  ***      0                                  0      my ($user, $db) = $dbh->selectrow_array('SELECT USER(), DATABASE()');
1631  ***      0                                  0      $user =~ s/@.*//;
1632  ***      0             0                    0      $dsn->{h} ||= $vars->{hostname}->{Value};
1633  ***      0             0                    0      $dsn->{S} ||= $vars->{'socket'}->{Value};
1634  ***      0             0                    0      $dsn->{P} ||= $vars->{port}->{Value};
1635  ***      0             0                    0      $dsn->{u} ||= $user;
1636  ***      0             0                    0      $dsn->{D} ||= $db;
1637                                                  }
1638                                                  
1639                                                  sub get_dbh {
1640          86                   86           597      my ( $self, $cxn_string, $user, $pass, $opts ) = @_;
1641  ***     86            50                  488      $opts ||= {};
1642  ***     86     50                        1100      my $defaults = {
1643                                                        AutoCommit         => 0,
1644                                                        RaiseError         => 1,
1645                                                        PrintError         => 0,
1646                                                        ShowErrorStatement => 1,
1647                                                        mysql_enable_utf8 => ($cxn_string =~ m/charset=utf8/ ? 1 : 0),
1648                                                     };
1649          86                                528      @{$defaults}{ keys %$opts } = values %$opts;
              86                                475   
1650                                                  
1651  ***     86     50                         531      if ( $opts->{mysql_use_result} ) {
1652  ***      0                                  0         $defaults->{mysql_use_result} = 1;
1653                                                     }
1654                                                  
1655  ***     86     50                         451      if ( !$have_dbi ) {
1656  ***      0                                  0         die "Cannot connect to MySQL because the Perl DBI module is not "
1657                                                           . "installed or not found.  Run 'perl -MDBI' to see the directories "
1658                                                           . "that Perl searches for DBI.  If DBI is not installed, try:\n"
1659                                                           . "  Debian/Ubuntu  apt-get install libdbi-perl\n"
1660                                                           . "  RHEL/CentOS    yum install perl-DBI\n"
1661                                                           . "  OpenSolaris    pgk install pkg:/SUNWpmdbi\n";
1662                                                  
1663                                                     }
1664                                                  
1665          86                                284      my $dbh;
1666          86                                282      my $tries = 2;
1667  ***     86            66                 1157      while ( !$dbh && $tries-- ) {
1668                                                        MKDEBUG && _d($cxn_string, ' ', $user, ' ', $pass, ' {',
1669          86                                244            join(', ', map { "$_=>$defaults->{$_}" } keys %$defaults ), '}');
1670                                                  
1671          86                                305         eval {
1672          86                               1063            $dbh = DBI->connect($cxn_string, $user, $pass, $defaults);
1673                                                  
1674  ***     86     50                         924            if ( $cxn_string =~ m/mysql/i ) {
1675          86                                294               my $sql;
1676                                                  
1677          86                                382               $sql = 'SELECT @@SQL_MODE';
1678          86                                245               MKDEBUG && _d($dbh, $sql);
1679          86                                242               my ($sql_mode) = $dbh->selectrow_array($sql);
1680                                                  
1681  ***     86     50                       15180               $sql = 'SET @@SQL_QUOTE_SHOW_CREATE = 1'
1682                                                                   . '/*!40101, @@SQL_MODE=\'NO_AUTO_VALUE_ON_ZERO'
1683                                                                   . ($sql_mode ? ",$sql_mode" : '')
1684                                                                   . '\'*/';
1685          86                                273               MKDEBUG && _d($dbh, $sql);
1686          86                               8364               $dbh->do($sql);
1687                                                  
1688  ***     86     50                         915               if ( my ($charset) = $cxn_string =~ m/charset=(\w+)/ ) {
1689  ***      0                                  0                  $sql = "/*!40101 SET NAMES $charset*/";
1690  ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
1691  ***      0                                  0                  $dbh->do($sql);
1692  ***      0                                  0                  MKDEBUG && _d('Enabling charset for STDOUT');
1693  ***      0      0                           0                  if ( $charset eq 'utf8' ) {
1694  ***      0      0                           0                     binmode(STDOUT, ':utf8')
1695                                                                       or die "Can't binmode(STDOUT, ':utf8'): $OS_ERROR";
1696                                                                 }
1697                                                                 else {
1698  ***      0      0                           0                     binmode(STDOUT) or die "Can't binmode(STDOUT): $OS_ERROR";
1699                                                                 }
1700                                                              }
1701                                                  
1702          86    100                         603               if ( $self->prop('set-vars') ) {
1703          61                                354                  $sql = "SET " . $self->prop('set-vars');
1704          61                                189                  MKDEBUG && _d($dbh, ':', $sql);
1705          61                               4118                  $dbh->do($sql);
1706                                                              }
1707                                                           }
1708                                                        };
1709  ***     86     50     33                 1081         if ( !$dbh && $EVAL_ERROR ) {
1710  ***      0                                  0            MKDEBUG && _d($EVAL_ERROR);
1711  ***      0      0                           0            if ( $EVAL_ERROR =~ m/not a compiled character set|character set utf8/ ) {
      ***             0                               
1712  ***      0                                  0               MKDEBUG && _d('Going to try again without utf8 support');
1713  ***      0                                  0               delete $defaults->{mysql_enable_utf8};
1714                                                           }
1715                                                           elsif ( $EVAL_ERROR =~ m/locate DBD\/mysql/i ) {
1716  ***      0                                  0               die "Cannot connect to MySQL because the Perl DBD::mysql module is "
1717                                                                 . "not installed or not found.  Run 'perl -MDBD::mysql' to see "
1718                                                                 . "the directories that Perl searches for DBD::mysql.  If "
1719                                                                 . "DBD::mysql is not installed, try:\n"
1720                                                                 . "  Debian/Ubuntu  apt-get install libdbd-mysql-perl\n"
1721                                                                 . "  RHEL/CentOS    yum install perl-DBD-MySQL\n"
1722                                                                 . "  OpenSolaris    pgk install pkg:/SUNWapu13dbd-mysql\n";
1723                                                           }
1724  ***      0      0                           0            if ( !$tries ) {
1725  ***      0                                  0               die $EVAL_ERROR;
1726                                                           }
1727                                                        }
1728                                                     }
1729                                                  
1730          86                                250      MKDEBUG && _d('DBH info: ',
1731                                                        $dbh,
1732                                                        Dumper($dbh->selectrow_hashref(
1733                                                           'SELECT DATABASE(), CONNECTION_ID(), VERSION()/*!50038 , @@hostname*/')),
1734                                                        'Connection info:',      $dbh->{mysql_hostinfo},
1735                                                        'Character set info:',   Dumper($dbh->selectall_arrayref(
1736                                                                       'SHOW VARIABLES LIKE "character_set%"', { Slice => {}})),
1737                                                        '$DBD::mysql::VERSION:', $DBD::mysql::VERSION,
1738                                                        '$DBI::VERSION:',        $DBI::VERSION,
1739                                                     );
1740                                                  
1741          86                                579      return $dbh;
1742                                                  }
1743                                                  
1744                                                  sub get_hostname {
1745  ***      0                    0             0      my ( $self, $dbh ) = @_;
1746  ***      0      0      0                    0      if ( my ($host) = ($dbh->{mysql_hostinfo} || '') =~ m/^(\w+) via/ ) {
1747  ***      0                                  0         return $host;
1748                                                     }
1749  ***      0                                  0      my ( $hostname, $one ) = $dbh->selectrow_array(
1750                                                        'SELECT /*!50038 @@hostname, */ 1');
1751  ***      0                                  0      return $hostname;
1752                                                  }
1753                                                  
1754                                                  sub disconnect {
1755  ***      0                    0             0      my ( $self, $dbh ) = @_;
1756  ***      0                                  0      MKDEBUG && $self->print_active_handles($dbh);
1757  ***      0                                  0      $dbh->disconnect;
1758                                                  }
1759                                                  
1760                                                  sub print_active_handles {
1761  ***      0                    0             0      my ( $self, $thing, $level ) = @_;
1762  ***      0             0                    0      $level ||= 0;
1763  ***      0      0      0                    0      printf("# Active %sh: %s %s %s\n", ($thing->{Type} || 'undef'), "\t" x $level,
      ***             0      0                        
      ***                    0                        
1764                                                        $thing, (($thing->{Type} || '') eq 'st' ? $thing->{Statement} || '' : ''))
1765                                                        or die "Cannot print: $OS_ERROR";
1766  ***      0                                  0      foreach my $handle ( grep {defined} @{ $thing->{ChildHandles} } ) {
      ***      0                                  0   
      ***      0                                  0   
1767  ***      0                                  0         $self->print_active_handles( $handle, $level + 1 );
1768                                                     }
1769                                                  }
1770                                                  
1771                                                  sub copy {
1772  ***      0                    0             0      my ( $self, $dsn_1, $dsn_2, %args ) = @_;
1773  ***      0      0                           0      die 'I need a dsn_1 argument' unless $dsn_1;
1774  ***      0      0                           0      die 'I need a dsn_2 argument' unless $dsn_2;
1775  ***      0                                  0      my %new_dsn = map {
1776  ***      0                                  0         my $key = $_;
1777  ***      0                                  0         my $val;
1778  ***      0      0                           0         if ( $args{overwrite} ) {
1779  ***      0      0                           0            $val = defined $dsn_1->{$key} ? $dsn_1->{$key} : $dsn_2->{$key};
1780                                                        }
1781                                                        else {
1782  ***      0      0                           0            $val = defined $dsn_2->{$key} ? $dsn_2->{$key} : $dsn_1->{$key};
1783                                                        }
1784  ***      0                                  0         $key => $val;
1785  ***      0                                  0      } keys %{$self->{opts}};
1786  ***      0                                  0      return \%new_dsn;
1787                                                  }
1788                                                  
1789                                                  sub _d {
1790  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1791  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1792  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1793                                                          @_;
1794  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1795                                                  }
1796                                                  
1797                                                  1;
1798                                                  
1799                                                  # ###########################################################################
1800                                                  # End DSNParser package
1801                                                  # ###########################################################################
1802                                                  
1803                                                  # ###########################################################################
1804                                                  # VersionParser package 6667
1805                                                  # This package is a copy without comments from the original.  The original
1806                                                  # with comments and its test file can be found in the SVN repository at,
1807                                                  #   trunk/common/VersionParser.pm
1808                                                  #   trunk/common/t/VersionParser.t
1809                                                  # See http://code.google.com/p/maatkit/wiki/Developers for more information.
1810                                                  # ###########################################################################
1811                                                  package VersionParser;
1812                                                  
1813          21                   21           180   use strict;
              21                                803   
              21                               2330   
1814          21                   21          1368   use warnings FATAL => 'all';
              21                                542   
              21                                353   
1815                                                  
1816          21                   21           361   use English qw(-no_match_vars);
              21                                 48   
              21                                113   
1817                                                  
1818  ***     21            50     21           129   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              21                                 55   
              21                                297   
1819                                                  
1820                                                  sub new {
1821          21                   21            99      my ( $class ) = @_;
1822          21                                281      bless {}, $class;
1823                                                  }
1824                                                  
1825                                                  sub parse {
1826         158                  158          6734      my ( $self, $str ) = @_;
1827         158                               2305      my $result = sprintf('%03d%03d%03d', $str =~ m/(\d+)/g);
1828         158                                502      MKDEBUG && _d($str, 'parses to', $result);
1829         158                               1260      return $result;
1830                                                  }
1831                                                  
1832                                                  sub version_ge {
1833          97                   97           614      my ( $self, $dbh, $target ) = @_;
1834          97    100                         794      if ( !$self->{$dbh} ) {
1835          61                                166         $self->{$dbh} = $self->parse(
1836                                                           $dbh->selectrow_array('SELECT VERSION()'));
1837                                                     }
1838  ***     97     50                        1597      my $result = $self->{$dbh} ge $self->parse($target) ? 1 : 0;
1839          97                                273      MKDEBUG && _d($self->{$dbh}, 'ge', $target, ':', $result);
1840          97                                832      return $result;
1841                                                  }
1842                                                  
1843                                                  sub innodb_version {
1844  ***      0                    0             0      my ( $self, $dbh ) = @_;
1845  ***      0      0                           0      return unless $dbh;
1846  ***      0                                  0      my $innodb_version = "NO";
1847                                                  
1848  ***      0                                  0      my ($innodb) =
1849  ***      0                                  0         grep { $_->{engine} =~ m/InnoDB/i }
1850                                                        map  {
1851  ***      0                                  0            my %hash;
1852  ***      0                                  0            @hash{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                  0   
1853  ***      0                                  0            \%hash;
1854                                                        }
1855  ***      0                                  0         @{ $dbh->selectall_arrayref("SHOW ENGINES", {Slice=>{}}) };
1856  ***      0      0                           0      if ( $innodb ) {
1857  ***      0                                  0         MKDEBUG && _d("InnoDB support:", $innodb->{support});
1858  ***      0      0                           0         if ( $innodb->{support} =~ m/YES|DEFAULT/i ) {
1859  ***      0                                  0            my $vars = $dbh->selectrow_hashref(
1860                                                              "SHOW VARIABLES LIKE 'innodb_version'");
1861  ***      0      0      0                    0            $innodb_version = !$vars ? "BUILTIN"
1862                                                                           :          ($vars->{Value} || $vars->{value});
1863                                                        }
1864                                                        else {
1865  ***      0                                  0            $innodb_version = $innodb->{support};  # probably DISABLED or NO
1866                                                        }
1867                                                     }
1868                                                  
1869  ***      0                                  0      MKDEBUG && _d("InnoDB version:", $innodb_version);
1870  ***      0                                  0      return $innodb_version;
1871                                                  }
1872                                                  
1873                                                  sub _d {
1874  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1875  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1876  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1877                                                          @_;
1878  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1879                                                  }
1880                                                  
1881                                                  1;
1882                                                  
1883                                                  # ###########################################################################
1884                                                  # End VersionParser package
1885                                                  # ###########################################################################
1886                                                  
1887                                                  # ###########################################################################
1888                                                  # Quoter package 6850
1889                                                  # This package is a copy without comments from the original.  The original
1890                                                  # with comments and its test file can be found in the SVN repository at,
1891                                                  #   trunk/common/Quoter.pm
1892                                                  #   trunk/common/t/Quoter.t
1893                                                  # See http://code.google.com/p/maatkit/wiki/Developers for more information.
1894                                                  # ###########################################################################
1895                                                  
1896                                                  package Quoter;
1897                                                  
1898          21                   21           151   use strict;
              21                                 54   
              21                                112   
1899          21                   21           131   use warnings FATAL => 'all';
              21                                 48   
              21                                103   
1900          21                   21           123   use English qw(-no_match_vars);
              21                                 45   
              21                                109   
1901                                                  
1902  ***     21            50     21           172   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              21                                 48   
              21                                274   
1903                                                  
1904                                                  sub new {
1905          21                   21           105      my ( $class, %args ) = @_;
1906          21                                257      return bless {}, $class;
1907                                                  }
1908                                                  
1909                                                  sub quote {
1910         721                  721          3806      my ( $self, @vals ) = @_;
1911         721                               3090      foreach my $val ( @vals ) {
1912         843                               4024         $val =~ s/`/``/g;
1913                                                     }
1914         721                               3030      return join('.', map { '`' . $_ . '`' } @vals);
             843                               6403   
1915                                                  }
1916                                                  
1917                                                  sub quote_val {
1918           6                    6            34      my ( $self, $val ) = @_;
1919                                                  
1920  ***      6     50                          36      return 'NULL' unless defined $val;          # undef = NULL
1921  ***      6     50                          33      return "''" if $val eq '';                  # blank string = ''
1922  ***      6     50                          39      return $val if $val =~ m/^0x[0-9a-fA-F]+$/;  # hex data
1923                                                  
1924           6                                 30      $val =~ s/(['\\])/\\$1/g;
1925           6                                 46      return "'$val'";
1926                                                  }
1927                                                  
1928                                                  sub split_unquote {
1929          61                   61           343      my ( $self, $db_tbl, $default_db ) = @_;
1930          61                                510      $db_tbl =~ s/`//g;
1931          61                                472      my ( $db, $tbl ) = split(/[.]/, $db_tbl);
1932  ***     61     50                         340      if ( !$tbl ) {
1933          61                                202         $tbl = $db;
1934          61                                214         $db  = $default_db;
1935                                                     }
1936          61                                355      return ($db, $tbl);
1937                                                  }
1938                                                  
1939                                                  sub literal_like {
1940  ***      0                    0             0      my ( $self, $like ) = @_;
1941  ***      0      0                           0      return unless $like;
1942  ***      0                                  0      $like =~ s/([%_])/\\$1/g;
1943  ***      0                                  0      return "'$like'";
1944                                                  }
1945                                                  
1946                                                  sub join_quote {
1947  ***      0                    0             0      my ( $self, $default_db, $db_tbl ) = @_;
1948  ***      0      0                           0      return unless $db_tbl;
1949  ***      0                                  0      my ($db, $tbl) = split(/[.]/, $db_tbl);
1950  ***      0      0                           0      if ( !$tbl ) {
1951  ***      0                                  0         $tbl = $db;
1952  ***      0                                  0         $db  = $default_db;
1953                                                     }
1954  ***      0      0      0                    0      $db  = "`$db`"  if $db  && $db  !~ m/^`/;
1955  ***      0      0      0                    0      $tbl = "`$tbl`" if $tbl && $tbl !~ m/^`/;
1956  ***      0      0                           0      return $db ? "$db.$tbl" : $tbl;
1957                                                  }
1958                                                  
1959                                                  1;
1960                                                  
1961                                                  # ###########################################################################
1962                                                  # End Quoter package
1963                                                  # ###########################################################################
1964                                                  
1965                                                  # ###########################################################################
1966                                                  # TableNibbler package 5266
1967                                                  # This package is a copy without comments from the original.  The original
1968                                                  # with comments and its test file can be found in the SVN repository at,
1969                                                  #   trunk/common/TableNibbler.pm
1970                                                  #   trunk/common/t/TableNibbler.t
1971                                                  # See http://code.google.com/p/maatkit/wiki/Developers for more information.
1972                                                  # ###########################################################################
1973                                                  package TableNibbler;
1974                                                  
1975          21                   21           150   use strict;
              21                                 58   
              21                                105   
1976          21                   21           119   use warnings FATAL => 'all';
              21                                 47   
              21                                106   
1977                                                  
1978          21                   21           120   use English qw(-no_match_vars);
              21                                 62   
              21                                106   
1979                                                  
1980  ***     21            50     21           138   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              21                                 49   
              21                                280   
1981                                                  
1982                                                  sub new {
1983          39                   39           367      my ( $class, %args ) = @_;
1984          39                                239      my @required_args = qw(TableParser Quoter);
1985          39                                239      foreach my $arg ( @required_args ) {
1986  ***     78     50                         509         die "I need a $arg argument" unless $args{$arg};
1987                                                     }
1988          39                                271      my $self = { %args };
1989          39                                526      return bless $self, $class;
1990                                                  }
1991                                                  
1992                                                  sub generate_asc_stmt {
1993          41                   41           438      my ( $self, %args ) = @_;
1994          41                                315      my @required_args = qw(tbl_struct index);
1995          41                                245      foreach my $arg ( @required_args ) {
1996  ***     82     50                         553         die "I need a $arg argument" unless defined $args{$arg};
1997                                                     }
1998          41                                242      my ($tbl_struct, $index) = @args{@required_args};
1999  ***     41     50                         233      my @cols = $args{cols}  ? @{$args{cols}} : @{$tbl_struct->{cols}};
              41                                288   
      ***      0                                  0   
2000          41                                188      my $q    = $self->{Quoter};
2001                                                  
2002  ***     41     50                         268      die "Index '$index' does not exist in table"
2003                                                        unless exists $tbl_struct->{keys}->{$index};
2004                                                  
2005          41                                131      my @asc_cols = @{$tbl_struct->{keys}->{$index}->{cols}};
              41                                302   
2006          41                                143      my @asc_slice;
2007                                                  
2008          41                                136      @asc_cols = @{$tbl_struct->{keys}->{$index}->{cols}};
              41                                285   
2009          41                                116      MKDEBUG && _d('Will ascend index', $index);
2010          41                                123      MKDEBUG && _d('Will ascend columns', join(', ', @asc_cols));
2011  ***     41     50                         247      if ( $args{asc_first} ) {
2012  ***      0                                  0         @asc_cols = $asc_cols[0];
2013  ***      0                                  0         MKDEBUG && _d('Ascending only first column');
2014                                                     }
2015                                                  
2016          41                                137      my %col_posn = do { my $i = 0; map { $_ => $i++ } @cols };
              41                                149   
              41                                163   
             154                                860   
2017          41                                247      foreach my $col ( @asc_cols ) {
2018  ***     50     50                         277         if ( !exists $col_posn{$col} ) {
2019  ***      0                                  0            push @cols, $col;
2020  ***      0                                  0            $col_posn{$col} = $#cols;
2021                                                        }
2022          50                                274         push @asc_slice, $col_posn{$col};
2023                                                     }
2024          41                                127      MKDEBUG && _d('Will ascend, in ordinal position:', join(', ', @asc_slice));
2025                                                  
2026          41                                425      my $asc_stmt = {
2027                                                        cols  => \@cols,
2028                                                        index => $index,
2029                                                        where => '',
2030                                                        slice => [],
2031                                                        scols => [],
2032                                                     };
2033                                                  
2034  ***     41     50                         231      if ( @asc_slice ) {
2035          41                                112         my $cmp_where;
2036          41                                209         foreach my $cmp ( qw(< <= >= >) ) {
2037         164                               1380            $cmp_where = $self->generate_cmp_where(
2038                                                              type        => $cmp,
2039                                                              slice       => \@asc_slice,
2040                                                              cols        => \@cols,
2041                                                              quoter      => $q,
2042                                                              is_nullable => $tbl_struct->{is_nullable},
2043                                                           );
2044         164                               1675            $asc_stmt->{boundaries}->{$cmp} = $cmp_where->{where};
2045                                                        }
2046          41    100                         249         my $cmp = $args{asc_only} ? '>' : '>=';
2047          41                                247         $asc_stmt->{where} = $asc_stmt->{boundaries}->{$cmp};
2048          41                                206         $asc_stmt->{slice} = $cmp_where->{slice};
2049          41                                265         $asc_stmt->{scols} = $cmp_where->{scols};
2050                                                     }
2051                                                  
2052          41                                307      return $asc_stmt;
2053                                                  }
2054                                                  
2055                                                  sub generate_cmp_where {
2056         164                  164          1403      my ( $self, %args ) = @_;
2057         164                                917      foreach my $arg ( qw(type slice cols is_nullable) ) {
2058  ***    656     50                        3670         die "I need a $arg arg" unless defined $args{$arg};
2059                                                     }
2060         164                                540      my @slice       = @{$args{slice}};
             164                                838   
2061         164                                509      my @cols        = @{$args{cols}};
             164                               1010   
2062         164                                689      my $is_nullable = $args{is_nullable};
2063         164                                600      my $type        = $args{type};
2064         164                                639      my $q           = $self->{Quoter};
2065                                                  
2066         164                                859      (my $cmp = $type) =~ s/=//;
2067                                                  
2068         164                                452      my @r_slice;    # Resulting slice columns, by ordinal
2069         164                                449      my @r_scols;    # Ditto, by name
2070                                                  
2071         164                                429      my @clauses;
2072         164                               1012      foreach my $i ( 0 .. $#slice ) {
2073         200                                557         my @clause;
2074                                                  
2075         200                               1098         foreach my $j ( 0 .. $i - 1 ) {
2076          72                                268            my $ord = $slice[$j];
2077          72                                245            my $col = $cols[$ord];
2078          72                                304            my $quo = $q->quote($col);
2079  ***     72     50                         334            if ( $is_nullable->{$col} ) {
2080  ***      0                                  0               push @clause, "((? IS NULL AND $quo IS NULL) OR ($quo = ?))";
2081  ***      0                                  0               push @r_slice, $ord, $ord;
2082  ***      0                                  0               push @r_scols, $col, $col;
2083                                                           }
2084                                                           else {
2085          72                                284               push @clause, "$quo = ?";
2086          72                                243               push @r_slice, $ord;
2087          72                                329               push @r_scols, $col;
2088                                                           }
2089                                                        }
2090                                                  
2091         200                                771         my $ord = $slice[$i];
2092         200                                711         my $col = $cols[$ord];
2093         200                                887         my $quo = $q->quote($col);
2094         200                                910         my $end = $i == $#slice; # Last clause of the whole group.
2095  ***    200     50                         993         if ( $is_nullable->{$col} ) {
2096  ***      0      0      0                    0            if ( $type =~ m/=/ && $end ) {
      ***             0                               
2097  ***      0                                  0               push @clause, "(? IS NULL OR $quo $type ?)";
2098                                                           }
2099                                                           elsif ( $type =~ m/>/ ) {
2100  ***      0                                  0               push @clause, "((? IS NULL AND $quo IS NOT NULL) OR ($quo $cmp ?))";
2101                                                           }
2102                                                           else { # If $type =~ m/</ ) {
2103  ***      0                                  0               push @clause, "((? IS NOT NULL AND $quo IS NULL) OR ($quo $cmp ?))";
2104                                                           }
2105  ***      0                                  0            push @r_slice, $ord, $ord;
2106  ***      0                                  0            push @r_scols, $col, $col;
2107                                                        }
2108                                                        else {
2109         200                                765            push @r_slice, $ord;
2110         200                                698            push @r_scols, $col;
2111         200    100    100                 2326            push @clause, ($type =~ m/=/ && $end ? "$quo $type ?" : "$quo $cmp ?");
2112                                                        }
2113                                                  
2114         200                               1394         push @clauses, '(' . join(' AND ', @clause) . ')';
2115                                                     }
2116         164                                859      my $result = '(' . join(' OR ', @clauses) . ')';
2117         164                               1189      my $where = {
2118                                                        slice => \@r_slice,
2119                                                        scols => \@r_scols,
2120                                                        where => $result,
2121                                                     };
2122         164                               1171      return $where;
2123                                                  }
2124                                                  
2125                                                  sub generate_del_stmt {
2126          39                   39           455      my ( $self, %args ) = @_;
2127                                                  
2128          39                                205      my $tbl  = $args{tbl_struct};
2129  ***     39     50                         218      my @cols = $args{cols} ? @{$args{cols}} : ();
              39                                293   
2130          39                                183      my $tp   = $self->{TableParser};
2131          39                                153      my $q    = $self->{Quoter};
2132                                                  
2133          39                                116      my @del_cols;
2134          39                                121      my @del_slice;
2135                                                  
2136          39                                359      my $index = $tp->find_best_index($tbl, $args{index});
2137  ***     39     50                         217      die "Cannot find an ascendable index in table" unless $index;
2138                                                  
2139  ***     39     50                         184      if ( $index ) {
2140          39                                133         @del_cols = @{$tbl->{keys}->{$index}->{cols}};
              39                                335   
2141                                                     }
2142                                                     else {
2143  ***      0                                  0         @del_cols = @{$tbl->{cols}};
      ***      0                                  0   
2144                                                     }
2145          39                                121      MKDEBUG && _d('Columns needed for DELETE:', join(', ', @del_cols));
2146                                                  
2147          39                                133      my %col_posn = do { my $i = 0; map { $_ => $i++ } @cols };
              39                                148   
              39                                159   
             147                                826   
2148          39                                293      foreach my $col ( @del_cols ) {
2149          48    100                         269         if ( !exists $col_posn{$col} ) {
2150           2                                 12            push @cols, $col;
2151           2                                 19            $col_posn{$col} = $#cols;
2152                                                        }
2153          48                                274         push @del_slice, $col_posn{$col};
2154                                                     }
2155          39                                119      MKDEBUG && _d('Ordinals needed for DELETE:', join(', ', @del_slice));
2156                                                  
2157          39                                474      my $del_stmt = {
2158                                                        cols  => \@cols,
2159                                                        index => $index,
2160                                                        where => '',
2161                                                        slice => [],
2162                                                        scols => [],
2163                                                     };
2164                                                  
2165          39                                150      my @clauses;
2166          39                                281      foreach my $i ( 0 .. $#del_slice ) {
2167          48                                219         my $ord = $del_slice[$i];
2168          48                                189         my $col = $cols[$ord];
2169          48                                243         my $quo = $q->quote($col);
2170  ***     48     50                         319         if ( $tbl->{is_nullable}->{$col} ) {
2171  ***      0                                  0            push @clauses, "((? IS NULL AND $quo IS NULL) OR ($quo = ?))";
2172  ***      0                                  0            push @{$del_stmt->{slice}}, $ord, $ord;
      ***      0                                  0   
2173  ***      0                                  0            push @{$del_stmt->{scols}}, $col, $col;
      ***      0                                  0   
2174                                                        }
2175                                                        else {
2176          48                                249            push @clauses, "$quo = ?";
2177          48                                151            push @{$del_stmt->{slice}}, $ord;
              48                                255   
2178          48                                165            push @{$del_stmt->{scols}}, $col;
              48                                309   
2179                                                        }
2180                                                     }
2181                                                  
2182          39                                289      $del_stmt->{where} = '(' . join(' AND ', @clauses) . ')';
2183                                                  
2184          39                                300      return $del_stmt;
2185                                                  }
2186                                                  
2187                                                  sub generate_ins_stmt {
2188          17                   17           128      my ( $self, %args ) = @_;
2189          17                                117      foreach my $arg ( qw(ins_tbl sel_cols) ) {
2190  ***     34     50                         213         die "I need a $arg argument" unless $args{$arg};
2191                                                     }
2192          17                                 71      my $ins_tbl  = $args{ins_tbl};
2193          17                                 57      my @sel_cols = @{$args{sel_cols}};
              17                                135   
2194                                                  
2195  ***     17     50                          90      die "You didn't specify any SELECT columns" unless @sel_cols;
2196                                                  
2197          17                                 62      my @ins_cols;
2198          17                                 50      my @ins_slice;
2199          17                                118      for my $i ( 0..$#sel_cols ) {
2200          69    100                         428         next unless $ins_tbl->{is_col}->{$sel_cols[$i]};
2201          63                                242         push @ins_cols, $sel_cols[$i];
2202          63                                250         push @ins_slice, $i;
2203                                                     }
2204                                                  
2205                                                     return {
2206          17                                176         cols  => \@ins_cols,
2207                                                        slice => \@ins_slice,
2208                                                     };
2209                                                  }
2210                                                  
2211                                                  sub _d {
2212  ***      0                    0             0      my ($package, undef, $line) = caller 0;
2213  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
2214  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
2215                                                          @_;
2216  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2217                                                  }
2218                                                  
2219                                                  1;
2220                                                  
2221                                                  # ###########################################################################
2222                                                  # End TableNibbler package
2223                                                  # ###########################################################################
2224                                                  
2225                                                  # ###########################################################################
2226                                                  # MySQLDump package 6345
2227                                                  # This package is a copy without comments from the original.  The original
2228                                                  # with comments and its test file can be found in the SVN repository at,
2229                                                  #   trunk/common/MySQLDump.pm
2230                                                  #   trunk/common/t/MySQLDump.t
2231                                                  # See http://code.google.com/p/maatkit/wiki/Developers for more information.
2232                                                  # ###########################################################################
2233                                                  package MySQLDump;
2234                                                  
2235          21                   21           158   use strict;
              21                                 56   
              21                                114   
2236          21                   21           129   use warnings FATAL => 'all';
              21                                 47   
              21                                125   
2237                                                  
2238          21                   21           127   use English qw(-no_match_vars);
              21                                 48   
              21                                109   
2239                                                  
2240  ***     21            50     21           140   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              21                                 54   
              21                                297   
2241                                                  
2242                                                  ( our $before = <<'EOF') =~ s/^   //gm;
2243                                                     /*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
2244                                                     /*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
2245                                                     /*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
2246                                                     /*!40101 SET NAMES utf8 */;
2247                                                     /*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
2248                                                     /*!40103 SET TIME_ZONE='+00:00' */;
2249                                                     /*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
2250                                                     /*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
2251                                                     /*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
2252                                                     /*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
2253                                                  EOF
2254                                                  
2255                                                  ( our $after = <<'EOF') =~ s/^   //gm;
2256                                                     /*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;
2257                                                     /*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
2258                                                     /*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
2259                                                     /*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
2260                                                     /*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
2261                                                     /*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
2262                                                     /*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
2263                                                     /*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
2264                                                  EOF
2265                                                  
2266                                                  sub new {
2267          42                   42           324      my ( $class, %args ) = @_;
2268          42                                241      my $self = {
2269                                                        cache => 0,  # Afaik no script uses this cache any longer because
2270                                                     };
2271          42                                412      return bless $self, $class;
2272                                                  }
2273                                                  
2274                                                  sub dump {
2275  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl, $what ) = @_;
2276                                                  
2277  ***      0      0                           0      if ( $what eq 'table' ) {
      ***             0                               
      ***             0                               
2278  ***      0                                  0         my $ddl = $self->get_create_table($dbh, $quoter, $db, $tbl);
2279  ***      0      0                           0         return unless $ddl;
2280  ***      0      0                           0         if ( $ddl->[0] eq 'table' ) {
2281  ***      0                                  0            return $before
2282                                                              . 'DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . ";\n"
2283                                                              . $ddl->[1] . ";\n";
2284                                                        }
2285                                                        else {
2286  ***      0                                  0            return 'DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . ";\n"
2287                                                              . '/*!50001 DROP VIEW IF EXISTS '
2288                                                              . $quoter->quote($tbl) . "*/;\n/*!50001 "
2289                                                              . $self->get_tmp_table($dbh, $quoter, $db, $tbl) . "*/;\n";
2290                                                        }
2291                                                     }
2292                                                     elsif ( $what eq 'triggers' ) {
2293  ***      0                                  0         my $trgs = $self->get_triggers($dbh, $quoter, $db, $tbl);
2294  ***      0      0      0                    0         if ( $trgs && @$trgs ) {
2295  ***      0                                  0            my $result = $before . "\nDELIMITER ;;\n";
2296  ***      0                                  0            foreach my $trg ( @$trgs ) {
2297  ***      0      0                           0               if ( $trg->{sql_mode} ) {
2298  ***      0                                  0                  $result .= qq{/*!50003 SET SESSION SQL_MODE='$trg->{sql_mode}' */;;\n};
2299                                                              }
2300  ***      0                                  0               $result .= "/*!50003 CREATE */ ";
2301  ***      0      0                           0               if ( $trg->{definer} ) {
2302  ***      0                                  0                  my ( $user, $host )
2303  ***      0                                  0                     = map { s/'/''/g; "'$_'"; }
      ***      0                                  0   
2304                                                                      split('@', $trg->{definer}, 2);
2305  ***      0                                  0                  $result .= "/*!50017 DEFINER=$user\@$host */ ";
2306                                                              }
2307  ***      0                                  0               $result .= sprintf("/*!50003 TRIGGER %s %s %s ON %s\nFOR EACH ROW %s */;;\n\n",
2308                                                                 $quoter->quote($trg->{trigger}),
2309  ***      0                                  0                  @{$trg}{qw(timing event)},
2310                                                                 $quoter->quote($trg->{table}),
2311                                                                 $trg->{statement});
2312                                                           }
2313  ***      0                                  0            $result .= "DELIMITER ;\n\n/*!50003 SET SESSION SQL_MODE=\@OLD_SQL_MODE */;\n\n";
2314  ***      0                                  0            return $result;
2315                                                        }
2316                                                        else {
2317  ***      0                                  0            return undef;
2318                                                        }
2319                                                     }
2320                                                     elsif ( $what eq 'view' ) {
2321  ***      0                                  0         my $ddl = $self->get_create_table($dbh, $quoter, $db, $tbl);
2322  ***      0                                  0         return '/*!50001 DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . "*/;\n"
2323                                                           . '/*!50001 DROP VIEW IF EXISTS ' . $quoter->quote($tbl) . "*/;\n"
2324                                                           . '/*!50001 ' . $ddl->[1] . "*/;\n";
2325                                                     }
2326                                                     else {
2327  ***      0                                  0         die "You didn't say what to dump.";
2328                                                     }
2329                                                  }
2330                                                  
2331                                                  sub _use_db {
2332          61                   61           417      my ( $self, $dbh, $quoter, $new ) = @_;
2333  ***     61     50                         368      if ( !$new ) {
2334  ***      0                                  0         MKDEBUG && _d('No new DB to use');
2335  ***      0                                  0         return;
2336                                                     }
2337          61                                311      my $sql = 'USE ' . $quoter->quote($new);
2338          61                                179      MKDEBUG && _d($dbh, $sql);
2339          61                               4630      $dbh->do($sql);
2340          61                                402      return;
2341                                                  }
2342                                                  
2343                                                  sub get_create_table {
2344          61                   61           408      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
2345  ***     61     50     33                  541      if ( !$self->{cache} || !$self->{tables}->{$db}->{$tbl} ) {
2346          61                                252         my $sql = '/*!40101 SET @OLD_SQL_MODE := @@SQL_MODE, '
2347                                                           . q{@@SQL_MODE := REPLACE(REPLACE(@@SQL_MODE, 'ANSI_QUOTES', ''), ',,', ','), }
2348                                                           . '@OLD_QUOTE := @@SQL_QUOTE_SHOW_CREATE, '
2349                                                           . '@@SQL_QUOTE_SHOW_CREATE := 1 */';
2350          61                                160         MKDEBUG && _d($sql);
2351          61                                210         eval { $dbh->do($sql); };
              61                               8811   
2352          61                                232         MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
2353          61                                539         $self->_use_db($dbh, $quoter, $db);
2354          61                                349         $sql = "SHOW CREATE TABLE " . $quoter->quote($db, $tbl);
2355          61                                194         MKDEBUG && _d($sql);
2356          61                                183         my $href;
2357          61                                212         eval { $href = $dbh->selectrow_hashref($sql); };
              61                                183   
2358  ***     61     50                         537         if ( $EVAL_ERROR ) {
2359  ***      0                                  0            warn "Failed to $sql.  The table may be damaged.\nError: $EVAL_ERROR";
2360  ***      0                                  0            return;
2361                                                        }
2362                                                  
2363          61                                234         $sql = '/*!40101 SET @@SQL_MODE := @OLD_SQL_MODE, '
2364                                                           . '@@SQL_QUOTE_SHOW_CREATE := @OLD_QUOTE */';
2365          61                                161         MKDEBUG && _d($sql);
2366          61                               5074         $dbh->do($sql);
2367          61                                500         my ($key) = grep { m/create table/i } keys %$href;
             122                                919   
2368  ***     61     50                         346         if ( $key ) {
2369          61                                172            MKDEBUG && _d('This table is a base table');
2370          61                               1024            $self->{tables}->{$db}->{$tbl} = [ 'table', $href->{$key} ];
2371                                                        }
2372                                                        else {
2373  ***      0                                  0            MKDEBUG && _d('This table is a view');
2374  ***      0                                  0            ($key) = grep { m/create view/i } keys %$href;
      ***      0                                  0   
2375  ***      0                                  0            $self->{tables}->{$db}->{$tbl} = [ 'view', $href->{$key} ];
2376                                                        }
2377                                                     }
2378          61                                811      return $self->{tables}->{$db}->{$tbl};
2379                                                  }
2380                                                  
2381                                                  sub get_columns {
2382  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
2383  ***      0                                  0      MKDEBUG && _d('Get columns for', $db, $tbl);
2384  ***      0      0      0                    0      if ( !$self->{cache} || !$self->{columns}->{$db}->{$tbl} ) {
2385  ***      0                                  0         $self->_use_db($dbh, $quoter, $db);
2386  ***      0                                  0         my $sql = "SHOW COLUMNS FROM " . $quoter->quote($db, $tbl);
2387  ***      0                                  0         MKDEBUG && _d($sql);
2388  ***      0                                  0         my $cols = $dbh->selectall_arrayref($sql, { Slice => {} });
2389                                                  
2390  ***      0                                  0         $self->{columns}->{$db}->{$tbl} = [
2391                                                           map {
2392  ***      0                                  0               my %row;
2393  ***      0                                  0               @row{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                  0   
2394  ***      0                                  0               \%row;
2395                                                           } @$cols
2396                                                        ];
2397                                                     }
2398  ***      0                                  0      return $self->{columns}->{$db}->{$tbl};
2399                                                  }
2400                                                  
2401                                                  sub get_tmp_table {
2402  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
2403  ***      0                                  0      my $result = 'CREATE TABLE ' . $quoter->quote($tbl) . " (\n";
2404  ***      0                                  0      $result .= join(",\n",
2405  ***      0                                  0         map { '  ' . $quoter->quote($_->{field}) . ' ' . $_->{type} }
2406  ***      0                                  0         @{$self->get_columns($dbh, $quoter, $db, $tbl)});
2407  ***      0                                  0      $result .= "\n)";
2408  ***      0                                  0      MKDEBUG && _d($result);
2409  ***      0                                  0      return $result;
2410                                                  }
2411                                                  
2412                                                  sub get_triggers {
2413  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
2414  ***      0      0      0                    0      if ( !$self->{cache} || !$self->{triggers}->{$db} ) {
2415  ***      0                                  0         $self->{triggers}->{$db} = {};
2416  ***      0                                  0         my $sql = '/*!40101 SET @OLD_SQL_MODE := @@SQL_MODE, '
2417                                                           . q{@@SQL_MODE := REPLACE(REPLACE(@@SQL_MODE, 'ANSI_QUOTES', ''), ',,', ','), }
2418                                                           . '@OLD_QUOTE := @@SQL_QUOTE_SHOW_CREATE, '
2419                                                           . '@@SQL_QUOTE_SHOW_CREATE := 1 */';
2420  ***      0                                  0         MKDEBUG && _d($sql);
2421  ***      0                                  0         eval { $dbh->do($sql); };
      ***      0                                  0   
2422  ***      0                                  0         MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
2423  ***      0                                  0         $sql = "SHOW TRIGGERS FROM " . $quoter->quote($db);
2424  ***      0                                  0         MKDEBUG && _d($sql);
2425  ***      0                                  0         my $sth = $dbh->prepare($sql);
2426  ***      0                                  0         $sth->execute();
2427  ***      0      0                           0         if ( $sth->rows ) {
2428  ***      0                                  0            my $trgs = $sth->fetchall_arrayref({});
2429  ***      0                                  0            foreach my $trg (@$trgs) {
2430  ***      0                                  0               my %trg;
2431  ***      0                                  0               @trg{ map { lc $_ } keys %$trg } = values %$trg;
      ***      0                                  0   
2432  ***      0                                  0               push @{ $self->{triggers}->{$db}->{ $trg{table} } }, \%trg;
      ***      0                                  0   
2433                                                           }
2434                                                        }
2435  ***      0                                  0         $sql = '/*!40101 SET @@SQL_MODE := @OLD_SQL_MODE, '
2436                                                           . '@@SQL_QUOTE_SHOW_CREATE := @OLD_QUOTE */';
2437  ***      0                                  0         MKDEBUG && _d($sql);
2438  ***      0                                  0         $dbh->do($sql);
2439                                                     }
2440  ***      0      0                           0      if ( $tbl ) {
2441  ***      0                                  0         return $self->{triggers}->{$db}->{$tbl};
2442                                                     }
2443  ***      0                                  0      return values %{$self->{triggers}->{$db}};
      ***      0                                  0   
2444                                                  }
2445                                                  
2446                                                  sub get_databases {
2447  ***      0                    0             0      my ( $self, $dbh, $quoter, $like ) = @_;
2448  ***      0      0      0                    0      if ( !$self->{cache} || !$self->{databases} || $like ) {
      ***                    0                        
2449  ***      0                                  0         my $sql = 'SHOW DATABASES';
2450  ***      0                                  0         my @params;
2451  ***      0      0                           0         if ( $like ) {
2452  ***      0                                  0            $sql .= ' LIKE ?';
2453  ***      0                                  0            push @params, $like;
2454                                                        }
2455  ***      0                                  0         my $sth = $dbh->prepare($sql);
2456  ***      0                                  0         MKDEBUG && _d($sql, @params);
2457  ***      0                                  0         $sth->execute( @params );
2458  ***      0                                  0         my @dbs = map { $_->[0] } @{$sth->fetchall_arrayref()};
      ***      0                                  0   
      ***      0                                  0   
2459  ***      0      0                           0         $self->{databases} = \@dbs unless $like;
2460  ***      0                                  0         return @dbs;
2461                                                     }
2462  ***      0                                  0      return @{$self->{databases}};
      ***      0                                  0   
2463                                                  }
2464                                                  
2465                                                  sub get_table_status {
2466  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $like ) = @_;
2467  ***      0      0      0                    0      if ( !$self->{cache} || !$self->{table_status}->{$db} || $like ) {
      ***                    0                        
2468  ***      0                                  0         my $sql = "SHOW TABLE STATUS FROM " . $quoter->quote($db);
2469  ***      0                                  0         my @params;
2470  ***      0      0                           0         if ( $like ) {
2471  ***      0                                  0            $sql .= ' LIKE ?';
2472  ***      0                                  0            push @params, $like;
2473                                                        }
2474  ***      0                                  0         MKDEBUG && _d($sql, @params);
2475  ***      0                                  0         my $sth = $dbh->prepare($sql);
2476  ***      0                                  0         $sth->execute(@params);
2477  ***      0                                  0         my @tables = @{$sth->fetchall_arrayref({})};
      ***      0                                  0   
2478  ***      0                                  0         @tables = map {
2479  ***      0                                  0            my %tbl; # Make a copy with lowercased keys
2480  ***      0                                  0            @tbl{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                  0   
2481  ***      0             0                    0            $tbl{engine} ||= $tbl{type} || $tbl{comment};
      ***                    0                        
2482  ***      0                                  0            delete $tbl{type};
2483  ***      0                                  0            \%tbl;
2484                                                        } @tables;
2485  ***      0      0                           0         $self->{table_status}->{$db} = \@tables unless $like;
2486  ***      0                                  0         return @tables;
2487                                                     }
2488  ***      0                                  0      return @{$self->{table_status}->{$db}};
      ***      0                                  0   
2489                                                  }
2490                                                  
2491                                                  sub get_table_list {
2492  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $like ) = @_;
2493  ***      0      0      0                    0      if ( !$self->{cache} || !$self->{table_list}->{$db} || $like ) {
      ***                    0                        
2494  ***      0                                  0         my $sql = "SHOW /*!50002 FULL*/ TABLES FROM " . $quoter->quote($db);
2495  ***      0                                  0         my @params;
2496  ***      0      0                           0         if ( $like ) {
2497  ***      0                                  0            $sql .= ' LIKE ?';
2498  ***      0                                  0            push @params, $like;
2499                                                        }
2500  ***      0                                  0         MKDEBUG && _d($sql, @params);
2501  ***      0                                  0         my $sth = $dbh->prepare($sql);
2502  ***      0                                  0         $sth->execute(@params);
2503  ***      0                                  0         my @tables = @{$sth->fetchall_arrayref()};
      ***      0                                  0   
2504  ***      0      0      0                    0         @tables = map {
2505  ***      0                                  0            my %tbl = (
2506                                                              name   => $_->[0],
2507                                                              engine => ($_->[1] || '') eq 'VIEW' ? 'VIEW' : '',
2508                                                           );
2509  ***      0                                  0            \%tbl;
2510                                                        } @tables;
2511  ***      0      0                           0         $self->{table_list}->{$db} = \@tables unless $like;
2512  ***      0                                  0         return @tables;
2513                                                     }
2514  ***      0                                  0      return @{$self->{table_list}->{$db}};
      ***      0                                  0   
2515                                                  }
2516                                                  
2517                                                  sub _d {
2518  ***      0                    0             0      my ($package, undef, $line) = caller 0;
2519  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
2520  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
2521                                                          @_;
2522  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2523                                                  }
2524                                                  
2525                                                  1;
2526                                                  
2527                                                  # ###########################################################################
2528                                                  # End MySQLDump package
2529                                                  # ###########################################################################
2530                                                  
2531                                                  # ###########################################################################
2532                                                  # Daemon package 6255
2533                                                  # This package is a copy without comments from the original.  The original
2534                                                  # with comments and its test file can be found in the SVN repository at,
2535                                                  #   trunk/common/Daemon.pm
2536                                                  #   trunk/common/t/Daemon.t
2537                                                  # See http://code.google.com/p/maatkit/wiki/Developers for more information.
2538                                                  # ###########################################################################
2539                                                  
2540                                                  package Daemon;
2541                                                  
2542          21                   21           164   use strict;
              21                                 59   
              21                                116   
2543          21                   21           122   use warnings FATAL => 'all';
              21                                 54   
              21                                122   
2544                                                  
2545          21                   21           126   use POSIX qw(setsid);
              21                                 63   
              21                                174   
2546          21                   21           132   use English qw(-no_match_vars);
              21                                 48   
              21                                120   
2547                                                  
2548  ***     21            50     21           139   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              21                                 56   
              21                                284   
2549                                                  
2550                                                  sub new {
2551  ***      0                    0             0      my ( $class, %args ) = @_;
2552  ***      0                                  0      foreach my $arg ( qw(o) ) {
2553  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
2554                                                     }
2555  ***      0                                  0      my $o = $args{o};
2556  ***      0      0                           0      my $self = {
      ***             0                               
2557                                                        o        => $o,
2558                                                        log_file => $o->has('log') ? $o->get('log') : undef,
2559                                                        PID_file => $o->has('pid') ? $o->get('pid') : undef,
2560                                                     };
2561                                                  
2562  ***      0                                  0      check_PID_file(undef, $self->{PID_file});
2563                                                  
2564  ***      0                                  0      MKDEBUG && _d('Daemonized child will log to', $self->{log_file});
2565  ***      0                                  0      return bless $self, $class;
2566                                                  }
2567                                                  
2568                                                  sub daemonize {
2569  ***      0                    0             0      my ( $self ) = @_;
2570                                                  
2571  ***      0                                  0      MKDEBUG && _d('About to fork and daemonize');
2572  ***      0      0                           0      defined (my $pid = fork()) or die "Cannot fork: $OS_ERROR";
2573  ***      0      0                           0      if ( $pid ) {
2574  ***      0                                  0         MKDEBUG && _d('I am the parent and now I die');
2575  ***      0                                  0         exit;
2576                                                     }
2577                                                  
2578  ***      0                                  0      $self->{PID_owner} = $PID;
2579  ***      0                                  0      $self->{child}     = 1;
2580                                                  
2581  ***      0      0                           0      POSIX::setsid() or die "Cannot start a new session: $OS_ERROR";
2582  ***      0      0                           0      chdir '/'       or die "Cannot chdir to /: $OS_ERROR";
2583                                                  
2584  ***      0                                  0      $self->_make_PID_file();
2585                                                  
2586  ***      0                                  0      $OUTPUT_AUTOFLUSH = 1;
2587                                                  
2588  ***      0      0                           0      if ( -t STDIN ) {
2589  ***      0                                  0         close STDIN;
2590  ***      0      0                           0         open  STDIN, '/dev/null'
2591                                                           or die "Cannot reopen STDIN to /dev/null: $OS_ERROR";
2592                                                     }
2593                                                  
2594  ***      0      0                           0      if ( $self->{log_file} ) {
2595  ***      0                                  0         close STDOUT;
2596  ***      0      0                           0         open  STDOUT, '>>', $self->{log_file}
2597                                                           or die "Cannot open log file $self->{log_file}: $OS_ERROR";
2598                                                  
2599  ***      0                                  0         close STDERR;
2600  ***      0      0                           0         open  STDERR, ">&STDOUT"
2601                                                           or die "Cannot dupe STDERR to STDOUT: $OS_ERROR"; 
2602                                                     }
2603                                                     else {
2604  ***      0      0                           0         if ( -t STDOUT ) {
2605  ***      0                                  0            close STDOUT;
2606  ***      0      0                           0            open  STDOUT, '>', '/dev/null'
2607                                                              or die "Cannot reopen STDOUT to /dev/null: $OS_ERROR";
2608                                                        }
2609  ***      0      0                           0         if ( -t STDERR ) {
2610  ***      0                                  0            close STDERR;
2611  ***      0      0                           0            open  STDERR, '>', '/dev/null'
2612                                                              or die "Cannot reopen STDERR to /dev/null: $OS_ERROR";
2613                                                        }
2614                                                     }
2615                                                  
2616  ***      0                                  0      MKDEBUG && _d('I am the child and now I live daemonized');
2617  ***      0                                  0      return;
2618                                                  }
2619                                                  
2620                                                  sub check_PID_file {
2621  ***      0                    0             0      my ( $self, $file ) = @_;
2622  ***      0      0                           0      my $PID_file = $self ? $self->{PID_file} : $file;
2623  ***      0                                  0      MKDEBUG && _d('Checking PID file', $PID_file);
2624  ***      0      0      0                    0      if ( $PID_file && -f $PID_file ) {
2625  ***      0                                  0         my $pid;
2626  ***      0                                  0         eval { chomp($pid = `cat $PID_file`); };
      ***      0                                  0   
2627  ***      0      0                           0         die "Cannot cat $PID_file: $OS_ERROR" if $EVAL_ERROR;
2628  ***      0                                  0         MKDEBUG && _d('PID file exists; it contains PID', $pid);
2629  ***      0      0                           0         if ( $pid ) {
2630  ***      0                                  0            my $pid_is_alive = kill 0, $pid;
2631  ***      0      0                           0            if ( $pid_is_alive ) {
2632  ***      0                                  0               die "The PID file $PID_file already exists "
2633                                                                 . " and the PID that it contains, $pid, is running";
2634                                                           }
2635                                                           else {
2636  ***      0                                  0               warn "Overwriting PID file $PID_file because the PID that it "
2637                                                                 . "contains, $pid, is not running";
2638                                                           }
2639                                                        }
2640                                                        else {
2641  ***      0                                  0            die "The PID file $PID_file already exists but it does not "
2642                                                              . "contain a PID";
2643                                                        }
2644                                                     }
2645                                                     else {
2646  ***      0                                  0         MKDEBUG && _d('No PID file');
2647                                                     }
2648  ***      0                                  0      return;
2649                                                  }
2650                                                  
2651                                                  sub make_PID_file {
2652  ***      0                    0             0      my ( $self ) = @_;
2653  ***      0      0                           0      if ( exists $self->{child} ) {
2654  ***      0                                  0         die "Do not call Daemon::make_PID_file() for daemonized scripts";
2655                                                     }
2656  ***      0                                  0      $self->_make_PID_file();
2657  ***      0                                  0      $self->{PID_owner} = $PID;
2658  ***      0                                  0      return;
2659                                                  }
2660                                                  
2661                                                  sub _make_PID_file {
2662  ***      0                    0             0      my ( $self ) = @_;
2663                                                  
2664  ***      0                                  0      my $PID_file = $self->{PID_file};
2665  ***      0      0                           0      if ( !$PID_file ) {
2666  ***      0                                  0         MKDEBUG && _d('No PID file to create');
2667  ***      0                                  0         return;
2668                                                     }
2669                                                  
2670  ***      0                                  0      $self->check_PID_file();
2671                                                  
2672  ***      0      0                           0      open my $PID_FH, '>', $PID_file
2673                                                        or die "Cannot open PID file $PID_file: $OS_ERROR";
2674  ***      0      0                           0      print $PID_FH $PID
2675                                                        or die "Cannot print to PID file $PID_file: $OS_ERROR";
2676  ***      0      0                           0      close $PID_FH
2677                                                        or die "Cannot close PID file $PID_file: $OS_ERROR";
2678                                                  
2679  ***      0                                  0      MKDEBUG && _d('Created PID file:', $self->{PID_file});
2680  ***      0                                  0      return;
2681                                                  }
2682                                                  
2683                                                  sub _remove_PID_file {
2684  ***      0                    0             0      my ( $self ) = @_;
2685  ***      0      0      0                    0      if ( $self->{PID_file} && -f $self->{PID_file} ) {
2686  ***      0      0                           0         unlink $self->{PID_file}
2687                                                           or warn "Cannot remove PID file $self->{PID_file}: $OS_ERROR";
2688  ***      0                                  0         MKDEBUG && _d('Removed PID file');
2689                                                     }
2690                                                     else {
2691  ***      0                                  0         MKDEBUG && _d('No PID to remove');
2692                                                     }
2693  ***      0                                  0      return;
2694                                                  }
2695                                                  
2696                                                  sub DESTROY {
2697  ***      0                    0             0      my ( $self ) = @_;
2698                                                  
2699  ***      0      0      0                    0      $self->_remove_PID_file() if ($self->{PID_owner} || 0) == $PID;
2700                                                  
2701  ***      0                                  0      return;
2702                                                  }
2703                                                  
2704                                                  sub _d {
2705  ***      0                    0             0      my ($package, undef, $line) = caller 0;
2706  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
2707  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
2708                                                          @_;
2709  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2710                                                  }
2711                                                  
2712                                                  1;
2713                                                  
2714                                                  # ###########################################################################
2715                                                  # End Daemon package
2716                                                  # ###########################################################################
2717                                                  
2718                                                  # ###########################################################################
2719                                                  # MasterSlave package 6935
2720                                                  # This package is a copy without comments from the original.  The original
2721                                                  # with comments and its test file can be found in the SVN repository at,
2722                                                  #   trunk/common/MasterSlave.pm
2723                                                  #   trunk/common/t/MasterSlave.t
2724                                                  # See http://code.google.com/p/maatkit/wiki/Developers for more information.
2725                                                  # ###########################################################################
2726                                                  
2727                                                  package MasterSlave;
2728                                                  
2729          21                   21           153   use strict;
              21                                 53   
              21                                112   
2730          21                   21           129   use warnings FATAL => 'all';
              21                                 68   
              21                                111   
2731          21                   21           123   use English qw(-no_match_vars);
              21                                 54   
              21                                181   
2732  ***     21            50     21           138   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              21                                 55   
              21                                330   
2733                                                  
2734          21                   21           138   use List::Util qw(min max);
              21                                 48   
              21                                123   
2735          21                   21           130   use Data::Dumper;
              21                                 55   
              21                                129   
2736                                                  $Data::Dumper::Quotekeys = 0;
2737                                                  $Data::Dumper::Indent    = 0;
2738                                                  
2739                                                  sub new {
2740  ***      0                    0             0      my ( $class, %args ) = @_;
2741  ***      0                                  0      my $self = {
2742                                                        %args,
2743                                                        replication_thread => {},
2744                                                     };
2745  ***      0                                  0      return bless $self, $class;
2746                                                  }
2747                                                  
2748                                                  sub recurse_to_slaves {
2749  ***      0                    0             0      my ( $self, $args, $level ) = @_;
2750  ***      0             0                    0      $level ||= 0;
2751  ***      0                                  0      my $dp   = $args->{dsn_parser};
2752  ***      0                                  0      my $dsn  = $args->{dsn};
2753                                                  
2754  ***      0                                  0      my $dbh;
2755  ***      0                                  0      eval {
2756  ***      0             0                    0         $dbh = $args->{dbh} || $dp->get_dbh(
2757                                                           $dp->get_cxn_params($dsn), { AutoCommit => 1 });
2758  ***      0                                  0         MKDEBUG && _d('Connected to', $dp->as_string($dsn));
2759                                                     };
2760  ***      0      0                           0      if ( $EVAL_ERROR ) {
2761  ***      0      0                           0         print STDERR "Cannot connect to ", $dp->as_string($dsn), "\n"
2762                                                           or die "Cannot print: $OS_ERROR";
2763  ***      0                                  0         return;
2764                                                     }
2765                                                  
2766  ***      0                                  0      my $sql  = 'SELECT @@SERVER_ID';
2767  ***      0                                  0      MKDEBUG && _d($sql);
2768  ***      0                                  0      my ($id) = $dbh->selectrow_array($sql);
2769  ***      0                                  0      MKDEBUG && _d('Working on server ID', $id);
2770  ***      0                                  0      my $master_thinks_i_am = $dsn->{server_id};
2771  ***      0      0      0                    0      if ( !defined $id
      ***                    0                        
      ***                    0                        
2772                                                         || ( defined $master_thinks_i_am && $master_thinks_i_am != $id )
2773                                                         || $args->{server_ids_seen}->{$id}++
2774                                                     ) {
2775  ***      0                                  0         MKDEBUG && _d('Server ID seen, or not what master said');
2776  ***      0      0                           0         if ( $args->{skip_callback} ) {
2777  ***      0                                  0            $args->{skip_callback}->($dsn, $dbh, $level, $args->{parent});
2778                                                        }
2779  ***      0                                  0         return;
2780                                                     }
2781                                                  
2782  ***      0                                  0      $args->{callback}->($dsn, $dbh, $level, $args->{parent});
2783                                                  
2784  ***      0      0      0                    0      if ( !defined $args->{recurse} || $level < $args->{recurse} ) {
2785                                                  
2786  ***      0      0                           0         my @slaves =
2787  ***      0                                  0            grep { !$_->{master_id} || $_->{master_id} == $id } # Only my slaves.
2788                                                           $self->find_slave_hosts($dp, $dbh, $dsn, $args->{method});
2789                                                  
2790  ***      0                                  0         foreach my $slave ( @slaves ) {
2791  ***      0                                  0            MKDEBUG && _d('Recursing from',
2792                                                              $dp->as_string($dsn), 'to', $dp->as_string($slave));
2793  ***      0                                  0            $self->recurse_to_slaves(
2794                                                              { %$args, dsn => $slave, dbh => undef, parent => $dsn }, $level + 1 );
2795                                                        }
2796                                                     }
2797                                                  }
2798                                                  
2799                                                  sub find_slave_hosts {
2800  ***      0                    0             0      my ( $self, $dsn_parser, $dbh, $dsn, $method ) = @_;
2801                                                  
2802  ***      0                                  0      my @methods = qw(processlist hosts);
2803  ***      0      0                           0      if ( $method ) {
2804  ***      0                                  0         @methods = grep { $_ ne $method } @methods;
      ***      0                                  0   
2805  ***      0                                  0         unshift @methods, $method;
2806                                                     }
2807                                                     else {
2808  ***      0      0      0                    0         if ( ($dsn->{P} || 3306) != 3306 ) {
2809  ***      0                                  0            MKDEBUG && _d('Port number is non-standard; using only hosts method');
2810  ***      0                                  0            @methods = qw(hosts);
2811                                                        }
2812                                                     }
2813  ***      0                                  0      MKDEBUG && _d('Looking for slaves on', $dsn_parser->as_string($dsn),
2814                                                        'using methods', @methods);
2815                                                  
2816  ***      0                                  0      my @slaves;
2817                                                     METHOD:
2818  ***      0                                  0      foreach my $method ( @methods ) {
2819  ***      0                                  0         my $find_slaves = "_find_slaves_by_$method";
2820  ***      0                                  0         MKDEBUG && _d('Finding slaves with', $find_slaves);
2821  ***      0                                  0         @slaves = $self->$find_slaves($dsn_parser, $dbh, $dsn);
2822  ***      0      0                           0         last METHOD if @slaves;
2823                                                     }
2824                                                  
2825  ***      0                                  0      MKDEBUG && _d('Found', scalar(@slaves), 'slaves');
2826  ***      0                                  0      return @slaves;
2827                                                  }
2828                                                  
2829                                                  sub _find_slaves_by_processlist {
2830  ***      0                    0             0      my ( $self, $dsn_parser, $dbh, $dsn ) = @_;
2831                                                  
2832  ***      0                                  0      my @slaves = map  {
2833  ***      0                                  0         my $slave        = $dsn_parser->parse("h=$_", $dsn);
2834  ***      0                                  0         $slave->{source} = 'processlist';
2835  ***      0                                  0         $slave;
2836                                                     }
2837  ***      0                                  0      grep { $_ }
2838                                                     map  {
2839  ***      0                                  0         my ( $host ) = $_->{host} =~ m/^([^:]+):/;
2840  ***      0      0                           0         if ( $host eq 'localhost' ) {
2841  ***      0                                  0            $host = '127.0.0.1'; # Replication never uses sockets.
2842                                                        }
2843  ***      0                                  0         $host;
2844                                                     } $self->get_connected_slaves($dbh);
2845                                                  
2846  ***      0                                  0      return @slaves;
2847                                                  }
2848                                                  
2849                                                  sub _find_slaves_by_hosts {
2850  ***      0                    0             0      my ( $self, $dsn_parser, $dbh, $dsn ) = @_;
2851                                                  
2852  ***      0                                  0      my @slaves;
2853  ***      0                                  0      my $sql = 'SHOW SLAVE HOSTS';
2854  ***      0                                  0      MKDEBUG && _d($dbh, $sql);
2855  ***      0                                  0      @slaves = @{$dbh->selectall_arrayref($sql, { Slice => {} })};
      ***      0                                  0   
2856                                                  
2857  ***      0      0                           0      if ( @slaves ) {
2858  ***      0                                  0         MKDEBUG && _d('Found some SHOW SLAVE HOSTS info');
2859  ***      0                                  0         @slaves = map {
2860  ***      0                                  0            my %hash;
2861  ***      0                                  0            @hash{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                  0   
2862  ***      0      0                           0            my $spec = "h=$hash{host},P=$hash{port}"
      ***             0                               
2863                                                              . ( $hash{user} ? ",u=$hash{user}" : '')
2864                                                              . ( $hash{password} ? ",p=$hash{password}" : '');
2865  ***      0                                  0            my $dsn           = $dsn_parser->parse($spec, $dsn);
2866  ***      0                                  0            $dsn->{server_id} = $hash{server_id};
2867  ***      0                                  0            $dsn->{master_id} = $hash{master_id};
2868  ***      0                                  0            $dsn->{source}    = 'hosts';
2869  ***      0                                  0            $dsn;
2870                                                        } @slaves;
2871                                                     }
2872                                                  
2873  ***      0                                  0      return @slaves;
2874                                                  }
2875                                                  
2876                                                  sub get_connected_slaves {
2877  ***      0                    0             0      my ( $self, $dbh ) = @_;
2878                                                  
2879  ***      0                                  0      my $show = "SHOW GRANTS FOR ";
2880  ***      0                                  0      my $user = 'CURRENT_USER()';
2881  ***      0                                  0      my $vp   = $self->{VersionParser};
2882  ***      0      0      0                    0      if ( $vp && !$vp->version_ge($dbh, '4.1.2') ) {
2883  ***      0                                  0         $user = $dbh->selectrow_arrayref('SELECT USER()')->[0];
2884  ***      0                                  0         $user =~ s/([^@]+)@(.+)/'$1'\@'$2'/;
2885                                                     }
2886  ***      0                                  0      my $sql = $show . $user;
2887  ***      0                                  0      MKDEBUG && _d($dbh, $sql);
2888                                                  
2889  ***      0                                  0      my $proc;
2890  ***      0                                  0      eval {
2891  ***      0                                  0         $proc = grep {
2892  ***      0                                  0            m/ALL PRIVILEGES.*?\*\.\*|PROCESS/
2893  ***      0                                  0         } @{$dbh->selectcol_arrayref($sql)};
2894                                                     };
2895  ***      0      0                           0      if ( $EVAL_ERROR ) {
2896                                                  
2897  ***      0      0                           0         if ( $EVAL_ERROR =~ m/no such grant defined for user/ ) {
2898  ***      0                                  0            MKDEBUG && _d('Retrying SHOW GRANTS without host; error:',
2899                                                              $EVAL_ERROR);
2900  ***      0                                  0            ($user) = split('@', $user);
2901  ***      0                                  0            $sql    = $show . $user;
2902  ***      0                                  0            MKDEBUG && _d($sql);
2903  ***      0                                  0            eval {
2904  ***      0                                  0               $proc = grep {
2905  ***      0                                  0                  m/ALL PRIVILEGES.*?\*\.\*|PROCESS/
2906  ***      0                                  0               } @{$dbh->selectcol_arrayref($sql)};
2907                                                           };
2908                                                        }
2909                                                  
2910  ***      0      0                           0         die "Failed to $sql: $EVAL_ERROR" if $EVAL_ERROR;
2911                                                     }
2912  ***      0      0                           0      if ( !$proc ) {
2913  ***      0                                  0         die "You do not have the PROCESS privilege";
2914                                                     }
2915                                                  
2916  ***      0                                  0      $sql = 'SHOW PROCESSLIST';
2917  ***      0                                  0      MKDEBUG && _d($dbh, $sql);
2918  ***      0                                  0      grep { $_->{command} =~ m/Binlog Dump/i }
      ***      0                                  0   
2919                                                     map  { # Lowercase the column names
2920  ***      0                                  0         my %hash;
2921  ***      0                                  0         @hash{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                  0   
2922  ***      0                                  0         \%hash;
2923                                                     }
2924  ***      0                                  0      @{$dbh->selectall_arrayref($sql, { Slice => {} })};
2925                                                  }
2926                                                  
2927                                                  sub is_master_of {
2928  ***      0                    0             0      my ( $self, $master, $slave ) = @_;
2929  ***      0      0                           0      my $master_status = $self->get_master_status($master)
2930                                                        or die "The server specified as a master is not a master";
2931  ***      0      0                           0      my $slave_status  = $self->get_slave_status($slave)
2932                                                        or die "The server specified as a slave is not a slave";
2933  ***      0      0                           0      my @connected     = $self->get_connected_slaves($master)
2934                                                        or die "The server specified as a master has no connected slaves";
2935  ***      0                                  0      my (undef, $port) = $master->selectrow_array('SHOW VARIABLES LIKE "port"');
2936                                                  
2937  ***      0      0                           0      if ( $port != $slave_status->{master_port} ) {
2938  ***      0                                  0         die "The slave is connected to $slave_status->{master_port} "
2939                                                           . "but the master's port is $port";
2940                                                     }
2941                                                  
2942  ***      0      0                           0      if ( !grep { $slave_status->{master_user} eq $_->{user} } @connected ) {
      ***      0                                  0   
2943  ***      0                                  0         die "I don't see any slave I/O thread connected with user "
2944                                                           . $slave_status->{master_user};
2945                                                     }
2946                                                  
2947  ***      0      0      0                    0      if ( ($slave_status->{slave_io_state} || '')
2948                                                        eq 'Waiting for master to send event' )
2949                                                     {
2950  ***      0                                  0         my ( $master_log_name, $master_log_num )
2951                                                           = $master_status->{file} =~ m/^(.*?)\.0*([1-9][0-9]*)$/;
2952  ***      0                                  0         my ( $slave_log_name, $slave_log_num )
2953                                                           = $slave_status->{master_log_file} =~ m/^(.*?)\.0*([1-9][0-9]*)$/;
2954  ***      0      0      0                    0         if ( $master_log_name ne $slave_log_name
2955                                                           || abs($master_log_num - $slave_log_num) > 1 )
2956                                                        {
2957  ***      0                                  0            die "The slave thinks it is reading from "
2958                                                              . "$slave_status->{master_log_file},  but the "
2959                                                              . "master is writing to $master_status->{file}";
2960                                                        }
2961                                                     }
2962  ***      0                                  0      return 1;
2963                                                  }
2964                                                  
2965                                                  sub get_master_dsn {
2966  ***      0                    0             0      my ( $self, $dbh, $dsn, $dsn_parser ) = @_;
2967  ***      0      0                           0      my $master = $self->get_slave_status($dbh) or return undef;
2968  ***      0                                  0      my $spec   = "h=$master->{master_host},P=$master->{master_port}";
2969  ***      0                                  0      return       $dsn_parser->parse($spec, $dsn);
2970                                                  }
2971                                                  
2972                                                  sub get_slave_status {
2973  ***      0                    0             0      my ( $self, $dbh ) = @_;
2974  ***      0      0                           0      if ( !$self->{not_a_slave}->{$dbh} ) {
2975  ***      0             0                    0         my $sth = $self->{sths}->{$dbh}->{SLAVE_STATUS}
2976                                                              ||= $dbh->prepare('SHOW SLAVE STATUS');
2977  ***      0                                  0         MKDEBUG && _d($dbh, 'SHOW SLAVE STATUS');
2978  ***      0                                  0         $sth->execute();
2979  ***      0                                  0         my ($ss) = @{$sth->fetchall_arrayref({})};
      ***      0                                  0   
2980                                                  
2981  ***      0      0      0                    0         if ( $ss && %$ss ) {
2982  ***      0                                  0            $ss = { map { lc($_) => $ss->{$_} } keys %$ss }; # lowercase the keys
      ***      0                                  0   
2983  ***      0                                  0            return $ss;
2984                                                        }
2985                                                  
2986  ***      0                                  0         MKDEBUG && _d('This server returns nothing for SHOW SLAVE STATUS');
2987  ***      0                                  0         $self->{not_a_slave}->{$dbh}++;
2988                                                     }
2989                                                  }
2990                                                  
2991                                                  sub get_master_status {
2992  ***      0                    0             0      my ( $self, $dbh ) = @_;
2993  ***      0      0                           0      if ( !$self->{not_a_master}->{$dbh} ) {
2994  ***      0             0                    0         my $sth = $self->{sths}->{$dbh}->{MASTER_STATUS}
2995                                                              ||= $dbh->prepare('SHOW MASTER STATUS');
2996  ***      0                                  0         MKDEBUG && _d($dbh, 'SHOW MASTER STATUS');
2997  ***      0                                  0         $sth->execute();
2998  ***      0                                  0         my ($ms) = @{$sth->fetchall_arrayref({})};
      ***      0                                  0   
2999                                                  
3000  ***      0      0      0                    0         if ( $ms && %$ms ) {
3001  ***      0                                  0            $ms = { map { lc($_) => $ms->{$_} } keys %$ms }; # lowercase the keys
      ***      0                                  0   
3002  ***      0      0      0                    0            if ( $ms->{file} && $ms->{position} ) {
3003  ***      0                                  0               return $ms;
3004                                                           }
3005                                                        }
3006                                                  
3007  ***      0                                  0         MKDEBUG && _d('This server returns nothing for SHOW MASTER STATUS');
3008  ***      0                                  0         $self->{not_a_master}->{$dbh}++;
3009                                                     }
3010                                                  }
3011                                                  
3012                                                  sub wait_for_master {
3013  ***      0                    0             0      my ( $self, %args ) = @_;
3014  ***      0                                  0      my @required_args = qw(master_dbh slave_dbh);
3015  ***      0                                  0      foreach my $arg ( @required_args ) {
3016  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
3017                                                     }
3018  ***      0                                  0      my ($master_dbh, $slave_dbh) = @args{@required_args};
3019  ***      0             0                    0      my $timeout       = $args{timeout} || 60;
3020  ***      0             0                    0      my $master_status = $args{master_status}
3021                                                                         || $self->get_master_status($master_dbh);
3022                                                  
3023  ***      0                                  0      my $result;
3024  ***      0                                  0      my $waited;
3025  ***      0      0                           0      if ( $master_status ) {
3026  ***      0                                  0         my $sql = "SELECT MASTER_POS_WAIT('$master_status->{file}', "
3027                                                                . "$master_status->{position}, $timeout)";
3028  ***      0                                  0         MKDEBUG && _d($slave_dbh, $sql);
3029  ***      0                                  0         my $start  = time;
3030  ***      0                                  0         ($result)  = $slave_dbh->selectrow_array($sql);
3031                                                  
3032  ***      0                                  0         $waited = time - $start;
3033                                                  
3034  ***      0                                  0         MKDEBUG && _d('Result of waiting:', $result);
3035  ***      0                                  0         MKDEBUG && _d("Waited", $waited, "seconds");
3036                                                     }
3037                                                     else {
3038  ***      0                                  0         MKDEBUG && _d('Not waiting: this server is not a master');
3039                                                     }
3040                                                  
3041                                                     return {
3042  ***      0                                  0         result => $result,
3043                                                        waited => $waited,
3044                                                     };
3045                                                  }
3046                                                  
3047                                                  sub stop_slave {
3048  ***      0                    0             0      my ( $self, $dbh ) = @_;
3049  ***      0             0                    0      my $sth = $self->{sths}->{$dbh}->{STOP_SLAVE}
3050                                                           ||= $dbh->prepare('STOP SLAVE');
3051  ***      0                                  0      MKDEBUG && _d($dbh, $sth->{Statement});
3052  ***      0                                  0      $sth->execute();
3053                                                  }
3054                                                  
3055                                                  sub start_slave {
3056  ***      0                    0             0      my ( $self, $dbh, $pos ) = @_;
3057  ***      0      0                           0      if ( $pos ) {
3058  ***      0                                  0         my $sql = "START SLAVE UNTIL MASTER_LOG_FILE='$pos->{file}', "
3059                                                                . "MASTER_LOG_POS=$pos->{position}";
3060  ***      0                                  0         MKDEBUG && _d($dbh, $sql);
3061  ***      0                                  0         $dbh->do($sql);
3062                                                     }
3063                                                     else {
3064  ***      0             0                    0         my $sth = $self->{sths}->{$dbh}->{START_SLAVE}
3065                                                              ||= $dbh->prepare('START SLAVE');
3066  ***      0                                  0         MKDEBUG && _d($dbh, $sth->{Statement});
3067  ***      0                                  0         $sth->execute();
3068                                                     }
3069                                                  }
3070                                                  
3071                                                  sub catchup_to_master {
3072  ***      0                    0             0      my ( $self, $slave, $master, $time ) = @_;
3073  ***      0                                  0      $self->stop_slave($master);
3074  ***      0                                  0      $self->stop_slave($slave);
3075  ***      0                                  0      my $slave_status  = $self->get_slave_status($slave);
3076  ***      0                                  0      my $slave_pos     = $self->repl_posn($slave_status);
3077  ***      0                                  0      my $master_status = $self->get_master_status($master);
3078  ***      0                                  0      my $master_pos    = $self->repl_posn($master_status);
3079  ***      0                                  0      MKDEBUG && _d('Master position:', $self->pos_to_string($master_pos),
3080                                                        'Slave position:', $self->pos_to_string($slave_pos));
3081                                                  
3082  ***      0                                  0      my $result;
3083  ***      0      0                           0      if ( $self->pos_cmp($slave_pos, $master_pos) < 0 ) {
3084  ***      0                                  0         MKDEBUG && _d('Waiting for slave to catch up to master');
3085  ***      0                                  0         $self->start_slave($slave, $master_pos);
3086                                                  
3087  ***      0                                  0         $result = $self->wait_for_master(
3088                                                              master_dbh    => $master,
3089                                                              slave_dbh     => $slave,
3090                                                              timeout       => $time,
3091                                                              master_status => $master_status
3092                                                        );
3093  ***      0      0                           0         if ( !defined $result ) {
3094  ***      0                                  0            $slave_status = $self->get_slave_status($slave);
3095  ***      0      0                           0            if ( !$self->slave_is_running($slave_status) ) {
3096  ***      0                                  0               MKDEBUG && _d('Master position:',
3097                                                                 $self->pos_to_string($master_pos),
3098                                                                 'Slave position:', $self->pos_to_string($slave_pos));
3099  ***      0                                  0               $slave_pos = $self->repl_posn($slave_status);
3100  ***      0      0                           0               if ( $self->pos_cmp($slave_pos, $master_pos) != 0 ) {
3101  ***      0                                  0                  die "MASTER_POS_WAIT() returned NULL but slave has not "
3102                                                                    . "caught up to master";
3103                                                              }
3104  ***      0                                  0               MKDEBUG && _d('Slave is caught up to master and stopped');
3105                                                           }
3106                                                           else {
3107  ***      0                                  0               die "Slave has not caught up to master and it is still running";
3108                                                           }
3109                                                        }
3110                                                     }
3111                                                     else {
3112  ***      0                                  0         MKDEBUG && _d("Slave is already caught up to master");
3113                                                     }
3114                                                  
3115  ***      0                                  0      return $result;
3116                                                  }
3117                                                  
3118                                                  sub catchup_to_same_pos {
3119  ***      0                    0             0      my ( $self, $s1_dbh, $s2_dbh ) = @_;
3120  ***      0                                  0      $self->stop_slave($s1_dbh);
3121  ***      0                                  0      $self->stop_slave($s2_dbh);
3122  ***      0                                  0      my $s1_status = $self->get_slave_status($s1_dbh);
3123  ***      0                                  0      my $s2_status = $self->get_slave_status($s2_dbh);
3124  ***      0                                  0      my $s1_pos    = $self->repl_posn($s1_status);
3125  ***      0                                  0      my $s2_pos    = $self->repl_posn($s2_status);
3126  ***      0      0                           0      if ( $self->pos_cmp($s1_pos, $s2_pos) < 0 ) {
      ***             0                               
3127  ***      0                                  0         $self->start_slave($s1_dbh, $s2_pos);
3128                                                     }
3129                                                     elsif ( $self->pos_cmp($s2_pos, $s1_pos) < 0 ) {
3130  ***      0                                  0         $self->start_slave($s2_dbh, $s1_pos);
3131                                                     }
3132                                                  
3133  ***      0                                  0      $s1_status = $self->get_slave_status($s1_dbh);
3134  ***      0                                  0      $s2_status = $self->get_slave_status($s2_dbh);
3135  ***      0                                  0      $s1_pos    = $self->repl_posn($s1_status);
3136  ***      0                                  0      $s2_pos    = $self->repl_posn($s2_status);
3137                                                  
3138  ***      0      0      0                    0      if ( $self->slave_is_running($s1_status)
      ***                    0                        
3139                                                       || $self->slave_is_running($s2_status)
3140                                                       || $self->pos_cmp($s1_pos, $s2_pos) != 0)
3141                                                     {
3142  ***      0                                  0         die "The servers aren't both stopped at the same position";
3143                                                     }
3144                                                  
3145                                                  }
3146                                                  
3147                                                  sub change_master_to {
3148  ***      0                    0             0      my ( $self, $dbh, $master_dsn, $master_pos ) = @_;
3149  ***      0                                  0      $self->stop_slave($dbh);
3150  ***      0                                  0      MKDEBUG && _d(Dumper($master_dsn), Dumper($master_pos));
3151  ***      0                                  0      my $sql = "CHANGE MASTER TO MASTER_HOST='$master_dsn->{h}', "
3152                                                        . "MASTER_PORT= $master_dsn->{P}, MASTER_LOG_FILE='$master_pos->{file}', "
3153                                                        . "MASTER_LOG_POS=$master_pos->{position}";
3154  ***      0                                  0      MKDEBUG && _d($dbh, $sql);
3155  ***      0                                  0      $dbh->do($sql);
3156                                                  }
3157                                                  
3158                                                  sub make_sibling_of_master {
3159  ***      0                    0             0      my ( $self, $slave_dbh, $slave_dsn, $dsn_parser, $timeout) = @_;
3160                                                  
3161  ***      0      0                           0      my $master_dsn  = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
3162                                                        or die "This server is not a slave";
3163  ***      0                                  0      my $master_dbh  = $dsn_parser->get_dbh(
3164                                                        $dsn_parser->get_cxn_params($master_dsn), { AutoCommit => 1 });
3165  ***      0      0                           0      my $gmaster_dsn
3166                                                        = $self->get_master_dsn($master_dbh, $master_dsn, $dsn_parser)
3167                                                        or die "This server's master is not a slave";
3168  ***      0                                  0      my $gmaster_dbh = $dsn_parser->get_dbh(
3169                                                        $dsn_parser->get_cxn_params($gmaster_dsn), { AutoCommit => 1 });
3170  ***      0      0                           0      if ( $self->short_host($slave_dsn) eq $self->short_host($gmaster_dsn) ) {
3171  ***      0                                  0         die "The slave's master's master is the slave: master-master replication";
3172                                                     }
3173                                                  
3174  ***      0                                  0      $self->stop_slave($master_dbh);
3175  ***      0                                  0      $self->catchup_to_master($slave_dbh, $master_dbh, $timeout);
3176  ***      0                                  0      $self->stop_slave($slave_dbh);
3177                                                  
3178  ***      0                                  0      my $master_status = $self->get_master_status($master_dbh);
3179  ***      0                                  0      my $mslave_status = $self->get_slave_status($master_dbh);
3180  ***      0                                  0      my $slave_status  = $self->get_slave_status($slave_dbh);
3181  ***      0                                  0      my $master_pos    = $self->repl_posn($master_status);
3182  ***      0                                  0      my $slave_pos     = $self->repl_posn($slave_status);
3183                                                  
3184  ***      0      0      0                    0      if ( !$self->slave_is_running($mslave_status)
      ***                    0                        
3185                                                       && !$self->slave_is_running($slave_status)
3186                                                       && $self->pos_cmp($master_pos, $slave_pos) == 0)
3187                                                     {
3188  ***      0                                  0         $self->change_master_to($slave_dbh, $gmaster_dsn,
3189                                                           $self->repl_posn($mslave_status)); # Note it's not $master_pos!
3190                                                     }
3191                                                     else {
3192  ***      0                                  0         die "The servers aren't both stopped at the same position";
3193                                                     }
3194                                                  
3195  ***      0                                  0      $mslave_status = $self->get_slave_status($master_dbh);
3196  ***      0                                  0      $slave_status  = $self->get_slave_status($slave_dbh);
3197  ***      0                                  0      my $mslave_pos = $self->repl_posn($mslave_status);
3198  ***      0                                  0      $slave_pos     = $self->repl_posn($slave_status);
3199  ***      0      0      0                    0      if ( $self->short_host($mslave_status) ne $self->short_host($slave_status)
3200                                                       || $self->pos_cmp($mslave_pos, $slave_pos) != 0)
3201                                                     {
3202  ***      0                                  0         die "The servers don't have the same master/position after the change";
3203                                                     }
3204                                                  }
3205                                                  
3206                                                  sub make_slave_of_sibling {
3207  ***      0                    0             0      my ( $self, $slave_dbh, $slave_dsn, $sib_dbh, $sib_dsn,
3208                                                          $dsn_parser, $timeout) = @_;
3209                                                  
3210  ***      0      0                           0      if ( $self->short_host($slave_dsn) eq $self->short_host($sib_dsn) ) {
3211  ***      0                                  0         die "You are trying to make the slave a slave of itself";
3212                                                     }
3213                                                  
3214  ***      0      0                           0      my $master_dsn1 = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
3215                                                        or die "This server is not a slave";
3216  ***      0                                  0      my $master_dbh1 = $dsn_parser->get_dbh(
3217                                                        $dsn_parser->get_cxn_params($master_dsn1), { AutoCommit => 1 });
3218  ***      0      0                           0      my $master_dsn2 = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
3219                                                        or die "The sibling is not a slave";
3220  ***      0      0                           0      if ( $self->short_host($master_dsn1) ne $self->short_host($master_dsn2) ) {
3221  ***      0                                  0         die "This server isn't a sibling of the slave";
3222                                                     }
3223  ***      0      0                           0      my $sib_master_stat = $self->get_master_status($sib_dbh)
3224                                                        or die "Binary logging is not enabled on the sibling";
3225  ***      0      0                           0      die "The log_slave_updates option is not enabled on the sibling"
3226                                                        unless $self->has_slave_updates($sib_dbh);
3227                                                  
3228  ***      0                                  0      $self->catchup_to_same_pos($slave_dbh, $sib_dbh);
3229                                                  
3230  ***      0                                  0      $sib_master_stat = $self->get_master_status($sib_dbh);
3231  ***      0                                  0      $self->change_master_to($slave_dbh, $sib_dsn,
3232                                                           $self->repl_posn($sib_master_stat));
3233                                                  
3234  ***      0                                  0      my $slave_status = $self->get_slave_status($slave_dbh);
3235  ***      0                                  0      my $slave_pos    = $self->repl_posn($slave_status);
3236  ***      0                                  0      $sib_master_stat = $self->get_master_status($sib_dbh);
3237  ***      0      0      0                    0      if ( $self->short_host($slave_status) ne $self->short_host($sib_dsn)
3238                                                       || $self->pos_cmp($self->repl_posn($sib_master_stat), $slave_pos) != 0)
3239                                                     {
3240  ***      0                                  0         die "After changing the slave's master, it isn't a slave of the sibling, "
3241                                                           . "or it has a different replication position than the sibling";
3242                                                     }
3243                                                  }
3244                                                  
3245                                                  sub make_slave_of_uncle {
3246  ***      0                    0             0      my ( $self, $slave_dbh, $slave_dsn, $unc_dbh, $unc_dsn,
3247                                                          $dsn_parser, $timeout) = @_;
3248                                                  
3249  ***      0      0                           0      if ( $self->short_host($slave_dsn) eq $self->short_host($unc_dsn) ) {
3250  ***      0                                  0         die "You are trying to make the slave a slave of itself";
3251                                                     }
3252                                                  
3253  ***      0      0                           0      my $master_dsn = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
3254                                                        or die "This server is not a slave";
3255  ***      0                                  0      my $master_dbh = $dsn_parser->get_dbh(
3256                                                        $dsn_parser->get_cxn_params($master_dsn), { AutoCommit => 1 });
3257  ***      0      0                           0      my $gmaster_dsn
3258                                                        = $self->get_master_dsn($master_dbh, $master_dsn, $dsn_parser)
3259                                                        or die "The master is not a slave";
3260  ***      0      0                           0      my $unc_master_dsn
3261                                                        = $self->get_master_dsn($unc_dbh, $unc_dsn, $dsn_parser)
3262                                                        or die "The uncle is not a slave";
3263  ***      0      0                           0      if ($self->short_host($gmaster_dsn) ne $self->short_host($unc_master_dsn)) {
3264  ***      0                                  0         die "The uncle isn't really the slave's uncle";
3265                                                     }
3266                                                  
3267  ***      0      0                           0      my $unc_master_stat = $self->get_master_status($unc_dbh)
3268                                                        or die "Binary logging is not enabled on the uncle";
3269  ***      0      0                           0      die "The log_slave_updates option is not enabled on the uncle"
3270                                                        unless $self->has_slave_updates($unc_dbh);
3271                                                  
3272  ***      0                                  0      $self->catchup_to_same_pos($master_dbh, $unc_dbh);
3273  ***      0                                  0      $self->catchup_to_master($slave_dbh, $master_dbh, $timeout);
3274                                                  
3275  ***      0                                  0      my $slave_status  = $self->get_slave_status($slave_dbh);
3276  ***      0                                  0      my $master_status = $self->get_master_status($master_dbh);
3277  ***      0      0                           0      if ( $self->pos_cmp(
3278                                                           $self->repl_posn($slave_status),
3279                                                           $self->repl_posn($master_status)) != 0 )
3280                                                     {
3281  ***      0                                  0         die "The slave is not caught up to its master";
3282                                                     }
3283                                                  
3284  ***      0                                  0      $unc_master_stat = $self->get_master_status($unc_dbh);
3285  ***      0                                  0      $self->change_master_to($slave_dbh, $unc_dsn,
3286                                                        $self->repl_posn($unc_master_stat));
3287                                                  
3288                                                  
3289  ***      0                                  0      $slave_status    = $self->get_slave_status($slave_dbh);
3290  ***      0                                  0      my $slave_pos    = $self->repl_posn($slave_status);
3291  ***      0      0      0                    0      if ( $self->short_host($slave_status) ne $self->short_host($unc_dsn)
3292                                                       || $self->pos_cmp($self->repl_posn($unc_master_stat), $slave_pos) != 0)
3293                                                     {
3294  ***      0                                  0         die "After changing the slave's master, it isn't a slave of the uncle, "
3295                                                           . "or it has a different replication position than the uncle";
3296                                                     }
3297                                                  }
3298                                                  
3299                                                  sub detach_slave {
3300  ***      0                    0             0      my ( $self, $dbh ) = @_;
3301  ***      0                                  0      $self->stop_slave($dbh);
3302  ***      0      0                           0      my $stat = $self->get_slave_status($dbh)
3303                                                        or die "This server is not a slave";
3304  ***      0                                  0      $dbh->do('CHANGE MASTER TO MASTER_HOST=""');
3305  ***      0                                  0      $dbh->do('RESET SLAVE'); # Wipes out master.info, etc etc
3306  ***      0                                  0      return $stat;
3307                                                  }
3308                                                  
3309                                                  sub slave_is_running {
3310  ***      0                    0             0      my ( $self, $slave_status ) = @_;
3311  ***      0             0                    0      return ($slave_status->{slave_sql_running} || 'No') eq 'Yes';
3312                                                  }
3313                                                  
3314                                                  sub has_slave_updates {
3315  ***      0                    0             0      my ( $self, $dbh ) = @_;
3316  ***      0                                  0      my $sql = q{SHOW VARIABLES LIKE 'log_slave_updates'};
3317  ***      0                                  0      MKDEBUG && _d($dbh, $sql);
3318  ***      0                                  0      my ($name, $value) = $dbh->selectrow_array($sql);
3319  ***      0             0                    0      return $value && $value =~ m/^(1|ON)$/;
3320                                                  }
3321                                                  
3322                                                  sub repl_posn {
3323  ***      0                    0             0      my ( $self, $status ) = @_;
3324  ***      0      0      0                    0      if ( exists $status->{file} && exists $status->{position} ) {
3325                                                        return {
3326  ***      0                                  0            file     => $status->{file},
3327                                                           position => $status->{position},
3328                                                        };
3329                                                     }
3330                                                     else {
3331                                                        return {
3332  ***      0                                  0            file     => $status->{relay_master_log_file},
3333                                                           position => $status->{exec_master_log_pos},
3334                                                        };
3335                                                     }
3336                                                  }
3337                                                  
3338                                                  sub get_slave_lag {
3339  ***      0                    0             0      my ( $self, $dbh ) = @_;
3340  ***      0                                  0      my $stat = $self->get_slave_status($dbh);
3341  ***      0                                  0      return $stat->{seconds_behind_master};
3342                                                  }
3343                                                  
3344                                                  sub pos_cmp {
3345  ***      0                    0             0      my ( $self, $a, $b ) = @_;
3346  ***      0                                  0      return $self->pos_to_string($a) cmp $self->pos_to_string($b);
3347                                                  }
3348                                                  
3349                                                  sub short_host {
3350  ***      0                    0             0      my ( $self, $dsn ) = @_;
3351  ***      0                                  0      my ($host, $port);
3352  ***      0      0                           0      if ( $dsn->{master_host} ) {
3353  ***      0                                  0         $host = $dsn->{master_host};
3354  ***      0                                  0         $port = $dsn->{master_port};
3355                                                     }
3356                                                     else {
3357  ***      0                                  0         $host = $dsn->{h};
3358  ***      0                                  0         $port = $dsn->{P};
3359                                                     }
3360  ***      0      0      0                    0      return ($host || '[default]') . ( ($port || 3306) == 3306 ? '' : ":$port" );
      ***                    0                        
3361                                                  }
3362                                                  
3363                                                  sub is_replication_thread {
3364  ***      0                    0             0      my ( $self, $query, %args ) = @_; 
3365  ***      0      0                           0      return unless $query;
3366                                                  
3367  ***      0             0                    0      my $type = lc $args{type} || 'all';
3368  ***      0      0                           0      die "Invalid type: $type"
3369                                                        unless $type =~ m/^binlog_dump|slave_io|slave_sql|all$/i;
3370                                                  
3371  ***      0                                  0      my $match = 0;
3372  ***      0      0                           0      if ( $type =~ m/binlog_dump|all/i ) {
3373  ***      0      0      0                    0         $match = 1
      ***                    0                        
3374                                                           if ($query->{Command} || $query->{command} || '') eq "Binlog Dump";
3375                                                     }
3376  ***      0      0                           0      if ( !$match ) {
3377  ***      0      0      0                    0         if ( ($query->{User} || $query->{user} || '') eq "system user" ) {
      ***                    0                        
3378  ***      0                                  0            MKDEBUG && _d("Slave replication thread");
3379  ***      0      0                           0            if ( $type ne 'all' ) { 
3380  ***      0             0                    0               my $state = $query->{State} || $query->{state} || '';
      ***                    0                        
3381                                                  
3382  ***      0      0                           0               if ( $state =~ m/^init|end$/ ) {
3383  ***      0                                  0                  MKDEBUG && _d("Special state:", $state);
3384  ***      0                                  0                  $match = 1;
3385                                                              }
3386                                                              else {
3387  ***      0                                  0                  my ($slave_sql) = $state =~ m/
3388                                                                    ^(Waiting\sfor\sthe\snext\sevent
3389                                                                     |Reading\sevent\sfrom\sthe\srelay\slog
3390                                                                     |Has\sread\sall\srelay\slog;\swaiting
3391                                                                     |Making\stemp\sfile
3392                                                                     |Waiting\sfor\sslave\smutex\son\sexit)/xi; 
3393                                                  
3394  ***      0      0      0                    0                  $match = $type eq 'slave_sql' &&  $slave_sql ? 1
      ***             0      0                        
3395                                                                        : $type eq 'slave_io'  && !$slave_sql ? 1
3396                                                                        :                                       0;
3397                                                              }
3398                                                           }
3399                                                           else {
3400  ***      0                                  0               $match = 1;
3401                                                           }
3402                                                        }
3403                                                        else {
3404  ***      0                                  0            MKDEBUG && _d('Not system user');
3405                                                        }
3406                                                  
3407  ***      0      0      0                    0         if ( !defined $args{check_known_ids} || $args{check_known_ids} ) {
3408  ***      0             0                    0            my $id = $query->{Id} || $query->{id};
3409  ***      0      0                           0            if ( $match ) {
3410  ***      0                                  0               $self->{replication_thread}->{$id} = 1;
3411                                                           }
3412                                                           else {
3413  ***      0      0                           0               if ( $self->{replication_thread}->{$id} ) {
3414  ***      0                                  0                  MKDEBUG && _d("Thread ID is a known replication thread ID");
3415  ***      0                                  0                  $match = 1;
3416                                                              }
3417                                                           }
3418                                                        }
3419                                                     }
3420                                                  
3421  ***      0                                  0      MKDEBUG && _d('Matches', $type, 'replication thread:',
3422                                                        ($match ? 'yes' : 'no'), '; match:', $match);
3423                                                  
3424  ***      0                                  0      return $match;
3425                                                  }
3426                                                  
3427                                                  
3428                                                  sub get_replication_filters {
3429  ***      0                    0             0      my ( $self, %args ) = @_;
3430  ***      0                                  0      my @required_args = qw(dbh);
3431  ***      0                                  0      foreach my $arg ( @required_args ) {
3432  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
3433                                                     }
3434  ***      0                                  0      my ($dbh) = @args{@required_args};
3435                                                  
3436  ***      0                                  0      my %filters = ();
3437                                                  
3438  ***      0                                  0      my $status = $self->get_master_status($dbh);
3439  ***      0      0                           0      if ( $status ) {
3440  ***      0      0                           0         map { $filters{$_} = $status->{$_} }
      ***      0                                  0   
3441  ***      0                                  0         grep { defined $status->{$_} && $status->{$_} ne '' }
3442                                                        qw(
3443                                                           binlog_do_db
3444                                                           binlog_ignore_db
3445                                                        );
3446                                                     }
3447                                                  
3448  ***      0                                  0      $status = $self->get_slave_status($dbh);
3449  ***      0      0                           0      if ( $status ) {
3450  ***      0      0                           0         map { $filters{$_} = $status->{$_} }
      ***      0                                  0   
3451  ***      0                                  0         grep { defined $status->{$_} && $status->{$_} ne '' }
3452                                                        qw(
3453                                                           replicate_do_db
3454                                                           replicate_ignore_db
3455                                                           replicate_do_table
3456                                                           replicate_ignore_table 
3457                                                           replicate_wild_do_table
3458                                                           replicate_wild_ignore_table
3459                                                        );
3460                                                  
3461  ***      0                                  0         my $sql = "SHOW VARIABLES LIKE 'slave_skip_errors'";
3462  ***      0                                  0         MKDEBUG && _d($dbh, $sql);
3463  ***      0                                  0         my $row = $dbh->selectrow_arrayref($sql);
3464  ***      0      0      0                    0         $filters{slave_skip_errors} = $row->[1] if $row->[1] && $row->[1] ne 'OFF';
3465                                                     }
3466                                                  
3467  ***      0                                  0      return \%filters; 
3468                                                  }
3469                                                  
3470                                                  
3471                                                  sub pos_to_string {
3472  ***      0                    0             0      my ( $self, $pos ) = @_;
3473  ***      0                                  0      my $fmt  = '%s/%020d';
3474  ***      0                                  0      return sprintf($fmt, @{$pos}{qw(file position)});
      ***      0                                  0   
3475                                                  }
3476                                                  
3477                                                  sub reset_known_replication_threads {
3478  ***      0                    0             0      my ( $self ) = @_;
3479  ***      0                                  0      $self->{replication_thread} = {};
3480  ***      0                                  0      return;
3481                                                  }
3482                                                  
3483                                                  sub _d {
3484  ***      0                    0             0      my ($package, undef, $line) = caller 0;
3485  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
3486  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
3487                                                          @_;
3488  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
3489                                                  }
3490                                                  
3491                                                  1;
3492                                                  
3493                                                  # ###########################################################################
3494                                                  # End MasterSlave package
3495                                                  # ###########################################################################
3496                                                  
3497                                                  # ###########################################################################
3498                                                  # This is a combination of modules and programs in one -- a runnable module.
3499                                                  # http://www.perl.com/pub/a/2006/07/13/lightning-articles.html?page=last
3500                                                  # Or, look it up in the Camel book on pages 642 and 643 in the 3rd edition.
3501                                                  #
3502                                                  # Check at the end of this package for the call to main() which actually runs
3503                                                  # the program.
3504                                                  # ###########################################################################
3505                                                  package mk_archiver;
3506                                                  
3507          21                   21           194   use English qw(-no_match_vars);
              21                                 65   
              21                                140   
3508          21                   21           156   use List::Util qw(max);
              21                                 50   
              21                                118   
3509          21                   21           139   use IO::File;
              21                                 55   
              21                                295   
3510          21                   21           260   use sigtrap qw(handler finish untrapped normal-signals);
              21                                 58   
              21                                181   
3511          21                   21           137   use Time::HiRes qw(gettimeofday sleep time);
              21                                 47   
              21                                169   
3512          21                   21           149   use Data::Dumper;
              21                                 64   
              21                                120   
3513                                                  $Data::Dumper::Indent    = 1;
3514                                                  $Data::Dumper::Quotekeys = 0;
3515                                                  
3516  ***     21            50     21           131   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              21                                 50   
              21                                357   
3517                                                  
3518                                                  # Global variables; as few as possible.
3519                                                  my $oktorun   = 1;
3520                                                  my $txn_cnt   = 0;
3521                                                  my $cnt       = 0;
3522                                                  my $can_retry = 1;
3523                                                  my $archive_fh;
3524                                                  my $get_sth;
3525                                                  my ( $OUT_OF_RETRIES, $ROLLED_BACK, $ALL_IS_WELL ) = ( 0, -1, 1 );
3526                                                  my ( $src, $dst );
3527                                                  
3528                                                  # Holds the arguments for the $sth's bind variables, so it can be re-tried
3529                                                  # easily.
3530                                                  my @beginning_of_txn;
3531                                                  my $vp = new VersionParser;
3532                                                  my $q  = new Quoter;
3533                                                  
3534                                                  sub main {
3535          43                   43        14693134      @ARGV = @_;  # set global ARGV for this package
3536                                                  
3537                                                     # Reset global vars else tests, which run this tool as a module,
3538                                                     # may encounter weird results.
3539          43                                388      $oktorun          = 1;
3540          43                                208      $txn_cnt          = 0;
3541          43                                171      $cnt              = 0;
3542          43                                226      $can_retry        = 1;
3543          43                                169      $archive_fh       = undef;
3544          43                                208      $get_sth          = undef;
3545          43                               1984      ($src, $dst)      = (undef, undef);
3546          43                               8612      @beginning_of_txn = ();
3547          43                               1275      undef *trace;
3548          43                                247      ($OUT_OF_RETRIES, $ROLLED_BACK, $ALL_IS_WELL ) = (0, -1, 1);
3549                                                  
3550                                                     # ########################################################################
3551                                                     # Get configuration information.
3552                                                     # ########################################################################
3553          43                               1198      my $o = new OptionParser();
3554          43                                452      $o->get_specs();
3555          43                               1789      $o->get_opts();
3556                                                  
3557          43                                293      my $dp = $o->DSNParser();
3558          43                                245      $dp->prop('set-vars', $o->get('set-vars'));
3559                                                  
3560                                                     # Frequently used options.
3561          43                                223      $src             = $o->get('source');
3562          43                                219      $dst             = $o->get('dest');
3563          43                                224      my $sentinel     = $o->get('sentinel');
3564          43                                230      my $bulk_del     = $o->get('bulk-delete');
3565          43                                225      my $commit_each  = $o->get('commit-each');
3566          43                                243      my $limit        = $o->get('limit');
3567          43                                217      my $archive_file = $o->get('file');
3568          43                                224      my $txnsize      = $o->get('txn-size');
3569          43                                233      my $quiet        = $o->get('quiet');
3570                                                  
3571                                                     # First things first: if --stop was given, create the sentinel file.
3572          43    100                         237      if ( $o->get('stop') ) {
3573  ***      1     50                          43         my $sentinel_fh = IO::File->new($sentinel, ">>")
3574                                                           or die "Cannot open $sentinel: $OS_ERROR\n";
3575  ***      1     50                         592         print $sentinel_fh "Remove this file to permit mk-archiver to run\n"
3576                                                           or die "Cannot write to $sentinel: $OS_ERROR\n";
3577  ***      1     50                          57         close $sentinel_fh
3578                                                           or die "Cannot close $sentinel: $OS_ERROR\n";
3579  ***      1     50                          15         print STDOUT "Successfully created file $sentinel\n"
3580                                                           unless $quiet;
3581           1                                  4         return 0;
3582                                                     }
3583                                                  
3584                                                     # Generate a filename with sprintf-like formatting codes.
3585          42    100                         228      if ( $archive_file ) {
3586           2                                149         my @time = localtime();
3587  ***      2     50     33                  132         my %fmt = (
      ***            50     33                        
3588                                                           d => sprintf('%02d', $time[3]),
3589                                                           H => sprintf('%02d', $time[2]),
3590                                                           i => sprintf('%02d', $time[1]),
3591                                                           m => sprintf('%02d', $time[4] + 1),
3592                                                           s => sprintf('%02d', $time[0]),
3593                                                           Y => $time[5] + 1900,
3594                                                           D => $src && $src->{D} ? $src->{D} : '',
3595                                                           t => $src && $src->{t} ? $src->{t} : '',
3596                                                        );
3597           2                                 56         $archive_file =~ s/%([dHimsYDt])/$fmt{$1}/g;
3598                                                     }
3599                                                  
3600  ***     42     50                         309      if ( !$o->got('help') ) {
3601  ***     42     50                         260         $o->save_error("--source DSN requires a 't' (table) part")
3602                                                           unless $src->{t};
3603                                                  
3604          42    100                         232         if ( $dst ) {
3605                                                           # Ensure --source and --dest don't point to the same place
3606          19                                 74            my $same = 1;
3607          19                                129            foreach my $arg ( qw(h P D t S) ) {
3608  ***     75    100     66                 1257               if ( defined $src->{$arg} && defined $dst->{$arg}
                           100                        
3609                                                                   && $src->{$arg} ne $dst->{$arg} ) {
3610          19                                 66                  $same = 0;
3611          19                                 77                  last;
3612                                                              }
3613                                                           }
3614  ***     19     50                         118            if ( $same ) {
3615  ***      0                                  0               $o->save_error("--source and --dest refer to the same table");
3616                                                           }
3617                                                        }
3618          42    100                         227         if ( $o->get('bulk-insert') ) {
3619  ***      2     50                          13            $o->save_error("--bulk-insert is meaningless without a destination")
3620                                                              unless $dst;
3621           2                                  7            $bulk_del = 1; # VERY IMPORTANT for safety.
3622                                                        }
3623  ***     42     50     66                  335         if ( $bulk_del && $limit < 2 ) {
3624  ***      0                                  0            $o->save_error("--bulk-delete is meaningless with --limit 1");
3625                                                        }
3626                                                  
3627                                                     }
3628                                                  
3629  ***     42    100     66                  562      if ( $bulk_del || $o->get('bulk-insert') ) {
3630           5                                 45         $o->set('commit-each', 1);
3631                                                     }
3632                                                  
3633          42                                384      $o->usage_or_errors();
3634                                                  
3635                                                     # ########################################################################
3636                                                     # If --pid, check it first since we'll die if it already exits.
3637                                                     # ########################################################################
3638          42                                144      my $daemon;
3639  ***     42     50                         258      if ( $o->get('pid') ) {
3640                                                        # We're not daemoninzing, it just handles PID stuff.  Keep $daemon
3641                                                        # in the the scope of main() because when it's destroyed it automatically
3642                                                        # removes the PID file.
3643  ***      0                                  0         $daemon = new Daemon(o=>$o);
3644  ***      0                                  0         $daemon->make_PID_file();
3645                                                     }
3646                                                        
3647                                                     # ########################################################################
3648                                                     # Set up statistics.
3649                                                     # ########################################################################
3650          42                                204      my %statistics = ();
3651          42                                138      my $stat_start;
3652                                                  
3653          42    100                         234      if ( $o->get('statistics') ) {
3654           7                                175         my $start    = gettimeofday();
3655           7                                 69         my $obs_cost = gettimeofday() - $start; # cost of observation
3656                                                  
3657                                                        *trace = sub {
3658  ***    701            66    701          6232            my ( $thing, $sub ) = @_;
3659         701                               5948            my $start = gettimeofday();
3660         701                               3753            $sub->();
3661         701                              11915            $statistics{$thing . '_time'}
3662                                                              += (gettimeofday() - $start - $obs_cost);
3663         701                               4702            ++$statistics{$thing . '_count'};
3664  ***    701            66                 6548            $stat_start ||= $start;
3665                                                        }
3666           7                                165      }
3667                                                     else { # Generate a version that doesn't do any timing
3668                                                        *trace = sub {
3669         262                  262          3169            my ( $thing, $sub ) = @_;
3670         262                               1569            $sub->();
3671                                                        }
3672          35                                733      }
3673                                                  
3674                                                     # ########################################################################
3675                                                     # Inspect DB servers and tables.
3676                                                     # ########################################################################
3677                                                  
3678          42                                752      my $tp = new TableParser(Quoter => $q);
3679          42                                651      my $du = new MySQLDump();
3680          42                                197      foreach my $table ( grep { $_ } ($src, $dst) ) {
              84                                434   
3681          61           100                  529         my $ac = !$txnsize && !$commit_each;
3682  ***     61     50     66                  868         if ( !defined $table->{p} && $o->get('ask-pass') ) {
3683  ***      0                                  0            $table->{p} = OptionParser::prompt_noecho("Enter password: ");
3684                                                        }
3685          61                                648         my $dbh = $dp->get_dbh(
3686                                                           $dp->get_cxn_params($table), { AutoCommit => $ac });
3687          61                                322         MKDEBUG && _d('Inspecting table on', $dp->as_string($table));
3688                                                  
3689                                                        # Set options that can enable removing data on the master and archiving it
3690                                                        # on the slaves.
3691  ***     61     50                         431         if ( $table->{a} ) {
3692  ***      0                                  0            $dbh->do("USE $table->{a}");
3693                                                        }
3694  ***     61     50                         359         if ( $table->{b} ) {
3695  ***      0                                  0            $dbh->do("SET SQL_LOG_BIN=0");
3696                                                        }
3697                                                  
3698          61                                325         $table->{dbh}  = $dbh;
3699          61                                619         $table->{irot} = get_irot($dbh);
3700                                                  
3701  ***     61            33                  805         $can_retry = $can_retry && !$table->{irot};
3702                                                  
3703         122                                855         $table->{db_tbl} = $q->quote(
3704         122                                903            map  { $_ =~ s/(^`|`$)//g; $_; }
             122                                575   
3705          61                                451            grep { $_ }
3706                                                           ( $table->{D}, $table->{t} )
3707                                                        );
3708                                                  
3709                                                        # Create objects for archivable and dependency handling, BEFORE getting
3710                                                        # the tbl structure (because the object might do some setup, including
3711                                                        # creating the table to be archived).
3712  ***     61     50                         414         if ( $table->{m} ) {
3713  ***      0                                  0            eval "require $table->{m}";
3714  ***      0      0                           0            die $EVAL_ERROR if $EVAL_ERROR;
3715                                                  
3716                                                           trace('plugin_start', sub {
3717  ***      0                    0             0               $table->{plugin} = $table->{m}->new(
3718                                                                 dbh          => $table->{dbh},
3719                                                                 db           => $table->{D},
3720                                                                 tbl          => $table->{t},
3721                                                                 OptionParser => $o,
3722                                                                 DSNParser    => $dp,
3723                                                                 Quoter       => $q,
3724                                                              );
3725  ***      0                                  0            });
3726                                                        }
3727                                                  
3728          61                                741         $table->{info} = $tp->parse(
3729                                                           $du->get_create_table($dbh, $q, $table->{D}, $table->{t}));
3730                                                     }
3731                                                  
3732          42    100    100                  457      if ( $o->get('primary-key-only')
3733                                                          && !exists $src->{info}->{keys}->{PRIMARY} ) {
3734           1                                 38         $src->{dbh}->disconnect();
3735  ***      1     50     33                    7         $dst->{dbh}->disconnect() if $dst && $dst->{dbh};
3736           1                                  4         die "--primary-key-only was specified by the --source table "
3737                                                           . "$src->{db_tbl} does not have a PRIMARY KEY";
3738                                                     }
3739                                                  
3740          41    100    100                  378      if ( $dst && $o->get('check-columns') ) {
3741          67                                398         my @not_in_src = grep {
3742          17                                111            !$src->{info}->{is_col}->{$_}
3743          17                                 61         } @{$dst->{info}->{cols}};
3744  ***     17     50                          98         if ( @not_in_src ) {
3745  ***      0                                  0            $src->{dbh}->disconnect();
3746  ***      0      0      0                    0            $dst->{dbh}->disconnect() if $dst && $dst->{dbh};
3747  ***      0                                  0            die "The following columns exist in --dest but not --source: "
3748                                                              . join(', ', @not_in_src)
3749                                                              . "\n";
3750                                                        }
3751          71                                393         my @not_in_dst = grep {
3752          17                                106            !$dst->{info}->{is_col}->{$_}
3753          17                                 64         } @{$src->{info}->{cols}};
3754          17    100                          98         if ( @not_in_dst ) {
3755           2                                101            $src->{dbh}->disconnect();
3756  ***      2     50     33                   78            $dst->{dbh}->disconnect() if $dst && $dst->{dbh};
3757           2                                  7            die "The following columns exist in --source but not --dest: "
3758                                                              . join(', ', @not_in_dst)
3759                                                              . "\n";
3760                                                        }
3761                                                     }
3762                                                  
3763                                                     # ########################################################################
3764                                                     # Get lag dbh.
3765                                                     # ########################################################################
3766          39                                125      my $lag_dbh;
3767          39                                122      my $ms;
3768  ***     39     50                         205      if ( $o->get('check-slave-lag') ) {
3769  ***      0                                  0         my $dsn_defaults = $dp->parse_options($o);
3770  ***      0                                  0         my $dsn  = $dp->parse($o->get('check-slave-lag'), $dsn_defaults);
3771  ***      0                                  0         $lag_dbh = $dp->get_dbh($dp->get_cxn_params($dsn), { AutoCommit => 1 });
3772  ***      0                                  0         $ms      = new MasterSlave(VersionParser => $vp);
3773                                                     }
3774                                                  
3775                                                     # ########################################################################
3776                                                     # Set up general plugin.
3777                                                     # ########################################################################
3778          39                                188      my $plugin;
3779  ***     39     50                         228      if ( $o->get('plugin') ) {
3780  ***      0                                  0         eval "require " . $o->get('plugin');
3781  ***      0      0                           0         die $EVAL_ERROR if $EVAL_ERROR;
3782  ***      0                                  0         $plugin = $o->get('plugin')->new(
3783                                                           src  => $src,
3784                                                           dst  => $dst,
3785                                                           opts => $o,
3786                                                        );
3787                                                     }
3788                                                  
3789                                                     # ########################################################################
3790                                                     # Design SQL statements.
3791                                                     # ########################################################################
3792          39                                200      my $dbh = $src->{dbh};
3793          39                                685      my $nibbler = new TableNibbler(
3794                                                        TableParser => $tp,
3795                                                        Quoter      => $q,
3796                                                     );
3797          39                                164      my ($first_sql, $next_sql, $del_sql, $ins_sql);
3798          39                                140      my ($sel_stmt, $ins_stmt, $del_stmt);
3799          39                                176      my (@asc_slice, @sel_slice, @del_slice, @bulkdel_slice, @ins_slice);
3800           3                                 26      my @sel_cols = $o->get('columns')          ? @{$o->get('columns')}    # Explicit
               1                                  7   
3801          35                                368                   : $o->get('primary-key-only') ? @{$src->{info}->{keys}->{PRIMARY}->{cols}} 
3802          39    100                         200                   :                               @{$src->{info}->{cols}}; # All
                    100                               
3803          39                                145      MKDEBUG && _d("sel cols: ", @sel_cols);
3804                                                  
3805          39                                536      $del_stmt = $nibbler->generate_del_stmt(
3806                                                        tbl_struct => $src->{info},
3807                                                        cols       => \@sel_cols,
3808                                                        index      => $src->{i},
3809                                                     );
3810          39                                141      @del_slice = @{$del_stmt->{slice}};
              39                                219   
3811                                                  
3812                                                     # Generate statement for ascending index, if desired
3813          39    100                         223      if ( !$o->get('no-ascend') ) {
3814  ***     36      0                         312         $sel_stmt = $nibbler->generate_asc_stmt(
      ***            50                               
                    100                               
3815                                                           tbl_struct => $src->{info},
3816                                                           cols       => $del_stmt->{cols},
3817                                                           index      => $del_stmt->{index},
3818                                                           asc_first  => $o->get('ascend-first'),
3819                                                           # A plugin might prevent rows in the source from being deleted
3820                                                           # when doing single delete, but it cannot prevent rows from
3821                                                           # being deleted when doing a bulk delete.
3822                                                           asc_only   => $o->get('no-delete') ?  1
3823                                                                      : $src->{m}             ? ($o->get('bulk-delete') ? 0 : 1)
3824                                                                      :                          0,
3825                                                        )
3826                                                     }
3827                                                     else {
3828           3                                 30         $sel_stmt = {
3829                                                           cols  => $del_stmt->{cols},
3830                                                           index => undef,
3831                                                           where => '1=1',
3832                                                           slice => [], # No-ascend = no bind variables in the WHERE clause.
3833                                                           scols => [], # No-ascend = no bind variables in the WHERE clause.
3834                                                        };
3835                                                     }
3836          39                                144      @asc_slice = @{$sel_stmt->{slice}};
              39                                222   
3837          39                                306      @sel_slice = 0..$#sel_cols;
3838                                                  
3839         149                                684      $first_sql
3840                                                        = 'SELECT' . ( $o->get('high-priority-select') ? ' HIGH_PRIORITY' : '' )
3841                                                        . ' /*!40001 SQL_NO_CACHE */ '
3842          39    100                         216         . join(',', map { $q->quote($_) } @{$sel_stmt->{cols}} )
      ***     39     50                         220   
                    100                               
3843                                                        . " FROM $src->{db_tbl}"
3844                                                        . ( $sel_stmt->{index}
3845                                                           ? (($vp->version_ge($dbh, '4.0.9') ? " FORCE" : " USE")
3846                                                              . " INDEX(`$sel_stmt->{index}`)")
3847                                                           : '')
3848                                                        . " WHERE (".$o->get('where').")";
3849                                                  
3850          39    100    100                  240      if ( $o->get('safe-auto-increment')
      ***     35            66                  862   
                           100                        
3851                                                           && $sel_stmt->{index}
3852                                                           && scalar(@{$src->{info}->{keys}->{$sel_stmt->{index}}->{cols}}) == 1
3853                                                           && $src->{info}->{is_autoinc}->{
3854                                                              $src->{info}->{keys}->{$sel_stmt->{index}}->{cols}->[0]
3855                                                           }
3856                                                     ) {
3857           6                                 32         my $col = $q->quote($sel_stmt->{scols}->[0]);
3858           6                                 19         my ($val) = $dbh->selectrow_array("SELECT MAX($col) FROM $src->{db_tbl}");
3859           6                               1299         $first_sql .= " AND ($col < " . $q->quote_val($val) . ")";
3860                                                     }
3861                                                  
3862          39                                173      $next_sql = $first_sql;
3863          39    100                         229      if ( !$o->get('no-ascend') ) {
3864          36                                201         $next_sql .= " AND $sel_stmt->{where}";
3865                                                     }
3866                                                  
3867          39                                212      foreach my $thing ( $first_sql, $next_sql ) {
3868          78                                329         $thing .= " LIMIT $limit";
3869          78    100                         352         if ( $o->get('for-update') ) {
                    100                               
3870           2                                  8            $thing .= ' FOR UPDATE';
3871                                                        }
3872                                                        elsif ( $o->get('share-lock') ) {
3873           2                                  9            $thing .= ' LOCK IN SHARE MODE';
3874                                                        }
3875                                                     }
3876                                                  
3877          39                                131      MKDEBUG && _d("Index for DELETE:", $del_stmt->{index});
3878          39    100                         202      if ( !$bulk_del ) {
3879                                                        # The LIMIT might be 1 here, because even though a SELECT can return
3880                                                        # many rows, an INSERT only does one at a time.  It would not be safe to
3881                                                        # iterate over a SELECT that was LIMIT-ed to 500 rows, read and INSERT
3882                                                        # one, and then delete with a LIMIT of 500.  Only one row would be written
3883                                                        # to the file; only one would be INSERT-ed at the destination.  But
3884                                                        # LIMIT 1 is actually only needed when the index is not unique
3885                                                        # (http://code.google.com/p/maatkit/issues/detail?id=1166).
3886          34    100                         166         $del_sql = 'DELETE'
                    100                               
3887                                                           . ($o->get('low-priority-delete') ? ' LOW_PRIORITY' : '')
3888                                                           . ($o->get('quick-delete')        ? ' QUICK'        : '')
3889                                                           . " FROM $src->{db_tbl} WHERE $del_stmt->{where}";
3890                                                  
3891          34    100                         294            if ( $src->{info}->{keys}->{$del_stmt->{index}}->{is_unique} ) {
3892          33                                114               MKDEBUG && _d("DELETE index is unique; LIMIT 1 is not needed");
3893                                                           }
3894                                                           else {
3895           1                                  2               MKDEBUG && _d("Adding LIMIT 1 to DELETE because DELETE index "
3896                                                                 . "is not unique");
3897           1                                  4               $del_sql .= " LIMIT 1";
3898                                                           }
3899                                                     }
3900                                                     else {
3901                                                        # Unless, of course, it's a bulk DELETE, in which case the 500 rows have
3902                                                        # already been INSERT-ed.
3903           5                                 53         my $asc_stmt = $nibbler->generate_asc_stmt(
3904                                                           tbl_struct => $src->{info},
3905                                                           cols       => $del_stmt->{cols},
3906                                                           index      => $del_stmt->{index},
3907                                                           asc_first  => 0,
3908                                                        );
3909  ***      5     50                          32         $del_sql = 'DELETE'
      ***            50                               
                    100                               
3910                                                           . ($o->get('low-priority-delete') ? ' LOW_PRIORITY' : '')
3911                                                           . ($o->get('quick-delete')        ? ' QUICK'        : '')
3912                                                           . " FROM $src->{db_tbl} WHERE ("
3913                                                           . $asc_stmt->{boundaries}->{'>='}
3914                                                           . ') AND (' . $asc_stmt->{boundaries}->{'<='}
3915                                                           # Unlike the row-at-a-time DELETE, this one must include the user's
3916                                                           # specified WHERE clause and an appropriate LIMIT clause.
3917                                                           . ") AND (".$o->get('where').")"
3918                                                           . ($o->get('bulk-delete-limit') ? " LIMIT $limit" : "");
3919           5                                 22         @bulkdel_slice = @{$asc_stmt->{slice}};
               5                                 51   
3920                                                     }
3921                                                  
3922          39    100                         177      if ( $dst ) {
3923          17                                183         $ins_stmt = $nibbler->generate_ins_stmt(
3924                                                           ins_tbl  => $dst->{info},
3925                                                           sel_cols => \@sel_cols,
3926                                                        );
3927          17                                 55         MKDEBUG && _d("inst stmt: ", Dumper($ins_stmt));
3928          17                                 58         @ins_slice = @{$ins_stmt->{slice}};
              17                                106   
3929          17    100                          88         if ( $o->get('bulk-insert') ) {
3930          12                                 66            $ins_sql = 'LOAD DATA'
3931                                                                    . ($o->get('low-priority-insert') ? ' LOW_PRIORITY' : '')
3932                                                                    . ' LOCAL INFILE ?'
3933                                                                    . ($o->get('replace')    ? ' REPLACE'      : '')
3934                                                                    . ($o->get('ignore')     ? ' IGNORE'       : '')
3935                                                                    . " INTO TABLE $dst->{db_tbl}("
3936  ***      2     50                          12                     . join(",", map { $q->quote($_) } @{$ins_stmt->{cols}} )
      ***      2     50                          12   
      ***            50                               
3937                                                                    . ")";
3938                                                        }
3939                                                        else {
3940          51                                209            $ins_sql = ($o->get('replace')             ? 'REPLACE'      : 'INSERT')
3941                                                                    . ($o->get('low-priority-insert') ? ' LOW_PRIORITY' : '')
3942                                                                    . ($o->get('delayed-insert')      ? ' DELAYED'      : '')
3943                                                                    . ($o->get('ignore')              ? ' IGNORE'       : '')
3944                                                                    . " INTO $dst->{db_tbl}("
3945          15                                 79                     . join(",", map { $q->quote($_) } @{$ins_stmt->{cols}} )
              51                                211   
3946                                                                    . ") VALUES ("
3947          15    100                         101                     . join(",", map { "?" } @{$ins_stmt->{cols}} ) . ")";
              15    100                          76   
                    100                               
      ***            50                               
3948                                                        }
3949                                                     }
3950                                                     else {
3951          22                                 95         $ins_sql = '';
3952                                                     }
3953                                                  
3954          39                                135      if ( MKDEBUG ) {
3955                                                        _d("get first sql:", $first_sql);
3956                                                        _d("get next sql:", $next_sql);
3957                                                        _d("del row sql:", $del_sql);
3958                                                        _d("ins row sql:", $ins_sql);
3959                                                     }
3960                                                     
3961          39    100                         241      if ( $o->get('dry-run') ) {
3962  ***     17     50                          83         if ( !$quiet ) {
3963  ***     17    100     50                  183            print join("\n", grep { $_ } ($archive_file || ''),
              85                                416   
3964                                                                    $first_sql, $next_sql,
3965                                                                    ($o->get('no-delete') ? '' : $del_sql), $ins_sql)
3966                                                              , "\n";
3967                                                        }
3968          17                               1075         $src->{dbh}->disconnect();
3969  ***     17    100     66                  277         $dst->{dbh}->disconnect() if $dst && $dst->{dbh};
3970          17                               3650         return 0;
3971                                                     }
3972                                                  
3973          22                                 80      my $get_first = $dbh->prepare($first_sql);
3974          22                                 63      my $get_next  = $dbh->prepare($next_sql);
3975          22                                 55      my $del_row   = $dbh->prepare($del_sql);
3976          22    100                         158      my $ins_row   = $dst->{dbh}->prepare($ins_sql) if $dst; # Different $dbh!
3977                                                  
3978                                                     # ########################################################################
3979                                                     # Set MySQL options.
3980                                                     # ########################################################################
3981                                                  
3982  ***     22     50                         174      if ( $o->get('skip-foreign-key-checks') ) {
3983  ***      0                                  0         $src->{dbh}->do("/*!40014 SET FOREIGN_KEY_CHECKS=0 */");
3984  ***      0      0                           0         if ( $dst ) {
3985  ***      0                                  0            $dst->{dbh}->do("/*!40014 SET FOREIGN_KEY_CHECKS=0 */");
3986                                                        }
3987                                                     }
3988                                                  
3989                                                     # ########################################################################
3990                                                     # Set up the plugins
3991                                                     # ########################################################################
3992          22                                159      foreach my $table ( $dst, $src ) {
3993  ***     44     50     66                  677         next unless $table && $table->{plugin};
3994                                                        trace ('before_begin', sub {
3995  ***      0                    0             0            $table->{plugin}->before_begin(
3996                                                              cols    => \@sel_cols,
3997                                                              allcols => $sel_stmt->{cols},
3998                                                           );
3999  ***      0                                  0         });
4000                                                     }
4001                                                  
4002                                                     # ########################################################################
4003                                                     # Start archiving.
4004                                                     # ########################################################################
4005          22                                327      my $start   = time();
4006  ***     22            50                  132      my $end     = $start + ($o->get('run-time') || 0); # When to exit
4007          22                                 92      my $now     = $start;
4008          22                                 72      my $last_select_time;  # for --sleep-coef
4009          22                                140      my $retries = $o->get('retries');
4010  ***     22     50     33                  149      printf("%-19s %7s %7s\n", 'TIME', 'ELAPSED', 'COUNT')
4011                                                        if $o->get('progress') && !$quiet;
4012  ***     22     50     33                  136      printf("%19s %7d %7d\n", ts($now), $now - $start, $cnt)
4013                                                        if $o->get('progress') && !$quiet;
4014                                                  
4015          22                                 92      $get_sth = $get_first; # Later it may be assigned $get_next
4016                                                     trace('select', sub {
4017          22                   22           160         my $select_start = time;
4018          22                               7627         $get_sth->execute;
4019          22                                218         $last_select_time = time - $select_start;
4020          22                                639         $statistics{SELECT} += $get_sth->rows;
4021          22                                435      });
4022          22                                549      my $row = $get_sth->fetchrow_arrayref();
4023          22                                 87      MKDEBUG && _d("First row: ", Dumper($row), 'rows:', $get_sth->rows);
4024          22    100                         153      if ( !$row ) {
4025           1                                 16         $get_sth->finish;
4026           1                                 34         $src->{dbh}->disconnect();
4027  ***      1     50     33                   10         $dst->{dbh}->disconnect() if $dst && $dst->{dbh};
4028           1                                272         return 0;
4029                                                     }
4030                                                  
4031                                                     # Open the file and print the header to it.
4032          21    100                         146      if ( $archive_file ) {
4033  ***      2            66                   11         my $need_hdr = $o->get('header') && !-f $archive_file;
4034  ***      2     50                          60         $archive_fh = IO::File->new($archive_file, ">>")
4035                                                           or die "Cannot open $archive_file: $OS_ERROR\n";
4036  ***      2     50                         758         $archive_fh->autoflush(1) unless $o->get('buffer');
4037           2    100                          49         if ( $need_hdr ) {
4038  ***      1     50                          18            print $archive_fh '', escape(\@sel_cols), "\n"
4039                                                              or die "Cannot write to $archive_file: $OS_ERROR\n";
4040                                                        }
4041                                                     }
4042                                                  
4043                                                     # Open the bulk insert file, which doesn't get any header info.
4044          21                                126      my $bulkins_file;
4045          21    100                         140      if ( $o->get('bulk-insert') ) {
4046           2                                 38         require File::Temp;
4047  ***      2     50                          21         $bulkins_file = File::Temp->new( SUFFIX => 'mk-archiver' )
4048                                                           or die "Cannot open temp file: $OS_ERROR\n";
4049                                                     }
4050                                                  
4051                                                     # This row is the first row fetched from each 'chunk'.
4052          21                                182      my $first_row = [ @$row ];
4053          21                                 89      my $csv_row;
4054                                                  
4055                                                     ROW:
4056  ***     21            66                  572      while (                                 # Quit if:
      ***                   33                        
      ***                   66                        
                           100                        
      ***                   66                        
4057                                                        $row                                 # There is no data
4058                                                        && $retries >= 0                     # or retries are exceeded
4059                                                        && (!$o->get('run-time') || $now < $end) # or time is exceeded
4060                                                        && !-f $sentinel                     # or the sentinel is set
4061                                                        && $oktorun                          # or instructed to quit
4062                                                        )
4063                                                     {
4064         281                               1361         my $lastrow = $row;
4065                                                  
4066  ***    281     50     33                 3012         if ( !$src->{plugin}
4067                                                           || trace('is_archivable', sub {
4068  ***      0                    0             0               $src->{plugin}->is_archivable(row => $row)
4069                                                           })
4070                                                        ) {
4071                                                  
4072                                                           # Do the archiving.  Write to the file first since, like the file,
4073                                                           # MyISAM and other tables cannot be rolled back etc.  If there is a
4074                                                           # problem, hopefully the data has at least made it to the file.
4075         281                               1048            my $escaped_row;
4076         281    100    100                 2711            if ( $archive_fh || $bulkins_file ) {
4077         122                                797               $escaped_row = escape([@{$row}[@sel_slice]]);
             122                               1458   
4078                                                           }
4079         281    100                        2215            if ( $archive_fh ) {
4080                                                              trace('print_file', sub {
4081  ***      8     50             8           373                  print $archive_fh $escaped_row, "\n"
4082                                                                    or die "Cannot write to $archive_file: $OS_ERROR\n";
4083           8                                136               });
4084                                                           }
4085                                                  
4086                                                           # ###################################################################
4087                                                           # This code is for the row-at-a-time archiving functionality.
4088                                                           # ###################################################################
4089                                                           # INSERT must come first, to be as safe as possible.
4090         281    100    100                 2502            if ( $dst && !$bulkins_file ) {
4091         131                                530               my $ins_sth; # Let plugin change which sth is used for the INSERT.
4092  ***    131     50                        1033               if ( $dst->{plugin} ) {
4093                                                                 trace('before_insert', sub {
4094  ***      0                    0             0                     $dst->{plugin}->before_insert(row => $row);
4095  ***      0                                  0                  });
4096                                                                 trace('custom_sth', sub {
4097  ***      0                    0             0                     $ins_sth = $dst->{plugin}->custom_sth(
4098                                                                       row => $row, sql => $ins_sql);
4099  ***      0                                  0                  });
4100                                                              }
4101  ***    131            33                  924               $ins_sth ||= $ins_row; # Default to the sth decided before.
4102                                                              my $success = do_with_retries($o, 'inserting', sub {
4103         131                  131           851                  $ins_sth->execute(@{$row}[@ins_slice]);
             131                             920469   
4104         131                                752                  MKDEBUG && _d('Inserted', $del_row->rows, 'rows');
4105         131                               4331                  $statistics{INSERT} += $ins_sth->rows;
4106         131                               2777               });
4107  ***    131     50                        2310               if ( $success == $OUT_OF_RETRIES ) {
      ***            50                               
4108  ***      0                                  0                  $retries = -1;
4109  ***      0                                  0                  last ROW;
4110                                                              }
4111                                                              elsif ( $success == $ROLLED_BACK ) {
4112  ***      0                                  0                  --$retries;
4113  ***      0                                  0                  next ROW;
4114                                                              }
4115                                                           }
4116                                                  
4117         281    100                        2782            if ( !$bulk_del ) {
4118                                                              # DELETE comes after INSERT for safety.
4119  ***     62     50                         461               if ( $src->{plugin} ) {
4120                                                                 trace('before_delete', sub {
4121  ***      0                    0             0                     $src->{plugin}->before_delete(row => $row);
4122  ***      0                                  0                  });
4123                                                              }
4124          62    100                         462               if ( !$o->get('no-delete') ) {
4125                                                                 my $success = do_with_retries($o, 'deleting', sub {
4126          58                   58           308                     $del_row->execute(@{$row}[@del_slice]);
              58                             601892   
4127          58                                296                     MKDEBUG && _d('Deleted', $del_row->rows, 'rows');
4128          58                               1683                     $statistics{DELETE} += $del_row->rows;
4129          58                               1121                  });
4130  ***     58     50                         964                  if ( $success == $OUT_OF_RETRIES ) {
      ***            50                               
4131  ***      0                                  0                     $retries = -1;
4132  ***      0                                  0                     last ROW;
4133                                                                 }
4134                                                                 elsif ( $success == $ROLLED_BACK ) {
4135  ***      0                                  0                     --$retries;
4136  ***      0                                  0                     next ROW;
4137                                                                 }
4138                                                              }
4139                                                           }
4140                                                  
4141                                                           # ###################################################################
4142                                                           # This code is for the bulk archiving functionality.
4143                                                           # ###################################################################
4144         281    100                        1474            if ( $bulkins_file ) {
4145                                                              trace('print_bulkfile', sub {
4146  ***    114     50           114          1109                  print $bulkins_file $escaped_row, "\n"
4147                                                                    or die "Cannot write to bulk file: $OS_ERROR\n";
4148         114                               1572               });
4149                                                           }
4150                                                  
4151                                                        }  # row is archivable
4152                                                  
4153         281                               2960         $now = time();
4154         281                               1052         ++$cnt;
4155         281                               1077         ++$txn_cnt;
4156         281                               1904         $retries = $o->get('retries');
4157                                                  
4158                                                        # Possibly flush the file and commit the insert and delete.
4159         281    100                        2555         commit($o) unless $commit_each;
4160                                                  
4161                                                        # Report on progress.
4162  ***    281     50     33                 5477         if ( !$quiet && $o->get('progress') && $cnt % $o->get('progress') == 0 ) {
      ***                   33                        
4163  ***      0                                  0            printf("%19s %7d %7d\n", ts($now), $now - $start, $cnt);
4164                                                        }
4165                                                  
4166                                                        # Get the next row in this chunk.
4167                                                        # First time through this loop $get_sth is set to $get_first.
4168                                                        # For non-bulk operations this means that rows ($row) are archived
4169                                                        # one-by-one in in the code block above ("row is archivable").  For
4170                                                        # bulk operations, the 2nd to 2nd-to-last rows are ignored and
4171                                                        # only the first row ($first_row) and the last row ($last_row) of
4172                                                        # this chunk are used to do bulk INSERT or DELETE on the range of
4173                                                        # rows between first and last.  After the bulk ops, $first_row and
4174                                                        # $last_row are reset to the next chunk.
4175  ***    281     50                        5531         if ( $get_sth->{Active} ) { # Fetch until exhausted
4176         281                               8037            $row = $get_sth->fetchrow_arrayref();
4177                                                        }
4178         281    100                        2151         if ( !$row ) {
4179          71                                277            MKDEBUG && _d('No more rows in this chunk; doing bulk operations');
4180                                                  
4181                                                           # ###################################################################
4182                                                           # This code is for the bulk archiving functionality.
4183                                                           # ###################################################################
4184          71    100                         435            if ( $bulkins_file ) {
4185  ***      6     50                          68               $bulkins_file->close()
4186                                                                 or die "Cannot close bulk insert file: $OS_ERROR\n";
4187           6                                444               my $ins_sth; # Let plugin change which sth is used for the INSERT.
4188  ***      6     50                          40               if ( $dst->{plugin} ) {
4189                                                                 trace('before_bulk_insert', sub {
4190  ***      0                    0             0                     $dst->{plugin}->before_bulk_insert(
4191                                                                       first_row => $first_row,
4192                                                                       last_row  => $lastrow,
4193                                                                       filename  => $bulkins_file->filename(),
4194                                                                    );
4195  ***      0                                  0                  });
4196                                                                 trace('custom_sth', sub {
4197  ***      0                    0             0                     $ins_sth = $dst->{plugin}->custom_sth_bulk(
4198                                                                       first_row => $first_row,
4199                                                                       last_row  => $lastrow,
4200                                                                       filename  => $bulkins_file->filename(),
4201                                                                       sql       => $ins_sql,
4202                                                                    );
4203  ***      0                                  0                  });
4204                                                              }
4205  ***      6            33                   32               $ins_sth ||= $ins_row; # Default to the sth decided before.
4206                                                              my $success = do_with_retries($o, 'bulk_inserting', sub {
4207           6                    6            33                  $ins_sth->execute($bulkins_file->filename());
4208           6                                 36                  MKDEBUG && _d('Bulk inserted', $del_row->rows, 'rows');
4209           6                                123                  $statistics{INSERT} += $ins_sth->rows;
4210           6                                 81               });
4211  ***      6     50                          61               if ( $success != $ALL_IS_WELL ) {
4212  ***      0                                  0                  $retries = -1;
4213  ***      0                                  0                  last ROW; # unlike other places, don't do 'next'
4214                                                              }
4215                                                           }
4216                                                  
4217          71    100                         436            if ( $bulk_del ) {
4218  ***      9     50                          66               if ( $src->{plugin} ) {
4219                                                                 trace('before_bulk_delete', sub {
4220  ***      0                    0             0                     $src->{plugin}->before_bulk_delete(
4221                                                                       first_row => $first_row,
4222                                                                       last_row  => $lastrow,
4223                                                                    );
4224  ***      0                                  0                  });
4225                                                              }
4226  ***      9     50                          62               if ( !$o->get('no-delete') ) {
4227                                                                 my $success = do_with_retries($o, 'bulk_deleting', sub {
4228           9                                 57                     $del_row->execute(
4229           9                              10837                        @{$first_row}[@bulkdel_slice],
4230           9                    9            56                        @{$lastrow}[@bulkdel_slice],
4231                                                                    );
4232           9                                 43                     MKDEBUG && _d('Bulk deleted', $del_row->rows, 'rows');
4233           9                                219                     $statistics{DELETE} += $del_row->rows;
4234           9                                143                  });
4235  ***      9     50                         119                  if ( $success != $ALL_IS_WELL ) {
4236  ***      0                                  0                     $retries = -1;
4237  ***      0                                  0                     last ROW; # unlike other places, don't do 'next'
4238                                                                 }
4239                                                              }
4240                                                           }
4241                                                  
4242                                                           # ###################################################################
4243                                                           # This code is for normal operation AND bulk operation.
4244                                                           # ###################################################################
4245          71    100                         459            commit($o, 1) if $commit_each;
4246          71                                316            $get_sth = $get_next;
4247                                                  
4248          71                                260            MKDEBUG && _d('Fetching rows in next chunk');
4249                                                           trace('select', sub {
4250          71                   71           670               my $select_start = time;
4251          71                                416               $get_sth->execute(@{$lastrow}[@asc_slice]);
              71                              31736   
4252          71                               1206               $last_select_time = time - $select_start;
4253          71                                247               MKDEBUG && _d('Fetched', $get_sth->rows, 'rows');
4254          71                               2425               $statistics{SELECT} += $get_sth->rows;
4255          71                               1791            });
4256                                                  
4257                                                           # Reset $first_row to the first row of this new chunk.
4258          71    100                        1316            @beginning_of_txn = @{$lastrow}[@asc_slice] unless $txn_cnt;
              65                                752   
4259          71                               1485            $row              = $get_sth->fetchrow_arrayref();
4260          71    100                         816            $first_row        = $row ? [ @$row ] : undef;
4261                                                  
4262          71    100                         729            if ( $o->get('bulk-insert') ) {
4263  ***      6     50                          84               $bulkins_file = File::Temp->new( SUFFIX => 'mk-archiver' )
4264                                                                 or die "Cannot open temp file: $OS_ERROR\n";
4265                                                           }
4266                                                        }  # no next row (do bulk operations)
4267                                                        else {
4268         210                                845            MKDEBUG && _d('Got another row in this chunk');
4269                                                        }
4270                                                  
4271                                                        # Check slave lag and wait if slave is too far behind.
4272  ***    281     50                        1737         if ( $lag_dbh ) {
4273  ***      0                                  0            my $lag = $ms->get_slave_lag($lag_dbh);
4274  ***      0             0                    0            while ( !defined $lag || $lag > $o->get('max-lag') ) {
4275  ***      0                                  0               MKDEBUG && _d('Sleeping: slave lag is', $lag);
4276  ***      0                                  0               sleep($o->get('check-interval'));
4277  ***      0                                  0               $lag = $ms->get_slave_lag($lag_dbh);
4278                                                           }
4279                                                        }
4280                                                  
4281                                                        # Sleep between rows.
4282  ***    281     50                        1916         if( my $sleep_time = $o->get('sleep') ) {
4283  ***      0      0                           0            $sleep_time = $last_select_time * $o->get('sleep-coef')
4284                                                              if $o->get('sleep-coef');
4285  ***      0                                  0            MKDEBUG && _d('Sleeping', $sleep_time);
4286                                                           trace('sleep', sub {
4287  ***      0                    0             0               sleep($sleep_time);
4288  ***      0                                  0            });
4289                                                        }
4290                                                     }  # ROW 
4291          21                                 87      MKDEBUG && _d('Done fetching rows');
4292                                                  
4293                                                     # Transactions might still be open, etc
4294          21           100                  265      commit($o, $txnsize || $commit_each);
4295  ***     21    100     66                  301      if ( $archive_file && $archive_fh ) {
4296  ***      2     50                          62         close $archive_fh
4297                                                           or die "Cannot close $archive_file: $OS_ERROR\n";
4298                                                     }
4299                                                  
4300  ***     21     50     33                  597      if ( !$quiet && $o->get('progress') ) {
4301  ***      0                                  0         printf("%19s %7d %7d\n", ts($now), $now - $start, $cnt);
4302                                                     }
4303                                                  
4304                                                     # Tear down the plugins.
4305          21                                183      foreach my $table ( $dst, $src ) {
4306  ***     42     50     66                  719         next unless $table && $table->{plugin};
4307                                                        trace('after_finish', sub {
4308  ***      0                    0             0            $table->{plugin}->after_finish();
4309  ***      0                                  0         });
4310                                                     }
4311                                                  
4312                                                     # Run ANALYZE or OPTIMIZE.
4313  ***     21    100     66                  292      if ( $oktorun && ($o->get('analyze') || $o->get('optimize')) ) {
      ***                   66                        
4314  ***      1            33                   14         my $action = $o->get('analyze') || $o->get('optimize');
4315  ***      1     50                           9         my $maint  = ($o->get('analyze') ? 'ANALYZE' : 'OPTIMIZE')
      ***            50                               
4316                                                                   . ($o->get('local') ? ' /*!40101 NO_WRITE_TO_BINLOG*/' : '');
4317  ***      1     50                          26         if ( $action =~ m/s/i ) {
4318                                                           trace($maint, sub {
4319           1                    1        236118               $src->{dbh}->do("$maint TABLE $src->{db_tbl}");
4320           1                                 21            });
4321                                                        }
4322  ***      1     50     33                   65         if ( $action =~ m/d/i && $dst ) {
4323                                                           trace($maint, sub {
4324  ***      0                    0             0               $dst->{dbh}->do("$maint TABLE $dst->{db_tbl}");
4325  ***      0                                  0            });
4326                                                        }
4327                                                     } 
4328                                                  
4329                                                     # ########################################################################
4330                                                     # Print statistics
4331                                                     # ########################################################################
4332  ***     21     50                         148      if ( $plugin ) {
4333  ***      0                                  0         $plugin->statistics(\%statistics, $stat_start);
4334                                                     }
4335                                                  
4336  ***     21    100     66                  374      if ( !$quiet && $o->get('statistics') ) {
4337           5                                 46         my $stat_stop  = gettimeofday();
4338           5                                 28         my $stat_total = $stat_stop - $stat_start;
4339                                                  
4340           5                                 22         my $total2 = 0;
4341           5                                 25         my $maxlen = 0;
4342           5                                 20         my %summary;
4343                                                  
4344           5                                 52         printf("Started at %s, ended at %s\n", ts($stat_start), ts($stat_stop));
4345           5                                 76         print("Source: ", $dp->as_string($src), "\n");
4346           5    100                          84         print("Dest:   ", $dp->as_string($dst), "\n") if $dst;
4347           5           100                   77         print(join("\n", map { "$_ " . ($statistics{$_} || 0) }
              15                                196   
4348                                                              qw(SELECT INSERT DELETE)), "\n");
4349                                                  
4350           5                                 51         foreach my $thing ( grep { m/_(count|time)/ } keys %statistics ) {
              54                                404   
4351          40                                496            my ( $action, $type ) = $thing =~ m/^(.*?)_(count|time)$/;
4352          40                                354            $summary{$action}->{$type}  = $statistics{$thing};
4353          40                                216            $summary{$action}->{action} = $action;
4354          40                                281            $maxlen                     = max($maxlen, length($action));
4355                                                           # Just in case I get only one type of statistic for a given action (in
4356                                                           # case there was a crash or CTRL-C or something).
4357          40           100                  299            $summary{$action}->{time}  ||= 0;
4358          40           100                  315            $summary{$action}->{count} ||= 0;
4359                                                        }
4360           5                                 91         printf("%-${maxlen}s \%10s %10s %10s\n", qw(Action Count Time Pct));
4361           5                                 35         my $fmt = "%-${maxlen}s \%10d %10.4f %10.2f\n";
4362                                                  
4363           5                                 14         foreach my $stat (
              23                                160   
4364                                                           reverse sort { $a->{time} <=> $b->{time} } values %summary )
4365                                                        {
4366          20                                153            my $pct = $stat->{time} / $stat_total * 100;
4367          20                                110            printf($fmt, @{$stat}{qw(action count time)}, $pct);
              20                                403   
4368          20                                144            $total2 += $stat->{time};
4369                                                        }
4370           5                                129         printf($fmt, 'other', 0, $stat_total - $total2,
4371                                                           ($stat_total - $total2) / $stat_total * 100);
4372                                                     }
4373                                                  
4374                                                     # Optionally print the reason for exiting.  Do this even if --quiet is
4375                                                     # specified.
4376          21    100                         159      if ( $o->get('why-quit') ) {
4377  ***      2     50     33                   23         if ( $retries < 0 ) {
      ***            50                               
                    100                               
      ***            50                               
4378  ***      0                                  0            print "Exiting because retries exceeded.\n";
4379                                                        }
4380                                                        elsif ( $o->get('run-time') && $now >= $end ) {
4381  ***      0                                  0            print "Exiting because time exceeded.\n";
4382                                                        }
4383                                                        elsif ( -f $sentinel ) {
4384           1                                 20            print "Exiting because sentinel file $sentinel exists.\n";
4385                                                        }
4386                                                        elsif ( $o->get('statistics') ) {
4387           1                                  7            print "Exiting because there are no more rows.\n";
4388                                                        }
4389                                                     }
4390                                                  
4391  ***     21     50                         433      $get_sth->finish() if $get_sth;
4392          21                               1757      $src->{dbh}->disconnect();
4393  ***     21    100     66                 1169      $dst->{dbh}->disconnect() if $dst && $dst->{dbh};
4394                                                  
4395          21                               7303      return 0;
4396                                                  }
4397                                                  
4398                                                  # ############################################################################
4399                                                  # Subroutines.
4400                                                  # ############################################################################
4401                                                  
4402                                                  # Catches signals so mk-archiver can exit gracefully.
4403                                                  sub finish {
4404  ***      0                    0             0      my ($signal) = @_;
4405  ***      0                                  0      print STDERR "Exiting on SIG$signal.\n";
4406  ***      0                                  0      $oktorun = 0;
4407                                                  }
4408                                                  
4409                                                  # Accesses globals, but I wanted the code in one place.
4410                                                  sub commit {
4411         302                  302          1938      my ( $o, $force ) = @_;
4412         302                               1898      my $txnsize = $o->get('txn-size');
4413         302    100    100                 7917      if ( $force || ($txnsize && $txn_cnt && $cnt % $txnsize == 0) ) {
                           100                        
                           100                        
4414  ***    295     50     33                 1879         if ( $o->get('buffer') && $archive_fh ) {
4415  ***      0                                  0            my $archive_file = $o->get('file');
4416                                                           trace('flush', sub {
4417  ***      0      0             0             0               $archive_fh->flush or die "Cannot flush $archive_file: $OS_ERROR\n";
4418  ***      0                                  0            });
4419                                                        }
4420         295    100                        1900         if ( $dst ) {
4421                                                           trace('commit', sub {
4422         248                  248        20478895               $dst->{dbh}->commit;
4423         248                               3175            });
4424                                                        }
4425                                                        trace('commit', sub {
4426         295                  295        8002620            $src->{dbh}->commit;
4427         295                               7618         });
4428         295                               4909         $txn_cnt = 0;
4429                                                     }
4430                                                  }
4431                                                  
4432                                                  # Repeatedly retries the code until retries runs out, a really bad error
4433                                                  # happens, or it succeeds.  This sub uses lots of global variables; I only wrote
4434                                                  # it to factor out some repeated code.
4435                                                  sub do_with_retries {
4436         204                  204          1736      my ( $o, $doing, $code ) = @_;
4437         204                               1449      my $retries = $o->get('retries');
4438         204                               1295      my $txnsize = $o->get('txn-size');
4439         204                                946      my $success = $OUT_OF_RETRIES;
4440                                                  
4441                                                     RETRY:
4442  ***    204            66                 3222      while ( !$success && $retries >= 0 ) {
4443         204                               1041         eval {
4444         204                               1331            trace($doing, $code);
4445         204                               1370            $success = $ALL_IS_WELL;
4446                                                        };
4447  ***    204     50                        2659         if ( $EVAL_ERROR ) {
4448  ***      0      0                           0            if ( $EVAL_ERROR =~ m/Lock wait timeout exceeded|Deadlock found/ ) {
4449  ***      0      0      0                    0               if (
      ***                    0                        
      ***                    0                        
      ***                    0                        
      ***                    0                        
      ***                    0                        
4450                                                                 # More than one row per txn
4451                                                                 (
4452                                                                    ($txnsize && $txnsize > 1)
4453                                                                    || ($o->get('commit-each') && $o->get('limit') > 1)
4454                                                                 )
4455                                                                 # Not first row
4456                                                                 && $txn_cnt
4457                                                                 # And it's not retry-able
4458                                                                 && (!$can_retry || $EVAL_ERROR =~ m/Deadlock/)
4459                                                              ) {
4460                                                                 # The txn, which is more than 1 statement, was rolled back.
4461  ***      0                                  0                  last RETRY;
4462                                                              }
4463                                                              else {
4464                                                                 # Only one statement had trouble, and the rest of the txn was
4465                                                                 # not rolled back.  The statement can be retried.
4466  ***      0                                  0                  --$retries;
4467                                                              }
4468                                                           }
4469                                                           else {
4470  ***      0                                  0               die $EVAL_ERROR;
4471                                                           }
4472                                                        }
4473                                                     }
4474                                                  
4475  ***    204     50                        1337      if ( $success != $ALL_IS_WELL ) {
4476                                                        # Must throw away everything and start the transaction over.
4477  ***      0      0                           0         if ( $retries >= 0 ) {
4478  ***      0                                  0            warn "Deadlock or non-retryable lock wait while $doing; "
4479                                                              . "rolling back $txn_cnt rows.\n";
4480  ***      0                                  0            $success = $ROLLED_BACK;
4481                                                        }
4482                                                        else {
4483  ***      0                                  0            warn "Exhausted retries while $doing; rolling back $txn_cnt rows.\n";
4484  ***      0                                  0            $success = $OUT_OF_RETRIES;
4485                                                        }
4486  ***      0                                  0         $get_sth->finish;
4487                                                        trace('rollback', sub {
4488  ***      0                    0             0            $dst->{dbh}->rollback;
4489  ***      0                                  0         });
4490                                                        trace('rollback', sub {
4491  ***      0                    0             0            $src->{dbh}->rollback;
4492  ***      0                                  0         });
4493                                                        # I wish: $archive_fh->rollback
4494                                                        trace('select', sub {
4495  ***      0                    0             0            $get_sth->execute(@beginning_of_txn);
4496  ***      0                                  0         });
4497  ***      0                                  0         $cnt -= $txn_cnt;
4498  ***      0                                  0         $txn_cnt = 0;
4499                                                     }
4500         204                               1429      return $success;
4501                                                  }
4502                                                  
4503                                                  # Formats a row the same way SELECT INTO OUTFILE does by default.  This is
4504                                                  # described in the LOAD DATA INFILE section of the MySQL manual,
4505                                                  # http://dev.mysql.com/doc/refman/5.0/en/load-data.html
4506                                                  sub escape {
4507         123                  123           657      my ($row) = @_;
4508         998    100                        6287      return join("\t", map {
4509         123                                749         s/([\t\n\\])/\\$1/g if defined $_;  # Escape tabs etc
4510         998    100                        6894         defined $_ ? $_ : '\N';             # NULL = \N
4511                                                     } @$row);
4512                                                  }
4513                                                  
4514                                                  sub ts {
4515          10                   10            55      my ( $time ) = @_;
4516          10                                726      my ( $sec, $min, $hour, $mday, $mon, $year )
4517                                                        = localtime($time);
4518          10                                 56      $mon  += 1;
4519          10                                 40      $year += 1900;
4520          10                                229      return sprintf("%d-%02d-%02dT%02d:%02d:%02d",
4521                                                        $year, $mon, $mday, $hour, $min, $sec);
4522                                                  }
4523                                                  
4524                                                  sub get_irot {
4525          61                   61           292      my ( $dbh ) = @_;
4526  ***     61     50                         567      return 1 unless $vp->version_ge($dbh, '5.0.13');
4527          61                               1165      my $rows = $dbh->selectall_arrayref(
4528                                                        "show variables like 'innodb_rollback_on_timeout'",
4529                                                        { Slice => {} });
4530  ***     61     50                         622      return 0 unless $rows;
4531  ***     61            33                 1162      return @$rows && $rows->[0]->{Value} ne 'OFF';
4532                                                  }
4533                                                  
4534                                                  sub _d {
4535  ***      0                    0                    my ($package, undef, $line) = caller 0;
4536  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
4537  ***      0                                              map { defined $_ ? $_ : 'undef' }
4538                                                          @_;
4539  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
4540                                                  }
4541                                                  
4542                                                  # ############################################################################
4543                                                  # Run the program.
4544                                                  # ############################################################################
4545                                                  if ( !caller ) { exit main(@ARGV); }
4546                                                  
4547                                                  1; # Because this is a module as well as a script.
4548                                                  
4549                                                  # ############################################################################
4550                                                  # Documentation.
4551                                                  # ############################################################################
4552                                                  
4553                                                  =pod
4554                                                  
4555                                                  =head1 NAME
4556                                                  
4557                                                  mk-archiver - Archive rows from a MySQL table into another table or a file.
4558                                                  
4559                                                  =head1 SYNOPSIS
4560                                                  
4561                                                  Usage: mk-archiver [OPTION...] --source DSN --where WHERE
4562                                                  
4563                                                  mk-archiver nibbles records from a MySQL table.  The --source and --dest
4564                                                  arguments use DSN syntax; if COPY is yes, --dest defaults to the key's value
4565                                                  from --source.
4566                                                  
4567                                                  Examples:
4568                                                  
4569                                                  Archive all rows from oltp_server to olap_server and to a file:
4570                                                  
4571                                                    mk-archiver --source h=oltp_server,D=test,t=tbl --dest h=olap_server \
4572                                                      --file '/var/log/archive/%Y-%m-%d-%D.%t'                           \
4573                                                      --where "1=1" --limit 1000 --commit-each
4574                                                  
4575                                                  Purge (delete) orphan rows from child table:
4576                                                  
4577                                                    mk-archiver --source h=host,D=db,t=child --purge \
4578                                                      --where 'NOT EXISTS(SELECT * FROM parent WHERE col=child.col)'
4579                                                  
4580                                                  =head1 RISKS
4581                                                  
4582                                                  The following section is included to inform users about the potential risks,
4583                                                  whether known or unknown, of using this tool.  The two main categories of risks
4584                                                  are those created by the nature of the tool (e.g. read-only tools vs. read-write
4585                                                  tools) and those created by bugs.
4586                                                  
4587                                                  mk-achiver is a read-write tool.  It deletes data from the source by default, so
4588                                                  you should test your archiving jobs with the L<"--dry-run"> option if you're not
4589                                                  sure about them.  It is designed to have as little impact on production systems
4590                                                  as possible, but tuning with L<"--limit">, L<"--txn-size"> and similar options
4591                                                  might be a good idea too.
4592                                                  
4593                                                  If you write or use L<"--plugin"> modules, you should ensure they are good
4594                                                  quality and well-tested. 
4595                                                  
4596                                                  At the time of this release there is a bug with character sets and another
4597                                                  bug with L<"--bulk-insert"> that may cause data loss.
4598                                                  
4599                                                  The authoritative source for updated information is always the online issue
4600                                                  tracking system.  Issues that affect this tool will be marked as such.  You can
4601                                                  see a list of such issues at the following URL:
4602                                                  L<http://www.maatkit.org/bugs/mk-archiver>.
4603                                                  
4604                                                  See also L<"BUGS"> for more information on filing bugs and getting help.
4605                                                  
4606                                                  =head1 DESCRIPTION
4607                                                  
4608                                                  mk-archiver is the tool I use to archive tables as described in
4609                                                  L<http://tinyurl.com/mysql-archiving>.  The goal is a low-impact, forward-only
4610                                                  job to nibble old data out of the table without impacting OLTP queries much.
4611                                                  You can insert the data into another table, which need not be on the same
4612                                                  server.  You can also write it to a file in a format suitable for LOAD DATA
4613                                                  INFILE.  Or you can do neither, in which case it's just an incremental DELETE.
4614                                                  
4615                                                  mk-archiver is extensible via a plugin mechanism.  You can inject your own
4616                                                  code to add advanced archiving logic that could be useful for archiving
4617                                                  dependent data, applying complex business rules, or building a data warehouse
4618                                                  during the archiving process.
4619                                                  
4620                                                  You need to choose values carefully for some options.  The most important are
4621                                                  L<"--limit">, L<"--retries">, and L<"--txn-size">.
4622                                                  
4623                                                  The strategy is to find the first row(s), then scan some index forward-only to
4624                                                  find more rows efficiently.  Each subsequent query should not scan the entire
4625                                                  table; it should seek into the index, then scan until it finds more archivable
4626                                                  rows.  Specifying the index with the 'i' part of the L<"--source"> argument can
4627                                                  be crucial for this; use L<"--dry-run"> to examine the generated queries and be
4628                                                  sure to EXPLAIN them to see if they are efficient (most of the time you probably
4629                                                  want to scan the PRIMARY key, which is the default).  Even better, profile
4630                                                  mk-archiver with mk-query-profiler and make sure it is not scanning the whole
4631                                                  table every query.
4632                                                  
4633                                                  You can disable the seek-then-scan optimizations partially or wholly with
4634                                                  L<"--no-ascend"> and L<"--ascend-first">.  Sometimes this may be more efficient
4635                                                  for multi-column keys.  Be aware that mk-archiver is built to start at the
4636                                                  beginning of the index it chooses and scan it forward-only.  This might result
4637                                                  in long table scans if you're trying to nibble from the end of the table by an
4638                                                  index other than the one it prefers.  See L<"--source"> and read the
4639                                                  documentation on the C<i> part if this applies to you.
4640                                                  
4641                                                  =head1 OUTPUT
4642                                                  
4643                                                  If you specify L<"--progress">, the output is a header row, plus status output
4644                                                  at intervals.  Each row in the status output lists the current date and time,
4645                                                  how many seconds mk-archiver has been running, and how many rows it has
4646                                                  archived.
4647                                                  
4648                                                  If you specify L<"--statistics">, C<mk-archiver> outputs timing and other
4649                                                  information to help you identify which part of your archiving process takes the
4650                                                  most time.
4651                                                  
4652                                                  =head1 ERROR-HANDLING
4653                                                  
4654                                                  mk-archiver tries to catch signals and exit gracefully; for example, if you
4655                                                  send it SIGTERM (Ctrl-C on UNIX-ish systems), it will catch the signal, print a
4656                                                  message about the signal, and exit fairly normally.  It will not execute
4657                                                  L<"--analyze"> or L<"--optimize">, because these may take a long time to finish.
4658                                                  It will run all other code normally, including calling after_finish() on any
4659                                                  plugins (see L<"EXTENDING">).
4660                                                  
4661                                                  In other words, a signal, if caught, will break out of the main archiving
4662                                                  loop and skip optimize/analyze.
4663                                                  
4664                                                  =head1 OPTIONS
4665                                                  
4666                                                  Specify at least one of L<"--dest">, L<"--file">, or L<"--purge">.
4667                                                  
4668                                                  L<"--ignore"> and L<"--replace"> are mutually exclusive.
4669                                                  
4670                                                  L<"--txn-size"> and L<"--commit-each"> are mutually exclusive.
4671                                                  
4672                                                  L<"--low-priority-insert"> and L<"--delayed-insert"> are mutually exclusive.
4673                                                  
4674                                                  L<"--share-lock"> and L<"--for-update"> are mutually exclusive.
4675                                                  
4676                                                  L<"--analyze"> and L<"--optimize"> are mutually exclusive.
4677                                                  
4678                                                  L<"--no-ascend"> and L<"--no-delete"> are mutually exclusive.
4679                                                  
4680                                                  DSN values in L<"--dest"> default to values from L<"--source"> if COPY is yes.
4681                                                  
4682                                                  =over
4683                                                  
4684                                                  =item --analyze
4685                                                  
4686                                                  type: string
4687                                                  
4688                                                  Run ANALYZE TABLE afterwards on L<"--source"> and/or L<"--dest">.
4689                                                  
4690                                                  Runs ANALYZE TABLE after finishing.  The argument is an arbitrary string.  If it
4691                                                  contains the letter 's', the source will be analyzed.  If it contains 'd', the
4692                                                  destination will be analyzed.  You can specify either or both.  For example, the
4693                                                  following will analyze both:
4694                                                  
4695                                                    --analyze=ds
4696                                                  
4697                                                  See L<http://dev.mysql.com/doc/en/analyze-table.html> for details on ANALYZE
4698                                                  TABLE.
4699                                                  
4700                                                  =item --ascend-first
4701                                                  
4702                                                  Ascend only first column of index.
4703                                                  
4704                                                  If you do want to use the ascending index optimization (see L<"--no-ascend">),
4705                                                  but do not want to incur the overhead of ascending a large multi-column index,
4706                                                  you can use this option to tell mk-archiver to ascend only the leftmost column
4707                                                  of the index.  This can provide a significant performance boost over not
4708                                                  ascending the index at all, while avoiding the cost of ascending the whole
4709                                                  index.
4710                                                  
4711                                                  See L<"EXTENDING"> for a discussion of how this interacts with plugins.
4712                                                  
4713                                                  =item --ask-pass
4714                                                  
4715                                                  Prompt for a password when connecting to MySQL.
4716                                                  
4717                                                  =item --buffer
4718                                                  
4719                                                  Buffer output to L<"--file"> and flush at commit.
4720                                                  
4721                                                  Disables autoflushing to L<"--file"> and flushes L<"--file"> to disk only when a
4722                                                  transaction commits.  This typically means the file is block-flushed by the
4723                                                  operating system, so there may be some implicit flushes to disk between
4724                                                  commits as well.  The default is to flush L<"--file"> to disk after every row.
4725                                                  
4726                                                  The danger is that a crash might cause lost data.
4727                                                  
4728                                                  The performance increase I have seen from using L<"--buffer"> is around 5 to 15
4729                                                  percent.  Your mileage may vary.
4730                                                  
4731                                                  =item --bulk-delete
4732                                                  
4733                                                  Delete each chunk with a single statement (implies L<"--commit-each">).
4734                                                  
4735                                                  Delete each chunk of rows in bulk with a single C<DELETE> statement.  The
4736                                                  statement deletes every row between the first and last row of the chunk,
4737                                                  inclusive.  It implies L<"--commit-each">, since it would be a bad idea to
4738                                                  C<INSERT> rows one at a time and commit them before the bulk C<DELETE>.
4739                                                  
4740                                                  The normal method is to delete every row by its primary key.  Bulk deletes might
4741                                                  be a lot faster.  B<They also might not be faster> if you have a complex
4742                                                  C<WHERE> clause.
4743                                                  
4744                                                  This option completely defers all C<DELETE> processing until the chunk of rows
4745                                                  is finished.  If you have a plugin on the source, its C<before_delete> method
4746                                                  will not be called.  Instead, its C<before_bulk_delete> method is called later.
4747                                                  
4748                                                  B<WARNING>: if you have a plugin on the source that sometimes doesn't return
4749                                                  true from C<is_archivable()>, you should use this option only if you understand
4750                                                  what it does.  If the plugin instructs C<mk-archiver> not to archive a row,
4751                                                  it will still be deleted by the bulk delete!
4752                                                  
4753                                                  =item --[no]bulk-delete-limit
4754                                                  
4755                                                  default: yes
4756                                                  
4757                                                  Add L<"--limit"> to L<"--bulk-delete"> statement.
4758                                                  
4759                                                  This is an advanced option and you should not disable it unless you know what
4760                                                  you are doing and why!  By default, L<"--bulk-delete"> appends a L<"--limit">
4761                                                  clause to the bulk delete SQL statement.  In certain cases, this clause can be
4762                                                  omitted by specifying C<--no-bulk-delete-limit>.  L<"--limit"> must still be
4763                                                  specified.
4764                                                  
4765                                                  =item --bulk-insert
4766                                                  
4767                                                  Insert each chunk with LOAD DATA INFILE (implies L<"--bulk-delete"> L<"--commit-each">).
4768                                                  
4769                                                  Insert each chunk of rows with C<LOAD DATA LOCAL INFILE>.  This may be much
4770                                                  faster than inserting a row at a time with C<INSERT> statements.  It is
4771                                                  implemented by creating a temporary file for each chunk of rows, and writing the
4772                                                  rows to this file instead of inserting them.  When the chunk is finished, it
4773                                                  uploads the rows.
4774                                                  
4775                                                  To protect the safety of your data, this option forces bulk deletes to be used.
4776                                                  It would be unsafe to delete each row as it is found, before inserting the rows
4777                                                  into the destination first.  Forcing bulk deletes guarantees that the deletion
4778                                                  waits until the insertion is successful.
4779                                                  
4780                                                  The L<"--low-priority-insert">, L<"--replace">, and L<"--ignore"> options work
4781                                                  with this option, but L<"--delayed-insert"> does not.
4782                                                  
4783                                                  =item --charset
4784                                                  
4785                                                  short form: -A; type: string
4786                                                  
4787                                                  Default character set.  If the value is utf8, sets Perl's binmode on
4788                                                  STDOUT to utf8, passes the mysql_enable_utf8 option to DBD::mysql, and runs SET
4789                                                  NAMES UTF8 after connecting to MySQL.  Any other value sets binmode on STDOUT
4790                                                  without the utf8 layer, and runs SET NAMES after connecting to MySQL.
4791                                                  
4792                                                  =item --[no]check-columns
4793                                                  
4794                                                  default: yes
4795                                                  
4796                                                  Ensure L<"--source"> and L<"--dest"> have same columns.
4797                                                  
4798                                                  Enabled by default; causes mk-archiver to check that the source and destination
4799                                                  tables have the same columns.  It does not check column order, data type, etc.
4800                                                  It just checks that all columns in the source exist in the destination and
4801                                                  vice versa.  If there are any differences, mk-archiver will exit with an
4802                                                  error.
4803                                                  
4804                                                  To disable this check, specify --no-check-columns.
4805                                                  
4806                                                  =item --check-interval
4807                                                  
4808                                                  type: time; default: 1s
4809                                                  
4810                                                  How often to check for slave lag if L<"--check-slave-lag"> is given.
4811                                                  
4812                                                  =item --check-slave-lag
4813                                                  
4814                                                  type: string
4815                                                  
4816                                                  Pause archiving until the specified DSN's slave lag is less than L<"--max-lag">.
4817                                                  
4818                                                  =item --columns
4819                                                  
4820                                                  short form: -c; type: array
4821                                                  
4822                                                  Comma-separated list of columns to archive.
4823                                                  
4824                                                  Specify a comma-separated list of columns to fetch, write to the file, and
4825                                                  insert into the destination table.  If specified, mk-archiver ignores other
4826                                                  columns unless it needs to add them to the C<SELECT> statement for ascending an
4827                                                  index or deleting rows.  It fetches and uses these extra columns internally, but
4828                                                  does not write them to the file or to the destination table.  It I<does> pass
4829                                                  them to plugins.
4830                                                  
4831                                                  See also L<"--primary-key-only">.
4832                                                  
4833                                                  =item --commit-each
4834                                                  
4835                                                  Commit each set of fetched and archived rows (disables L<"--txn-size">).
4836                                                  
4837                                                  Commits transactions and flushes L<"--file"> after each set of rows has been
4838                                                  archived, before fetching the next set of rows, and before sleeping if
4839                                                  L<"--sleep"> is specified.  Disables L<"--txn-size">; use L<"--limit"> to
4840                                                  control the transaction size with L<"--commit-each">.
4841                                                  
4842                                                  This option is useful as a shortcut to make L<"--limit"> and L<"--txn-size"> the
4843                                                  same value, but more importantly it avoids transactions being held open while
4844                                                  searching for more rows.  For example, imagine you are archiving old rows from
4845                                                  the beginning of a very large table, with L<"--limit"> 1000 and L<"--txn-size">
4846                                                  1000.  After some period of finding and archiving 1000 rows at a time,
4847                                                  mk-archiver finds the last 999 rows and archives them, then executes the next
4848                                                  SELECT to find more rows.  This scans the rest of the table, but never finds any
4849                                                  more rows.  It has held open a transaction for a very long time, only to
4850                                                  determine it is finished anyway.  You can use L<"--commit-each"> to avoid this.
4851                                                  
4852                                                  =item --config
4853                                                  
4854                                                  type: Array
4855                                                  
4856                                                  Read this comma-separated list of config files; if specified, this must be the
4857                                                  first option on the command line.
4858                                                  
4859                                                  =item --delayed-insert
4860                                                  
4861                                                  Add the DELAYED modifier to INSERT statements.
4862                                                  
4863                                                  Adds the DELAYED modifier to INSERT or REPLACE statements.  See
4864                                                  L<http://dev.mysql.com/doc/en/insert.html> for details.
4865                                                  
4866                                                  =item --dest
4867                                                  
4868                                                  type: DSN
4869                                                  
4870                                                  DSN specifying the table to archive to.
4871                                                  
4872                                                  This item specifies a table into which mk-archiver will insert rows
4873                                                  archived from L<"--source">.  It uses the same key=val argument format as
4874                                                  L<"--source">.  Most missing values default to the same values as
4875                                                  L<"--source">, so you don't have to repeat options that are the same in
4876                                                  L<"--source"> and L<"--dest">.  Use the L<"--help"> option to see which values
4877                                                  are copied from L<"--source">.
4878                                                  
4879                                                  B<WARNING>: Using a default options file (F) DSN option that defines a
4880                                                  socket for L<"--source"> causes mk-archiver to connect to L<"--dest"> using
4881                                                  that socket unless another socket for L<"--dest"> is specified.  This
4882                                                  means that mk-archiver may incorrectly connect to L<"--source"> when it
4883                                                  connects to L<"--dest">.  For example:
4884                                                  
4885                                                    --source F=host1.cnf,D=db,t=tbl --dest h=host2
4886                                                  
4887                                                  When mk-archiver connects to L<"--dest">, host2, it will connect via the
4888                                                  L<"--source">, host1, socket defined in host1.cnf.
4889                                                  
4890                                                  =item --dry-run
4891                                                  
4892                                                  Print queries and exit without doing anything.
4893                                                  
4894                                                  Causes mk-archiver to exit after printing the filename and SQL statements
4895                                                  it will use.
4896                                                  
4897                                                  =item --file
4898                                                  
4899                                                  type: string
4900                                                  
4901                                                  File to archive to, with DATE_FORMAT()-like formatting.
4902                                                  
4903                                                  Filename to write archived rows to.  A subset of MySQL's DATE_FORMAT()
4904                                                  formatting codes are allowed in the filename, as follows:
4905                                                  
4906                                                     %d    Day of the month, numeric (01..31)
4907                                                     %H    Hour (00..23)
4908                                                     %i    Minutes, numeric (00..59)
4909                                                     %m    Month, numeric (01..12)
4910                                                     %s    Seconds (00..59)
4911                                                     %Y    Year, numeric, four digits
4912                                                  
4913                                                  You can use the following extra format codes too:
4914                                                  
4915                                                     %D    Database name
4916                                                     %t    Table name
4917                                                  
4918                                                  Example:
4919                                                  
4920                                                     --file '/var/log/archive/%Y-%m-%d-%D.%t'
4921                                                  
4922                                                  The file's contents are in the same format used by SELECT INTO OUTFILE, as
4923                                                  documented in the MySQL manual: rows terminated by newlines, columns
4924                                                  terminated by tabs, NULL characters are represented by \N, and special
4925                                                  characters are escaped by \.  This lets you reload a file with LOAD DATA
4926                                                  INFILE's default settings.
4927                                                  
4928                                                  If you want a column header at the top of the file, see L<"--header">.  The file
4929                                                  is auto-flushed by default; see L<"--buffer">.
4930                                                  
4931                                                  =item --for-update
4932                                                  
4933                                                  Adds the FOR UPDATE modifier to SELECT statements.
4934                                                  
4935                                                  For details, see L<http://dev.mysql.com/doc/en/innodb-locking-reads.html>.
4936                                                  
4937                                                  =item --header
4938                                                  
4939                                                  Print column header at top of L<"--file">.
4940                                                  
4941                                                  Writes column names as the first line in the file given by L<"--file">.  If the
4942                                                  file exists, does not write headers; this keeps the file loadable with LOAD
4943                                                  DATA INFILE in case you append more output to it.
4944                                                  
4945                                                  =item --help
4946                                                  
4947                                                  Show help and exit.
4948                                                  
4949                                                  =item --high-priority-select
4950                                                  
4951                                                  Adds the HIGH_PRIORITY modifier to SELECT statements.
4952                                                  
4953                                                  See L<http://dev.mysql.com/doc/en/select.html> for details.
4954                                                  
4955                                                  =item --host
4956                                                  
4957                                                  short form: -h; type: string
4958                                                  
4959                                                  Connect to host.
4960                                                  
4961                                                  =item --ignore
4962                                                  
4963                                                  Use IGNORE for INSERT statements.
4964                                                  
4965                                                  Causes INSERTs into L<"--dest"> to be INSERT IGNORE.
4966                                                  
4967                                                  =item --limit
4968                                                  
4969                                                  type: int; default: 1
4970                                                  
4971                                                  Number of rows to fetch and archive per statement.
4972                                                  
4973                                                  Limits the number of rows returned by the SELECT statements that retrieve rows
4974                                                  to archive.  Default is one row.  It may be more efficient to increase the
4975                                                  limit, but be careful if you are archiving sparsely, skipping over many rows;
4976                                                  this can potentially cause more contention with other queries, depending on the
4977                                                  storage engine, transaction isolation level, and options such as
4978                                                  L<"--for-update">.
4979                                                  
4980                                                  =item --local
4981                                                  
4982                                                  Do not write OPTIMIZE or ANALYZE queries to binlog.
4983                                                  
4984                                                  Adds the NO_WRITE_TO_BINLOG modifier to ANALYZE and OPTIMIZE queries.  See
4985                                                  L<"--analyze"> for details.
4986                                                  
4987                                                  =item --low-priority-delete
4988                                                  
4989                                                  Adds the LOW_PRIORITY modifier to DELETE statements.
4990                                                  
4991                                                  See L<http://dev.mysql.com/doc/en/delete.html> for details.
4992                                                  
4993                                                  =item --low-priority-insert
4994                                                  
4995                                                  Adds the LOW_PRIORITY modifier to INSERT or REPLACE statements.
4996                                                  
4997                                                  See L<http://dev.mysql.com/doc/en/insert.html> for details.
4998                                                  
4999                                                  =item --max-lag
5000                                                  
5001                                                  type: time; default: 1s
5002                                                  
5003                                                  Pause archiving if the slave given by L<"--check-slave-lag"> lags.
5004                                                  
5005                                                  This option causes mk-archiver to look at the slave every time it's about
5006                                                  to fetch another row.  If the slave's lag is greater than the option's value,
5007                                                  or if the slave isn't running (so its lag is NULL), mk-table-checksum sleeps
5008                                                  for L<"--check-interval"> seconds and then looks at the lag again.  It repeats
5009                                                  until the slave is caught up, then proceeds to fetch and archive the row.
5010                                                  
5011                                                  This option may eliminate the need for L<"--sleep"> or L<"--sleep-coef">.
5012                                                  
5013                                                  =item --no-ascend
5014                                                  
5015                                                  Do not use ascending index optimization.
5016                                                  
5017                                                  The default ascending-index optimization causes C<mk-archiver> to optimize
5018                                                  repeated C<SELECT> queries so they seek into the index where the previous query
5019                                                  ended, then scan along it, rather than scanning from the beginning of the table
5020                                                  every time.  This is enabled by default because it is generally a good strategy
5021                                                  for repeated accesses.
5022                                                  
5023                                                  Large, multiple-column indexes may cause the WHERE clause to be complex enough
5024                                                  that this could actually be less efficient.  Consider for example a four-column
5025                                                  PRIMARY KEY on (a, b, c, d).  The WHERE clause to start where the last query
5026                                                  ended is as follows:
5027                                                  
5028                                                     WHERE (a > ?)
5029                                                        OR (a = ? AND b > ?)
5030                                                        OR (a = ? AND b = ? AND c > ?)
5031                                                        OR (a = ? AND b = ? AND c = ? AND d >= ?)
5032                                                  
5033                                                  Populating the placeholders with values uses memory and CPU, adds network
5034                                                  traffic and parsing overhead, and may make the query harder for MySQL to
5035                                                  optimize.  A four-column key isn't a big deal, but a ten-column key in which
5036                                                  every column allows C<NULL> might be.
5037                                                  
5038                                                  Ascending the index might not be necessary if you know you are simply removing
5039                                                  rows from the beginning of the table in chunks, but not leaving any holes, so
5040                                                  starting at the beginning of the table is actually the most efficient thing to
5041                                                  do.
5042                                                  
5043                                                  See also L<"--ascend-first">.  See L<"EXTENDING"> for a discussion of how this
5044                                                  interacts with plugins.
5045                                                  
5046                                                  =item --no-delete
5047                                                  
5048                                                  Do not delete archived rows.
5049                                                  
5050                                                  Causes C<mk-archiver> not to delete rows after processing them.  This disallows
5051                                                  L<"--no-ascend">, because enabling them both would cause an infinite loop.
5052                                                  
5053                                                  If there is a plugin on the source DSN, its C<before_delete> method is called
5054                                                  anyway, even though C<mk-archiver> will not execute the delete.  See
5055                                                  L<"EXTENDING"> for more on plugins.
5056                                                  
5057                                                  =item --optimize
5058                                                  
5059                                                  type: string
5060                                                  
5061                                                  Run OPTIMIZE TABLE afterwards on L<"--source"> and/or L<"--dest">.
5062                                                  
5063                                                  Runs OPTIMIZE TABLE after finishing.  See L<"--analyze"> for the option syntax
5064                                                  and L<http://dev.mysql.com/doc/en/optimize-table.html> for details on OPTIMIZE
5065                                                  TABLE.
5066                                                  
5067                                                  =item --password
5068                                                  
5069                                                  short form: -p; type: string
5070                                                  
5071                                                  Password to use when connecting.
5072                                                  
5073                                                  =item --pid
5074                                                  
5075                                                  type: string
5076                                                  
5077                                                  Create the given PID file when daemonized.  The file contains the process ID of
5078                                                  the daemonized instance.  The PID file is removed when the daemonized instance
5079                                                  exits.  The program checks for the existence of the PID file when starting; if
5080                                                  it exists and the process with the matching PID exists, the program exits.
5081                                                  
5082                                                  =item --plugin
5083                                                  
5084                                                  type: string
5085                                                  
5086                                                  Perl module name to use as a generic plugin.
5087                                                  
5088                                                  Specify the Perl module name of a general-purpose plugin.  It is currently used
5089                                                  only for statistics (see L<"--statistics">) and must have C<new()> and a
5090                                                  C<statistics()> method.
5091                                                  
5092                                                  The C<new( src => $src, dst => $dst, opts => $o )> method gets the source
5093                                                  and destination DSNs, and their database connections, just like the
5094                                                  connection-specific plugins do.  It also gets an OptionParser object (C<$o>) for
5095                                                  accessing command-line options (example: C<$o->get('purge');>).
5096                                                  
5097                                                  The C<statistics(\%stats, $time)> method gets a hashref of the statistics
5098                                                  collected by the archiving job, and the time the whole job started.
5099                                                  
5100                                                  =item --port
5101                                                  
5102                                                  short form: -P; type: int
5103                                                  
5104                                                  Port number to use for connection.
5105                                                  
5106                                                  =item --primary-key-only
5107                                                  
5108                                                  Primary key columns only.
5109                                                  
5110                                                  A shortcut for specifying L<"--columns"> with the primary key columns.  This is
5111                                                  an efficiency if you just want to purge rows; it avoids fetching the entire row,
5112                                                  when only the primary key columns are needed for C<DELETE> statements.  See also
5113                                                  L<"--purge">.
5114                                                  
5115                                                  =item --progress
5116                                                  
5117                                                  type: int
5118                                                  
5119                                                  Print progress information every X rows.
5120                                                  
5121                                                  Prints current time, elapsed time, and rows archived every X rows.
5122                                                  
5123                                                  =item --purge
5124                                                  
5125                                                  Purge instead of archiving; allows omitting L<"--file"> and L<"--dest">.
5126                                                  
5127                                                  Allows archiving without a L<"--file"> or L<"--dest"> argument, which is
5128                                                  effectively a purge since the rows are just deleted.
5129                                                  
5130                                                  If you just want to purge rows, consider specifying the table's primary key
5131                                                  columns with L<"--primary-key-only">.  This will prevent fetching all columns
5132                                                  from the server for no reason.
5133                                                  
5134                                                  =item --quick-delete
5135                                                  
5136                                                  Adds the QUICK modifier to DELETE statements.
5137                                                  
5138                                                  See L<http://dev.mysql.com/doc/en/delete.html> for details.  As stated in the
5139                                                  documentation, in some cases it may be faster to use DELETE QUICK followed by
5140                                                  OPTIMIZE TABLE.  You can use L<"--optimize"> for this.
5141                                                  
5142                                                  =item --quiet
5143                                                  
5144                                                  short form: -q
5145                                                  
5146                                                  Do not print any output, such as for L<"--statistics">.
5147                                                  
5148                                                  Suppresses normal output, including the output of L<"--statistics">, but doesn't
5149                                                  suppress the output from L<"--why-quit">.
5150                                                  
5151                                                  =item --replace
5152                                                  
5153                                                  Causes INSERTs into L<"--dest"> to be written as REPLACE.
5154                                                  
5155                                                  =item --retries
5156                                                  
5157                                                  type: int; default: 1
5158                                                  
5159                                                  Number of retries per timeout or deadlock.
5160                                                  
5161                                                  Specifies the number of times mk-archiver should retry when there is an
5162                                                  InnoDB lock wait timeout or deadlock.  When retries are exhausted,
5163                                                  mk-archiver will exit with an error.
5164                                                  
5165                                                  Consider carefully what you want to happen when you are archiving between a
5166                                                  mixture of transactional and non-transactional storage engines.  The INSERT to
5167                                                  L<"--dest"> and DELETE from L<"--source"> are on separate connections, so they
5168                                                  do not actually participate in the same transaction even if they're on the same
5169                                                  server.  However, mk-archiver implements simple distributed transactions in
5170                                                  code, so commits and rollbacks should happen as desired across the two
5171                                                  connections.
5172                                                  
5173                                                  At this time I have not written any code to handle errors with transactional
5174                                                  storage engines other than InnoDB.  Request that feature if you need it.
5175                                                  
5176                                                  =item --run-time
5177                                                  
5178                                                  type: time
5179                                                  
5180                                                  Time to run before exiting.
5181                                                  
5182                                                  Optional suffix s=seconds, m=minutes, h=hours, d=days; if no suffix, s is used.
5183                                                  
5184                                                  =item --[no]safe-auto-increment
5185                                                  
5186                                                  default: yes
5187                                                  
5188                                                  Do not archive row with max AUTO_INCREMENT.
5189                                                  
5190                                                  Adds an extra WHERE clause to prevent mk-archiver from removing the newest
5191                                                  row when ascending a single-column AUTO_INCREMENT key.  This guards against
5192                                                  re-using AUTO_INCREMENT values if the server restarts, and is enabled by
5193                                                  default.
5194                                                  
5195                                                  The extra WHERE clause contains the maximum value of the auto-increment column
5196                                                  as of the beginning of the archive or purge job.  If new rows are inserted while
5197                                                  mk-archiver is running, it will not see them.
5198                                                  
5199                                                  =item --sentinel
5200                                                  
5201                                                  type: string; default: /tmp/mk-archiver-sentinel
5202                                                  
5203                                                  Exit if this file exists.
5204                                                  
5205                                                  The presence of the file specified by L<"--sentinel"> will cause mk-archiver to
5206                                                  stop archiving and exit.  The default is /tmp/mk-archiver-sentinel.  You
5207                                                  might find this handy to stop cron jobs gracefully if necessary.  See also
5208                                                  L<"--stop">.
5209                                                  
5210                                                  =item --set-vars
5211                                                  
5212                                                  type: string; default: wait_timeout=10000
5213                                                  
5214                                                  Set these MySQL variables.
5215                                                  
5216                                                  Specify any variables you want to be set immediately after connecting to MySQL.
5217                                                  These will be included in a C<SET> command.
5218                                                  
5219                                                  =item --share-lock
5220                                                  
5221                                                  Adds the LOCK IN SHARE MODE modifier to SELECT statements.
5222                                                  
5223                                                  See L<http://dev.mysql.com/doc/en/innodb-locking-reads.html>.
5224                                                  
5225                                                  =item --skip-foreign-key-checks
5226                                                  
5227                                                  Disables foreign key checks with SET FOREIGN_KEY_CHECKS=0.
5228                                                  
5229                                                  =item --sleep
5230                                                  
5231                                                  type: int
5232                                                  
5233                                                  Sleep time between fetches.
5234                                                  
5235                                                  Specifies how long to sleep between SELECT statements.  Default is not to
5236                                                  sleep at all.  Transactions are NOT committed, and the L<"--file"> file is NOT
5237                                                  flushed, before sleeping.  See L<"--txn-size"> to control that.
5238                                                  
5239                                                  If L<"--commit-each"> is specified, committing and flushing happens before
5240                                                  sleeping.
5241                                                  
5242                                                  =item --sleep-coef
5243                                                  
5244                                                  type: float
5245                                                  
5246                                                  Calculate L<"--sleep"> as a multiple of the last SELECT time.
5247                                                  
5248                                                  If this option is specified, mk-archiver will sleep for the query time of the
5249                                                  last SELECT multiplied by the specified coefficient.  This option is ignored
5250                                                  if L<"--sleep"> is specified.
5251                                                  
5252                                                  This is a slightly more sophisticated way to throttle the SELECTs: sleep a
5253                                                  varying amount of time between each SELECT, depending on how long the SELECTs
5254                                                  are taking.
5255                                                  
5256                                                  =item --socket
5257                                                  
5258                                                  short form: -S; type: string
5259                                                  
5260                                                  Socket file to use for connection.
5261                                                  
5262                                                  =item --source
5263                                                  
5264                                                  type: DSN
5265                                                  
5266                                                  DSN specifying the table to archive from (required).  This argument is a DSN.
5267                                                  See L<DSN OPTIONS> for the syntax.  Most options control how mk-archiver
5268                                                  connects to MySQL, but there are some extended DSN options in this tool's
5269                                                  syntax.  The D, t, and i options select a table to archive:
5270                                                  
5271                                                    --source h=my_server,D=my_database,t=my_tbl
5272                                                  
5273                                                  The a option specifies the database to set as the connection's default with USE.
5274                                                  If the b option is true, it disables binary logging with SQL_LOG_BIN.  The m
5275                                                  option specifies pluggable actions, which an external Perl module can provide.
5276                                                  The only required part is the table; other parts may be read from various
5277                                                  places in the environment (such as options files).
5278                                                  
5279                                                  The 'i' part deserves special mention.  This tells mk-archiver which index
5280                                                  it should scan to archive.  This appears in a FORCE INDEX or USE INDEX hint in
5281                                                  the SELECT statements used to fetch archivable rows.  If you don't specify
5282                                                  anything, mk-archiver will auto-discover a good index, preferring a C<PRIMARY
5283                                                  KEY> if one exists.  In my experience this usually works well, so most of the
5284                                                  time you can probably just omit the 'i' part.
5285                                                  
5286                                                  The index is used to optimize repeated accesses to the table; mk-archiver
5287                                                  remembers the last row it retrieves from each SELECT statement, and uses it to
5288                                                  construct a WHERE clause, using the columns in the specified index, that should
5289                                                  allow MySQL to start the next SELECT where the last one ended, rather than
5290                                                  potentially scanning from the beginning of the table with each successive
5291                                                  SELECT.  If you are using external plugins, please see L<"EXTENDING"> for a
5292                                                  discussion of how they interact with ascending indexes.
5293                                                  
5294                                                  The 'a' and 'b' options allow you to control how statements flow through the
5295                                                  binary log.  If you specify the 'b' option, binary logging will be disabled on
5296                                                  the specified connection.  If you specify the 'a' option, the connection will
5297                                                  C<USE> the specified database, which you can use to prevent slaves from
5298                                                  executing the binary log events with C<--replicate-ignore-db> options.  These
5299                                                  two options can be used as different methods to achieve the same goal: archive
5300                                                  data off the master, but leave it on the slave.  For example, you can run a
5301                                                  purge job on the master and prevent it from happening on the slave using your
5302                                                  method of choice.
5303                                                  
5304                                                  B<WARNING>: Using a default options file (F) DSN option that defines a
5305                                                  socket for L<"--source"> causes mk-archiver to connect to L<"--dest"> using
5306                                                  that socket unless another socket for L<"--dest"> is specified.  This
5307                                                  means that mk-archiver may incorrectly connect to L<"--source"> when it
5308                                                  is meant to connect to L<"--dest">.  For example:
5309                                                  
5310                                                    --source F=host1.cnf,D=db,t=tbl --dest h=host2
5311                                                  
5312                                                  When mk-archiver connects to L<"--dest">, host2, it will connect via the
5313                                                  L<"--source">, host1, socket defined in host1.cnf.
5314                                                  
5315                                                  =item --statistics
5316                                                  
5317                                                  Collect and print timing statistics.
5318                                                  
5319                                                  Causes mk-archiver to collect timing statistics about what it does.  These
5320                                                  statistics are available to the plugin specified by L<"--plugin">
5321                                                  
5322                                                  Unless you specify L<"--quiet">, C<mk-archiver> prints the statistics when it
5323                                                  exits.  The statistics look like this:
5324                                                  
5325                                                   Started at 2008-07-18T07:18:53, ended at 2008-07-18T07:18:53
5326                                                   Source: D=db,t=table
5327                                                   SELECT 4
5328                                                   INSERT 4
5329                                                   DELETE 4
5330                                                   Action         Count       Time        Pct
5331                                                   commit            10     0.1079      88.27
5332                                                   select             5     0.0047       3.87
5333                                                   deleting           4     0.0028       2.29
5334                                                   inserting          4     0.0028       2.28
5335                                                   other              0     0.0040       3.29
5336                                                  
5337                                                  The first two (or three) lines show times and the source and destination tables.
5338                                                  The next three lines show how many rows were fetched, inserted, and deleted.
5339                                                  
5340                                                  The remaining lines show counts and timing.  The columns are the action, the
5341                                                  total number of times that action was timed, the total time it took, and the
5342                                                  percent of the program's total runtime.  The rows are sorted in order of
5343                                                  descending total time.  The last row is the rest of the time not explicitly
5344                                                  attributed to anything.  Actions will vary depending on command-line options.
5345                                                  
5346                                                  If L<"--why-quit"> is given, its behavior is changed slightly.  This option
5347                                                  causes it to print the reason for exiting even when it's just because there are
5348                                                  no more rows.
5349                                                  
5350                                                  This option requires the standard Time::HiRes module, which is part of core Perl
5351                                                  on reasonably new Perl releases.
5352                                                  
5353                                                  =item --stop
5354                                                  
5355                                                  Stop running instances by creating the sentinel file.
5356                                                  
5357                                                  Causes mk-archiver to create the sentinel file specified by L<"--sentinel"> and
5358                                                  exit.  This should have the effect of stopping all running instances which are
5359                                                  watching the same sentinel file.
5360                                                  
5361                                                  =item --txn-size
5362                                                  
5363                                                  type: int; default: 1
5364                                                  
5365                                                  Number of rows per transaction.
5366                                                  
5367                                                  Specifies the size, in number of rows, of each transaction. Zero disables
5368                                                  transactions altogether.  After mk-archiver processes this many rows, it
5369                                                  commits both the L<"--source"> and the L<"--dest"> if given, and flushes the
5370                                                  file given by L<"--file">.
5371                                                  
5372                                                  This parameter is critical to performance.  If you are archiving from a live
5373                                                  server, which for example is doing heavy OLTP work, you need to choose a good
5374                                                  balance between transaction size and commit overhead.  Larger transactions
5375                                                  create the possibility of more lock contention and deadlocks, but smaller
5376                                                  transactions cause more frequent commit overhead, which can be significant.  To
5377                                                  give an idea, on a small test set I worked with while writing mk-archiver, a
5378                                                  value of 500 caused archiving to take about 2 seconds per 1000 rows on an
5379                                                  otherwise quiet MySQL instance on my desktop machine, archiving to disk and to
5380                                                  another table.  Disabling transactions with a value of zero, which turns on
5381                                                  autocommit, dropped performance to 38 seconds per thousand rows.
5382                                                  
5383                                                  If you are not archiving from or to a transactional storage engine, you may
5384                                                  want to disable transactions so mk-archiver doesn't try to commit.
5385                                                  
5386                                                  =item --user
5387                                                  
5388                                                  short form: -u; type: string
5389                                                  
5390                                                  User for login if not current user.
5391                                                  
5392                                                  =item --version
5393                                                  
5394                                                  Show version and exit.
5395                                                  
5396                                                  =item --where
5397                                                  
5398                                                  type: string
5399                                                  
5400                                                  WHERE clause to limit which rows to archive (required).
5401                                                  
5402                                                  Specifies a WHERE clause to limit which rows are archived.  Do not include the
5403                                                  word WHERE.  You may need to quote the argument to prevent your shell from
5404                                                  interpreting it.  For example:
5405                                                  
5406                                                     --where 'ts < current_date - interval 90 day'
5407                                                  
5408                                                  For safety, L<"--where"> is required.  If you do not require a WHERE clause, use
5409                                                  L<"--where"> 1=1.
5410                                                  
5411                                                  =item --why-quit
5412                                                  
5413                                                  Print reason for exiting unless rows exhausted.
5414                                                  
5415                                                  Causes mk-archiver to print a message if it exits for any reason other than
5416                                                  running out of rows to archive.  This can be useful if you have a cron job with
5417                                                  L<"--run-time"> specified, for example, and you want to be sure mk-archiver is
5418                                                  finishing before running out of time.
5419                                                  
5420                                                  If L<"--statistics"> is given, the behavior is changed slightly.  It will print
5421                                                  the reason for exiting even when it's just because there are no more rows.
5422                                                  
5423                                                  This output prints even if L<"--quiet"> is given.  That's so you can put
5424                                                  C<mk-archiver> in a C<cron> job and get an email if there's an abnormal exit.
5425                                                  
5426                                                  =back
5427                                                  
5428                                                  =head1 DSN OPTIONS
5429                                                  
5430                                                  These DSN options are used to create a DSN.  Each option is given like
5431                                                  C<option=value>.  The options are case-sensitive, so P and p are not the
5432                                                  same option.  There cannot be whitespace before or after the C<=> and
5433                                                  if the value contains whitespace it must be quoted.  DSN options are
5434                                                  comma-separated.  See the L<maatkit> manpage for full details.
5435                                                  
5436                                                  =over
5437                                                  
5438                                                  =item * a
5439                                                  
5440                                                  copy: no
5441                                                  
5442                                                  Database to USE when executing queries.
5443                                                  
5444                                                  =item * A
5445                                                  
5446                                                  dsn: charset; copy: yes
5447                                                  
5448                                                  Default character set.
5449                                                  
5450                                                  =item * b
5451                                                  
5452                                                  copy: no
5453                                                  
5454                                                  If true, disable binlog with SQL_LOG_BIN.
5455                                                  
5456                                                  =item * D
5457                                                  
5458                                                  dsn: database; copy: yes
5459                                                  
5460                                                  Database that contains the table.
5461                                                  
5462                                                  =item * F
5463                                                  
5464                                                  dsn: mysql_read_default_file; copy: yes
5465                                                  
5466                                                  Only read default options from the given file
5467                                                  
5468                                                  =item * h
5469                                                  
5470                                                  dsn: host; copy: yes
5471                                                  
5472                                                  Connect to host.
5473                                                  
5474                                                  =item * i
5475                                                  
5476                                                  copy: yes
5477                                                  
5478                                                  Index to use.
5479                                                  
5480                                                  =item * m
5481                                                  
5482                                                  copy: no
5483                                                  
5484                                                  Plugin module name.
5485                                                  
5486                                                  =item * p
5487                                                  
5488                                                  dsn: password; copy: yes
5489                                                  
5490                                                  Password to use when connecting.
5491                                                  
5492                                                  =item * P
5493                                                  
5494                                                  dsn: port; copy: yes
5495                                                  
5496                                                  Port number to use for connection.
5497                                                  
5498                                                  =item * S
5499                                                  
5500                                                  dsn: mysql_socket; copy: yes
5501                                                  
5502                                                  Socket file to use for connection.
5503                                                  
5504                                                  =item * t
5505                                                  
5506                                                  copy: yes
5507                                                  
5508                                                  Table to archive from/to.
5509                                                  
5510                                                  =item * u
5511                                                  
5512                                                  dsn: user; copy: yes
5513                                                  
5514                                                  User for login if not current user.
5515                                                  
5516                                                  =back
5517                                                  
5518                                                  =head1 EXTENDING
5519                                                  
5520                                                  mk-archiver is extensible by plugging in external Perl modules to handle some
5521                                                  logic and/or actions.  You can specify a module for both the L<"--source"> and
5522                                                  the L<"--dest">, with the 'm' part of the specification.  For example:
5523                                                  
5524                                                     --source D=test,t=test1,m=My::Module1 --dest m=My::Module2,t=test2
5525                                                  
5526                                                  This will cause mk-archiver to load the My::Module1 and My::Module2 packages,
5527                                                  create instances of them, and then make calls to them during the archiving
5528                                                  process.
5529                                                  
5530                                                  You can also specify a plugin with L<"--plugin">.
5531                                                  
5532                                                  The module must provide this interface:
5533                                                  
5534                                                  =over
5535                                                  
5536                                                  =item new(dbh => $dbh, db => $db_name, tbl => $tbl_name)
5537                                                  
5538                                                  The plugin's constructor is passed a reference to the database handle, the
5539                                                  database name, and table name.  The plugin is created just after mk-archiver
5540                                                  opens the connection, and before it examines the table given in the arguments.
5541                                                  This gives the plugin a chance to create and populate temporary tables, or do
5542                                                  other setup work.
5543                                                  
5544                                                  =item before_begin(cols => \@cols, allcols => \@allcols)
5545                                                  
5546                                                  This method is called just before mk-archiver begins iterating through rows
5547                                                  and archiving them, but after it does all other setup work (examining table
5548                                                  structures, designing SQL queries, and so on).  This is the only time
5549                                                  mk-archiver tells the plugin column names for the rows it will pass the
5550                                                  plugin while archiving.
5551                                                  
5552                                                  The C<cols> argument is the column names the user requested to be archived,
5553                                                  either by default or by the L<"--columns"> option.  The C<allcols> argument is
5554                                                  the list of column names for every row mk-archiver will fetch from the source
5555                                                  table.  It may fetch more columns than the user requested, because it needs some
5556                                                  columns for its own use.  When subsequent plugin functions receive a row, it is
5557                                                  the full row containing all the extra columns, if any, added to the end.
5558                                                  
5559                                                  =item is_archivable(row => \@row)
5560                                                  
5561                                                  This method is called for each row to determine whether it is archivable.  This
5562                                                  applies only to L<"--source">.  The argument is the row itself, as an arrayref.
5563                                                  If the method returns true, the row will be archived; otherwise it will be
5564                                                  skipped.
5565                                                  
5566                                                  Skipping a row adds complications for non-unique indexes.  Normally
5567                                                  mk-archiver uses a WHERE clause designed to target the last processed row as
5568                                                  the place to start the scan for the next SELECT statement.  If you have skipped
5569                                                  the row by returning false from is_archivable(), mk-archiver could get into
5570                                                  an infinite loop because the row still exists.  Therefore, when you specify a
5571                                                  plugin for the L<"--source"> argument, mk-archiver will change its WHERE clause
5572                                                  slightly.  Instead of starting at "greater than or equal to" the last processed
5573                                                  row, it will start "strictly greater than."  This will work fine on unique
5574                                                  indexes such as primary keys, but it may skip rows (leave holes) on non-unique
5575                                                  indexes or when ascending only the first column of an index.
5576                                                  
5577                                                  C<mk-archiver> will change the clause in the same way if you specify
5578                                                  L<"--no-delete">, because again an infinite loop is possible.
5579                                                  
5580                                                  If you specify the L<"--bulk-delete"> option and return false from this method,
5581                                                  C<mk-archiver> may not do what you want.  The row won't be archived, but it will
5582                                                  be deleted, since bulk deletes operate on ranges of rows and don't know which
5583                                                  rows the plugin selected to keep.
5584                                                  
5585                                                  If you specify the L<"--bulk-insert"> option, this method's return value will
5586                                                  influence whether the row is written to the temporary file for the bulk insert,
5587                                                  so bulk inserts will work as expected.  However, bulk inserts require bulk
5588                                                  deletes.
5589                                                  
5590                                                  =item before_delete(row => \@row)
5591                                                  
5592                                                  This method is called for each row just before it is deleted.  This applies only
5593                                                  to L<"--source">.  This is a good place for you to handle dependencies, such as
5594                                                  deleting things that are foreign-keyed to the row you are about to delete.  You
5595                                                  could also use this to recursively archive all dependent tables.
5596                                                  
5597                                                  This plugin method is called even if L<"--no-delete"> is given, but not if
5598                                                  L<"--bulk-delete"> is given.
5599                                                  
5600                                                  =item before_bulk_delete(first_row => \@row, last_row => \@row)
5601                                                  
5602                                                  This method is called just before a bulk delete is executed.  It is similar to
5603                                                  the C<before_delete> method, except its arguments are the first and last row of
5604                                                  the range to be deleted.  It is called even if L<"--no-delete"> is given.
5605                                                  
5606                                                  =item before_insert(row => \@row)
5607                                                  
5608                                                  This method is called for each row just before it is inserted.  This applies
5609                                                  only to L<"--dest">.  You could use this to insert the row into multiple tables,
5610                                                  perhaps with an ON DUPLICATE KEY UPDATE clause to build summary tables in a data
5611                                                  warehouse.
5612                                                  
5613                                                  This method is not called if L<"--bulk-insert"> is given.
5614                                                  
5615                                                  =item before_bulk_insert(first_row => \@row, last_row => \@row, filename => bulk_insert_filename)
5616                                                  
5617                                                  This method is called just before a bulk insert is executed.  It is similar to
5618                                                  the C<before_insert> method, except its arguments are the first and last row of
5619                                                  the range to be deleted.
5620                                                  
5621                                                  =item custom_sth(row => \@row, sql => $sql)
5622                                                  
5623                                                  This method is called just before inserting the row, but after
5624                                                  L<"before_insert()">.  It allows the plugin to specify different C<INSERT>
5625                                                  statement if desired.  The return value (if any) should be a DBI statement
5626                                                  handle.  The C<sql> parameter is the SQL text used to prepare the default
5627                                                  C<INSERT> statement.  This method is not called if you specify
5628                                                  L<"--bulk-insert">.
5629                                                  
5630                                                  If no value is returned, the default C<INSERT> statement handle is used.
5631                                                  
5632                                                  This method applies only to the plugin specified for L<"--dest">, so if your
5633                                                  plugin isn't doing what you expect, check that you've specified it for the
5634                                                  destination and not the source.
5635                                                  
5636                                                  =item custom_sth_bulk(first_row => \@row, last_row => \@row, sql => $sql, filename => $bulk_insert_filename)
5637                                                  
5638                                                  If you've specified L<"--bulk-insert">, this method is called just before the
5639                                                  bulk insert, but after L<"before_bulk_insert()">, and the arguments are
5640                                                  different.
5641                                                  
5642                                                  This method's return value etc is similar to the L<"custom_sth()"> method.
5643                                                  
5644                                                  =item after_finish()
5645                                                  
5646                                                  This method is called after mk-archiver exits the archiving loop, commits all
5647                                                  database handles, closes L<"--file">, and prints the final statistics, but
5648                                                  before mk-archiver runs ANALYZE or OPTIMIZE (see L<"--analyze"> and
5649                                                  L<"--optimize">).
5650                                                  
5651                                                  =back
5652                                                  
5653                                                  If you specify a plugin for both L<"--source"> and L<"--dest">, mk-archiver
5654                                                  constructs, calls before_begin(), and calls after_finish() on the two plugins in
5655                                                  the order L<"--source">, L<"--dest">.
5656                                                  
5657                                                  mk-archiver assumes it controls transactions, and that the plugin will NOT
5658                                                  commit or roll back the database handle.  The database handle passed to the
5659                                                  plugin's constructor is the same handle mk-archiver uses itself.  Remember
5660                                                  that L<"--source"> and L<"--dest"> are separate handles.
5661                                                  
5662                                                  A sample module might look like this:
5663                                                  
5664                                                     package My::Module;
5665                                                  
5666                                                     sub new {
5667                                                        my ( $class, %args ) = @_;
5668                                                        return bless(\%args, $class);
5669                                                     }
5670                                                  
5671                                                     sub before_begin {
5672                                                        my ( $self, %args ) = @_;
5673                                                        # Save column names for later
5674                                                        $self->{cols} = $args{cols};
5675                                                     }
5676                                                  
5677                                                     sub is_archivable {
5678                                                        my ( $self, %args ) = @_;
5679                                                        # Do some advanced logic with $args{row}
5680                                                        return 1;
5681                                                     }
5682                                                  
5683                                                     sub before_delete {} # Take no action
5684                                                     sub before_insert {} # Take no action
5685                                                     sub custom_sth    {} # Take no action
5686                                                     sub after_finish  {} # Take no action
5687                                                  
5688                                                     1;
5689                                                  
5690                                                  =head1 DOWNLOADING
5691                                                  
5692                                                  You can download Maatkit from Google Code at
5693                                                  L<http://code.google.com/p/maatkit/>, or you can get any of the tools
5694                                                  easily with a command like the following:
5695                                                  
5696                                                     wget http://www.maatkit.org/get/toolname
5697                                                     or
5698                                                     wget http://www.maatkit.org/trunk/toolname
5699                                                  
5700                                                  Where C<toolname> can be replaced with the name (or fragment of a name) of any
5701                                                  of the Maatkit tools.  Once downloaded, they're ready to run; no installation is
5702                                                  needed.  The first URL gets the latest released version of the tool, and the
5703                                                  second gets the latest trunk code from Subversion.
5704                                                  
5705                                                  =head1 ENVIRONMENT
5706                                                  
5707                                                  The environment variable C<MKDEBUG> enables verbose debugging output in all of
5708                                                  the Maatkit tools:
5709                                                  
5710                                                     MKDEBUG=1 mk-....
5711                                                  
5712                                                  =head1 SYSTEM REQUIREMENTS
5713                                                  
5714                                                  You need Perl, DBI, DBD::mysql, and some core packages that ought to be
5715                                                  installed in any reasonably new version of Perl.
5716                                                  
5717                                                  =head1 BUGS
5718                                                  
5719                                                  For a list of known bugs see L<http://www.maatkit.org/bugs/mk-archiver>.
5720                                                  
5721                                                  Please use Google Code Issues and Groups to report bugs or request support:
5722                                                  L<http://code.google.com/p/maatkit/>.  You can also join #maatkit on Freenode to
5723                                                  discuss Maatkit.
5724                                                  
5725                                                  Please include the complete command-line used to reproduce the problem you are
5726                                                  seeing, the version of all MySQL servers involved, the complete output of the
5727                                                  tool when run with L<"--version">, and if possible, debugging output produced by
5728                                                  running with the C<MKDEBUG=1> environment variable.
5729                                                  
5730                                                  =head1 ACKNOWLEDGMENTS
5731                                                  
5732                                                  Thanks to the following people, and apologies to anyone I've omitted:
5733                                                  
5734                                                  Andrew O'Brien,
5735                                                  
5736                                                  =head1 COPYRIGHT, LICENSE AND WARRANTY
5737                                                  
5738                                                  This program is copyright 2007-@CURRENTYEAR@ Baron Schwartz.
5739                                                  Feedback and improvements are welcome.
5740                                                  
5741                                                  THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
5742                                                  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
5743                                                  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
5744                                                  
5745                                                  This program is free software; you can redistribute it and/or modify it under
5746                                                  the terms of the GNU General Public License as published by the Free Software
5747                                                  Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
5748                                                  systems, you can issue `man perlgpl' or `man perlartistic' to read these
5749                                                  licenses.
5750                                                  
5751                                                  You should have received a copy of the GNU General Public License along with
5752                                                  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
5753                                                  Place, Suite 330, Boston, MA  02111-1307  USA.
5754                                                  
5755                                                  =head1 AUTHOR
5756                                                  
5757                                                  Baron Schwartz
5758                                                  
5759                                                  =head1 ABOUT MAATKIT
5760                                                  
5761                                                  This tool is part of Maatkit, a toolkit for power users of MySQL.  Maatkit
5762                                                  was created by Baron Schwartz; Baron and Daniel Nichter are the primary
5763                                                  code contributors.  Both are employed by Percona.  Financial support for
5764                                                  Maatkit development is primarily provided by Percona and its clients. 
5765                                                  
5766                                                  =head1 VERSION
5767                                                  
5768                                                  This manual page documents Ver @VERSION@ Distrib @DISTRIB@ $Revision: 7328 $.
5769                                                  
5770                                                  =cut


Branches
--------

line  err      %   true  false   branch
----- --- ------ ------ ------   ------
55    ***      0      0      0   unless $args{$arg}
124   ***     50      0     43   unless open my $fh, '<', $file
127   ***     50     43      0   if ($contents =~ /^=head1 DSN OPTIONS/m)
137   ***     50    903      0   if ($val)
138          100    129    344   $val eq 'no' ? :
             100    430    473   $val eq 'yes' ? :
186   ***     50      0     86   unless open my $fh, '<', $file
194          100  60845     86   unless $para =~ /^=head1 $$self{'head1'}/
199          100     86    387   if $para =~ /^=over/
200          100     43    344   if $$self{'skip_rules'}
208   ***     50      0     86   unless $para
211          100   3139     86   if (my($option) = $para =~ /^=item $$self{'item'}/)
218          100   1935   1204   if ($para =~ /: /) { }
222   ***     50      0   2881   unless $$self{'attributes'}{$attrib}
226          100    344   1591   if ($attribs{'short form'})
242   ***     50      0   3139   if $para =~ /^=item/
244          100    129   3010   if (my($base_option) = $option =~ /^\[no\](.*)/)
249          100    430   2709   defined $attribs{'default'} ? :
      ***     50      0   3139   $attribs{'group'} ? :
257   ***     50      0   7697   unless $para
258          100     86   7611   if ($para =~ /^=head1/)
262          100   3139   4472   if $para =~ /^=item /
266   ***     50      0     86   unless @specs
277          100   2580    344   if (ref $opt) { }
282   ***     50      0   2580   if (not $long)
287   ***     50      0   2580   if exists $$self{'opts'}{$long}
290   ***     50      0   2580   if (length $long == 1)
295          100    344   2236   if ($short) { }
296   ***     50      0    344   if exists $$self{'short_opts'}{$short}
305          100    129   2451   $$opt{'spec'} =~ /!/ ? :
306   ***     50      0   2580   $$opt{'spec'} =~ /\+/ ? :
307          100     86   2494   $$opt{'desc'} =~ /required/ ? :
320          100    301   2279   if $type and $type =~ /[HhAadzm]/
322          100    430   2150   if (my($def) = $$opt{'desc'} =~ /default\b(?: ([^)]+))?/)
323   ***     50    430      0   defined $def ? :
327          100     43   2537   if ($long eq 'config')
331          100     43   2537   if (my($dis) = $$opt{'desc'} =~ /(disables .*)/)
344          100    258     86   if ($opt =~ /mutually exclusive|one and only one/)
349          100     43    301   if ($opt =~ /at least one|one and only one/)
354          100     43    301   if ($opt =~ /default to/)
359   ***     50      0    344   if ($opt =~ /restricted to option groups/)
368   ***     50      0    344   if ($opt =~ /accepts additional command-line arguments/)
374   ***     50      0    344   unless $rule_ok
391   ***     50      0    774   unless exists $$self{'opts'}{$long}
415   ***      0      0      0   unless exists $$self{'opts'}{$long}
435   ***      0      0      0   exists $$self{'short_opts'}{$opt} ? :
      ***     50    206      0   exists $$self{'opts'}{$opt} ? :
440   ***     50      0    206   if ($$opt{'is_cumulative'}) { }
455   ***     50      0   2107   $$self{'opts'}{$long}{'is_cumulative'} ? :
             100    473   2107   exists $$self{'defaults'}{$long} ? :
464   ***     50      0     43   if (@ARGV and $ARGV[0] eq '--config')
468   ***     50     43      0   if ($self->has('config'))
474   ***     50    172      0   if ($EVAL_ERROR)
475   ***     50      0    172   $self->got('config') ? :
490   ***     50      0     43   unless GetOptions map({$$_{'spec'}, sub {
	$self->_set_option(@_);
}
;} grep({$$_{'long'} ne 'config';} values %{$$self{'opts'};}))
493   ***     50      0     43   if (exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'})
494   ***      0      0      0   unless printf "%s  Ver %s Distrib %s Changeset %s\n", $$self{'program_name'}, $main::VERSION, $main::DISTRIB, $main::SVN_REV
500   ***     50      0     43   if (@ARGV and $$self{'strict'})
506   ***     50      0    258   if (@set > 1)
517          100      1     42   if (@set == 0)
536   ***     50      0   2580   unless $long
538          100    205   2375   if ($$opt{'got'}) { }
             100      2   2373   elsif ($$opt{'is_required'}) { }
539          100      2    203   if (exists $$self{'disables'}{$long})
546   ***     50      0    205   if (exists $$self{'allowed_groups'}{$long})
558   ***      0      0      0   if $restricted_opt eq $long
559   ***      0      0      0   if $$self{'opts'}{$restricted_opt}{'got'}
564   ***      0      0      0   if (@restricted_opts)
566   ***      0      0      0   if (@restricted_opts == 1) { }
587   ***     50   2580      0   if ($$opt{'parsed'}) { }
595   ***     50      0     43   if @long == $long_last
605   ***     50      0   2580   unless $opt
607          100   1376   1204   if (not $$opt{'type'})
614          100     86   1118   if ($val and $$opt{'type'} eq 'm') { }
             100     61   1057   elsif ($val and $$opt{'type'} eq 'd') { }
      ***     50      0   1057   elsif ($val and $$opt{'type'} eq 'z') { }
      ***     50      0   1057   elsif ($$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h') { }
             100     47   1010   elsif ($$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a') { }
617   ***     50      0     86   if (not $suffix)
623   ***     50     86      0   if ($suffix =~ /[smhd]/) { }
624   ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***     50     86      0   $suffix eq 's' ? :
639          100     19     42   if ($from_key)
641   ***     50     19      0   if ($$self{'opts'}{$from_key}{'parsed'}) { }
674          100    366   4122   length $opt == 1 ? :
675   ***     50      0   4488   unless $long and exists $$self{'opts'}{$long}
682   ***     50      0    214   length $opt == 1 ? :
683   ***     50      0    214   unless $long and exists $$self{'opts'}{$long}
690          100    793     43   length $opt == 1 ? :
691          100    409    427   defined $long ? :
696   ***     50      0      5   length $opt == 1 ? :
697   ***     50      0      5   unless $long and exists $$self{'opts'}{$long}
716   ***      0      0      0   unless $$self{'usage'}
722   ***      0      0      0   unless $$self{'description'}
727   ***      0      0      0   unless $ENV{'DONT_BREAK_LINES'}
737   ***     50     42      0   if (not $$self{'description'} or not $$self{'usage'})
746   ***     50      0     42   if ($$self{'opts'}{'help'}{'got'}) { }
      ***     50      0     42   elsif (scalar @{$$self{'errors'};}) { }
747   ***      0      0      0   unless print $self->print_usage
748   ***      0      0      0   unless $return
751   ***      0      0      0   unless print $self->print_errors
752   ***      0      0      0   unless $return
761   ***      0      0      0   if (my(@errors) = @{$$self{'errors'};})
770   ***      0      0      0   unless $$self{'got_opts'}
773   ***      0      0      0   $$_{'is_negatable'} ? :
      ***      0      0      0   $$_{'type'} ? :
781   ***      0      0      0   $$self{'opts'}{$_}{'is_negatable'} ? :
      ***      0      0      0   $$self{'opts'}{$_}{'type'} ? :
801   ***      0      0      0   $group eq 'default' ? :
807   ***      0      0      0   $$opt{'is_negatable'} ? :
811   ***      0      0      0   $$opt{'type'} ? :
813   ***      0      0      0   if ($$opt{'type'} and $$opt{'type'} eq 'm')
822   ***      0      0      0   if ($short) { }
833   ***      0      0      0   if (my(@rules) = @{$$self{'rules'};})
837   ***      0      0      0   if ($$self{'DSNParser'})
845   ***      0      0      0   $val ? :
      ***      0      0      0   $type =~ /A|a/ ? :
      ***      0      0      0   $type =~ /H|h/ ? :
      ***      0      0      0   $type eq 'd' ? :
      ***      0      0      0   !defined($val) ? :
      ***      0      0      0   $bool ? :
857   ***      0      0      0   if ref $_[0] eq 'OptionParser'
860   ***      0      0      0   unless print $prompt
868   ***      0      0      0   unless print "\n"
871   ***      0      0      0   if ($EVAL_ERROR)
893   ***     50    172      0   unless open my $fh, '<', $filename
901   ***      0      0      0   if $line =~ /^\s*(?:\#|\;|$)/
904   ***      0      0      0   if ($line eq '--')
909   ***      0      0      0   if ($parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/) { }
      ***      0      0      0   elsif ($line =~ /./) { }
927   ***      0      0      0   unless open my $fh, '<', $file
931   ***      0      0      0   unless $para =~ /^=pod$/m
935   ***      0      0      0   unless $para =~ /$regex/
940   ***      0      0      0   unless close $fh
954   ***      0      0      0   $ref eq 'ARRAY' ? :
      ***      0      0      0   $ref eq 'HASH' ? :
      ***      0      0      0   !$ref ? :
970   ***      0      0      0   if (lc($val || '') eq 'null')
978   ***      0      0      0   if (defined $num) { }
979   ***      0      0      0   if ($factor)
995          100    344   2236   $$attribs{'short form'} ? :
             100    129   2451   $$attribs{'negatable'} ? :
      ***     50      0   2580   $$attribs{'cumulative'} ? :
             100   1204   1376   $$attribs{'type'} ? :
1008  ***     50      0     42   unless open my $fh, '<', $file
1011  ***     50      0     42   unless $para
1020  ***     50      0     42   unless $usage and $desc
1039  ***      0      0      0   defined $_ ? :
1076  ***     50      0     42   unless $args{$arg}
1084  ***     50      0     61   unless $ddl
1085  ***     50     61      0   if (ref $ddl eq 'ARRAY')
1086  ***     50     61      0   if (lc $$ddl[0] eq 'table') { }
1096  ***     50      0     61   if (not $ddl =~ /CREATE (?:TEMPORARY )?TABLE `/)
1102  ***     50     61      0   if $name
1120  ***     50      0    234   unless $type
1122         100    164     70   if ($type =~ /(?:(?:tiny|big|medium|small)?int|float|double|decimal|year)/)
1126         100    100    134   if (not $def =~ /NOT NULL/)
1130         100     21    213   $def =~ /AUTO_INCREMENT/i ? :
1164  ***     50      0     28   unless ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'} or $$tbl{'keys'}{$a}{'is_nullable'} <=> $$tbl{'keys'}{$b}{'is_nullable'}
1178  ***     50      0     39   if ($index)
1181  ***     50     39      0   if (not $best)
1182  ***     50      0     39   if ($index) { }
1195  ***      0      0      0   unless $where
1201  ***      0      0      0   if ($$expl{'possible_keys'}) { }
1205  ***      0      0      0   if ($$expl{'key'})
1225  ***      0      0      0   unless $args{$arg}
1239  ***      0      0      0   if ($EVAL_ERROR)
1243  ***      0      0      0   if (not $$row[0] or $$row[0] ne $tbl)
1249  ***      0      0      0   unless $args{'all_privs'}
1256  ***      0      0      0   if ($EVAL_ERROR)
1260  ***      0      0      0   if (not scalar keys %$row)
1271  ***      0      0      0   $EVAL_ERROR ? :
1276  ***      0      0      0   if (not $privs =~ /select/ && $privs =~ /insert/ && $privs =~ /update/ && $can_delete)
1302  ***     50      0     85   if $key =~ /FOREIGN/
1307  ***     50     85      0   if (not $engine =~ /MEMORY|HEAP/)
1314  ***     50      0     85   if ($$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000' and $engine =~ /HEAP|MEMORY/i)
1321         100     55     30   $key =~ /PRIMARY|UNIQUE/ ? :
1345         100     46     39   if ($engine =~ /InnoDB/i and not $clustered_key)
1347  ***     50     46      0   if ($$this_key{'name'} eq 'PRIMARY') { }
      ***      0      0      0   elsif ($$this_key{'is_unique'} and not $$this_key{'is_nullable'}) { }
1371  ***      0      0      0   if (not $parent =~ /\./ and $$opts{'database'})
1400  ***      0      0      0   if (($$tbl_struct{'engine'} || '') =~ /InnoDB/i) { }
1410  ***      0      0      0   unless $key_ddl =~ /,$/
1417  ***      0      0      0   if (@sec_indexes)
1434  ***      0      0      0   defined $_ ? :
1475  ***     50      0     64   unless $args{$arg}
1481  ***     50      0    748   if (not $$opt{'key'} or not $$opt{'desc'})
1501         100     43    319   if (@_ > 2)
1510         100     61     86   if (not $dsn)
1522  ***     50    251      0   if (my($prop_key, $prop_val) = $dsn_part =~ /^(.)=(.*)$/) { }
1534         100     38    980   if (not defined $final_props{$key} and defined $$prev{$key} and $$opts{$key}{'copy'})
1540         100    729    289   if (not defined $final_props{$key})
1547  ***     50      0    251   unless exists $$opts{$key}
1552  ***     50      0     86   if (my $required = $self->prop('required'))
1554  ***      0      0      0   unless $final_props{$key}
1566  ***     50      0     61   unless ref $o eq 'OptionParser'
1569         100    366    427   if $o->has($_)
1579  ***     50      0      9   unless ref $dsn
1580  ***     50      0      9   $props ? :
1581  ***     50      0     27   $_ eq 'p' ? :
1582         100     63     90   if defined $$dsn{$_}
1583  ***     50      0    153   unless not $props
1596  ***      0      0      0   $opts{$key}{'copy'} ? :
1610  ***     50      0     86   if ($driver eq 'Pg') { }
1642  ***     50      0     86   $cxn_string =~ /charset=utf8/ ? :
1651  ***     50      0     86   if ($$opts{'mysql_use_result'})
1655  ***     50      0     86   if (not $have_dbi)
1674  ***     50     86      0   if ($cxn_string =~ /mysql/i)
1681  ***     50      0     86   $sql_mode ? :
1688  ***     50      0     86   if (my($charset) = $cxn_string =~ /charset=(\w+)/)
1693  ***      0      0      0   if ($charset eq 'utf8') { }
1694  ***      0      0      0   unless binmode STDOUT, ':utf8'
1698  ***      0      0      0   unless binmode STDOUT
1702         100     61     25   if ($self->prop('set-vars'))
1709  ***     50      0     86   if (not $dbh and $EVAL_ERROR)
1711  ***      0      0      0   if ($EVAL_ERROR =~ /not a compiled character set|character set utf8/) { }
      ***      0      0      0   elsif ($EVAL_ERROR =~ m[locate DBD/mysql]i) { }
1724  ***      0      0      0   if (not $tries)
1746  ***      0      0      0   if (my($host) = ($$dbh{'mysql_hostinfo'} || '') =~ /^(\w+) via/)
1763  ***      0      0      0   ($$thing{'Type'} || '') eq 'st' ? :
      ***      0      0      0   unless printf "# Active %sh: %s %s %s\n", $$thing{'Type'} || 'undef', "\t" x $level, $thing, ($$thing{'Type'} || '') eq 'st' ? $$thing{'Statement'} || '' : ''
1773  ***      0      0      0   unless $dsn_1
1774  ***      0      0      0   unless $dsn_2
1778  ***      0      0      0   if ($args{'overwrite'}) { }
1779  ***      0      0      0   defined $$dsn_1{$key} ? :
1782  ***      0      0      0   defined $$dsn_2{$key} ? :
1791  ***      0      0      0   defined $_ ? :
1834         100     61     36   if (not $$self{$dbh})
1838  ***     50     97      0   $$self{$dbh} ge $self->parse($target) ? :
1845  ***      0      0      0   unless $dbh
1856  ***      0      0      0   if ($innodb)
1858  ***      0      0      0   if ($$innodb{'support'} =~ /YES|DEFAULT/i) { }
1861  ***      0      0      0   !$vars ? :
1875  ***      0      0      0   defined $_ ? :
1920  ***     50      0      6   unless defined $val
1921  ***     50      0      6   if $val eq ''
1922  ***     50      0      6   if $val =~ /^0x[0-9a-fA-F]+$/
1932  ***     50     61      0   if (not $tbl)
1941  ***      0      0      0   unless $like
1948  ***      0      0      0   unless $db_tbl
1950  ***      0      0      0   if (not $tbl)
1954  ***      0      0      0   if $db and not $db =~ /^`/
1955  ***      0      0      0   if $tbl and not $tbl =~ /^`/
1956  ***      0      0      0   $db ? :
1986  ***     50      0     78   unless $args{$arg}
1996  ***     50      0     82   unless defined $args{$arg}
1999  ***     50     41      0   $args{'cols'} ? :
2002  ***     50      0     41   unless exists $$tbl_struct{'keys'}{$index}
2011  ***     50      0     41   if ($args{'asc_first'})
2018  ***     50      0     50   if (not exists $col_posn{$col})
2034  ***     50     41      0   if (@asc_slice)
2046         100      3     38   $args{'asc_only'} ? :
2058  ***     50      0    656   unless defined $args{$arg}
2079  ***     50      0     72   if ($$is_nullable{$col}) { }
2095  ***     50      0    200   if ($$is_nullable{$col}) { }
2096  ***      0      0      0   if ($type =~ /=/ and $end) { }
      ***      0      0      0   elsif ($type =~ />/) { }
2111         100     82    118   $type =~ /=/ && $end ? :
2129  ***     50     39      0   $args{'cols'} ? :
2137  ***     50      0     39   unless $index
2139  ***     50     39      0   if ($index) { }
2149         100      2     46   if (not exists $col_posn{$col})
2170  ***     50      0     48   if ($$tbl{'is_nullable'}{$col}) { }
2190  ***     50      0     34   unless $args{$arg}
2195  ***     50      0     17   unless @sel_cols
2200         100      6     63   unless $$ins_tbl{'is_col'}{$sel_cols[$i]}
2213  ***      0      0      0   defined $_ ? :
2277  ***      0      0      0   if ($what eq 'table') { }
      ***      0      0      0   elsif ($what eq 'triggers') { }
      ***      0      0      0   elsif ($what eq 'view') { }
2279  ***      0      0      0   unless $ddl
2280  ***      0      0      0   if ($$ddl[0] eq 'table') { }
2294  ***      0      0      0   if ($trgs and @$trgs) { }
2297  ***      0      0      0   if ($$trg{'sql_mode'})
2301  ***      0      0      0   if ($$trg{'definer'})
2333  ***     50      0     61   if (not $new)
2345  ***     50     61      0   if (not $$self{'cache'} or not $$self{'tables'}{$db}{$tbl})
2358  ***     50      0     61   if ($EVAL_ERROR)
2368  ***     50     61      0   if ($key) { }
2384  ***      0      0      0   if (not $$self{'cache'} or not $$self{'columns'}{$db}{$tbl})
2414  ***      0      0      0   if (not $$self{'cache'} or not $$self{'triggers'}{$db})
2427  ***      0      0      0   if ($sth->rows)
2440  ***      0      0      0   if ($tbl)
2448  ***      0      0      0   if (not $$self{'cache'} or not $$self{'databases'} or $like)
2451  ***      0      0      0   if ($like)
2459  ***      0      0      0   unless $like
2467  ***      0      0      0   if (not $$self{'cache'} or not $$self{'table_status'}{$db} or $like)
2470  ***      0      0      0   if ($like)
2485  ***      0      0      0   unless $like
2493  ***      0      0      0   if (not $$self{'cache'} or not $$self{'table_list'}{$db} or $like)
2496  ***      0      0      0   if ($like)
2504  ***      0      0      0   ($$_[1] || '') eq 'VIEW' ? :
2511  ***      0      0      0   unless $like
2519  ***      0      0      0   defined $_ ? :
2553  ***      0      0      0   unless $args{$arg}
2556  ***      0      0      0   $o->has('log') ? :
      ***      0      0      0   $o->has('pid') ? :
2572  ***      0      0      0   unless defined(my $pid = fork)
2573  ***      0      0      0   if ($pid)
2581  ***      0      0      0   unless POSIX::setsid()
2582  ***      0      0      0   unless chdir '/'
2588  ***      0      0      0   if (-t STDIN)
2590  ***      0      0      0   unless open STDIN, '/dev/null'
2594  ***      0      0      0   if ($$self{'log_file'}) { }
2596  ***      0      0      0   unless open STDOUT, '>>', $$self{'log_file'}
2600  ***      0      0      0   unless open STDERR, '>&STDOUT'
2604  ***      0      0      0   if (-t STDOUT)
2606  ***      0      0      0   unless open STDOUT, '>', '/dev/null'
2609  ***      0      0      0   if (-t STDERR)
2611  ***      0      0      0   unless open STDERR, '>', '/dev/null'
2622  ***      0      0      0   $self ? :
2624  ***      0      0      0   if ($PID_file and -f $PID_file) { }
2627  ***      0      0      0   if $EVAL_ERROR
2629  ***      0      0      0   if ($pid) { }
2631  ***      0      0      0   if ($pid_is_alive) { }
2653  ***      0      0      0   if (exists $$self{'child'})
2665  ***      0      0      0   if (not $PID_file)
2672  ***      0      0      0   unless open my $PID_FH, '>', $PID_file
2674  ***      0      0      0   unless print $PID_FH $PID
2676  ***      0      0      0   unless close $PID_FH
2685  ***      0      0      0   if ($$self{'PID_file'} and -f $$self{'PID_file'}) { }
2686  ***      0      0      0   unless unlink $$self{'PID_file'}
2699  ***      0      0      0   if ($$self{'PID_owner'} || 0) == $PID
2706  ***      0      0      0   defined $_ ? :
2760  ***      0      0      0   if ($EVAL_ERROR)
2761  ***      0      0      0   unless print STDERR 'Cannot connect to ', $dp->as_string($dsn), "\n"
2771  ***      0      0      0   if (not defined $id or defined $master_thinks_i_am and $master_thinks_i_am != $id or $$args{'server_ids_seen'}{$id}++)
2776  ***      0      0      0   if ($$args{'skip_callback'})
2784  ***      0      0      0   if (not defined $$args{'recurse'} or $level < $$args{'recurse'})
2786  ***      0      0      0   unless not $$_{'master_id'}
2803  ***      0      0      0   if ($method) { }
2808  ***      0      0      0   if (($$dsn{'P'} || 3306) != 3306)
2822  ***      0      0      0   if @slaves
2840  ***      0      0      0   if ($host eq 'localhost')
2857  ***      0      0      0   if (@slaves)
2862  ***      0      0      0   $hash{'user'} ? :
      ***      0      0      0   $hash{'password'} ? :
2882  ***      0      0      0   if ($vp and not $vp->version_ge($dbh, '4.1.2'))
2895  ***      0      0      0   if ($EVAL_ERROR)
2897  ***      0      0      0   if ($EVAL_ERROR =~ /no such grant defined for user/)
2910  ***      0      0      0   if $EVAL_ERROR
2912  ***      0      0      0   if (not $proc)
2929  ***      0      0      0   unless my $master_status = $self->get_master_status($master)
2931  ***      0      0      0   unless my $slave_status = $self->get_slave_status($slave)
2933  ***      0      0      0   unless my(@connected) = $self->get_connected_slaves($master)
2937  ***      0      0      0   if ($port != $$slave_status{'master_port'})
2942  ***      0      0      0   if (not grep {$$slave_status{'master_user'} eq $$_{'user'};} @connected)
2947  ***      0      0      0   if (($$slave_status{'slave_io_state'} || '') eq 'Waiting for master to send event')
2954  ***      0      0      0   if ($master_log_name ne $slave_log_name or abs $master_log_num - $slave_log_num > 1)
2967  ***      0      0      0   unless my $master = $self->get_slave_status($dbh)
2974  ***      0      0      0   if (not $$self{'not_a_slave'}{$dbh})
2981  ***      0      0      0   if ($ss and %$ss)
2993  ***      0      0      0   if (not $$self{'not_a_master'}{$dbh})
3000  ***      0      0      0   if ($ms and %$ms)
3002  ***      0      0      0   if ($$ms{'file'} and $$ms{'position'})
3016  ***      0      0      0   unless $args{$arg}
3025  ***      0      0      0   if ($master_status) { }
3057  ***      0      0      0   if ($pos) { }
3083  ***      0      0      0   if ($self->pos_cmp($slave_pos, $master_pos) < 0) { }
3093  ***      0      0      0   if (not defined $result)
3095  ***      0      0      0   if (not $self->slave_is_running($slave_status)) { }
3100  ***      0      0      0   if ($self->pos_cmp($slave_pos, $master_pos) != 0)
3126  ***      0      0      0   if ($self->pos_cmp($s1_pos, $s2_pos) < 0) { }
      ***      0      0      0   elsif ($self->pos_cmp($s2_pos, $s1_pos) < 0) { }
3138  ***      0      0      0   if ($self->slave_is_running($s1_status) or $self->slave_is_running($s2_status) or $self->pos_cmp($s1_pos, $s2_pos) != 0)
3161  ***      0      0      0   unless my $master_dsn = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
3165  ***      0      0      0   unless my $gmaster_dsn = $self->get_master_dsn($master_dbh, $master_dsn, $dsn_parser)
3170  ***      0      0      0   if ($self->short_host($slave_dsn) eq $self->short_host($gmaster_dsn))
3184  ***      0      0      0   if (not $self->slave_is_running($mslave_status) and not $self->slave_is_running($slave_status) and $self->pos_cmp($master_pos, $slave_pos) == 0) { }
3199  ***      0      0      0   if ($self->short_host($mslave_status) ne $self->short_host($slave_status) or $self->pos_cmp($mslave_pos, $slave_pos) != 0)
3210  ***      0      0      0   if ($self->short_host($slave_dsn) eq $self->short_host($sib_dsn))
3214  ***      0      0      0   unless my $master_dsn1 = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
3218  ***      0      0      0   unless my $master_dsn2 = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
3220  ***      0      0      0   if ($self->short_host($master_dsn1) ne $self->short_host($master_dsn2))
3223  ***      0      0      0   unless my $sib_master_stat = $self->get_master_status($sib_dbh)
3225  ***      0      0      0   unless $self->has_slave_updates($sib_dbh)
3237  ***      0      0      0   if ($self->short_host($slave_status) ne $self->short_host($sib_dsn) or $self->pos_cmp($self->repl_posn($sib_master_stat), $slave_pos) != 0)
3249  ***      0      0      0   if ($self->short_host($slave_dsn) eq $self->short_host($unc_dsn))
3253  ***      0      0      0   unless my $master_dsn = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
3257  ***      0      0      0   unless my $gmaster_dsn = $self->get_master_dsn($master_dbh, $master_dsn, $dsn_parser)
3260  ***      0      0      0   unless my $unc_master_dsn = $self->get_master_dsn($unc_dbh, $unc_dsn, $dsn_parser)
3263  ***      0      0      0   if ($self->short_host($gmaster_dsn) ne $self->short_host($unc_master_dsn))
3267  ***      0      0      0   unless my $unc_master_stat = $self->get_master_status($unc_dbh)
3269  ***      0      0      0   unless $self->has_slave_updates($unc_dbh)
3277  ***      0      0      0   if ($self->pos_cmp($self->repl_posn($slave_status), $self->repl_posn($master_status)) != 0)
3291  ***      0      0      0   if ($self->short_host($slave_status) ne $self->short_host($unc_dsn) or $self->pos_cmp($self->repl_posn($unc_master_stat), $slave_pos) != 0)
3302  ***      0      0      0   unless my $stat = $self->get_slave_status($dbh)
3324  ***      0      0      0   if (exists $$status{'file'} and exists $$status{'position'}) { }
3352  ***      0      0      0   if ($$dsn{'master_host'}) { }
3360  ***      0      0      0   ($port || 3306) == 3306 ? :
3365  ***      0      0      0   unless $query
3368  ***      0      0      0   unless $type =~ /^binlog_dump|slave_io|slave_sql|all$/i
3372  ***      0      0      0   if ($type =~ /binlog_dump|all/i)
3373  ***      0      0      0   if ($$query{'Command'} || $$query{'command'} || '') eq 'Binlog Dump'
3376  ***      0      0      0   if (not $match)
3377  ***      0      0      0   if (($$query{'User'} || $$query{'user'} || '') eq 'system user') { }
3379  ***      0      0      0   if ($type ne 'all') { }
3382  ***      0      0      0   if ($state =~ /^init|end$/) { }
3394  ***      0      0      0   $type eq 'slave_io' && !$slave_sql ? :
      ***      0      0      0   $type eq 'slave_sql' && $slave_sql ? :
3407  ***      0      0      0   if (not defined $args{'check_known_ids'} or $args{'check_known_ids'})
3409  ***      0      0      0   if ($match) { }
3413  ***      0      0      0   if ($$self{'replication_thread'}{$id})
3432  ***      0      0      0   unless $args{$arg}
3439  ***      0      0      0   if ($status)
3440  ***      0      0      0   if defined $$status{$_}
3449  ***      0      0      0   if ($status)
3450  ***      0      0      0   if defined $$status{$_}
3464  ***      0      0      0   if $$row[1] and $$row[1] ne 'OFF'
3485  ***      0      0      0   defined $_ ? :
3572         100      1     42   if ($o->get('stop'))
3573  ***     50      0      1   unless my $sentinel_fh = 'IO::File'->new($sentinel, '>>')
3575  ***     50      0      1   unless print $sentinel_fh "Remove this file to permit mk-archiver to run\n"
3577  ***     50      0      1   unless close $sentinel_fh
3579  ***     50      1      0   unless $quiet
3585         100      2     40   if ($archive_file)
3587  ***     50      2      0   $src && $$src{'D'} ? :
      ***     50      2      0   $src && $$src{'t'} ? :
3600  ***     50     42      0   if (not $o->got('help'))
3601  ***     50      0     42   unless $$src{'t'}
3604         100     19     23   if ($dst)
3608         100     19     56   if (defined $$src{$arg} and defined $$dst{$arg} and $$src{$arg} ne $$dst{$arg})
3614  ***     50      0     19   if ($same)
3618         100      2     40   if ($o->get('bulk-insert'))
3619  ***     50      0      2   unless $dst
3623  ***     50      0     42   if ($bulk_del and $limit < 2)
3629         100      5     37   if ($bulk_del or $o->get('bulk-insert'))
3639  ***     50      0     42   if ($o->get('pid'))
3653         100      7     35   if ($o->get('statistics')) { }
3682  ***     50      0     61   if (not defined $$table{'p'} and $o->get('ask-pass'))
3691  ***     50      0     61   if ($$table{'a'})
3694  ***     50      0     61   if ($$table{'b'})
3712  ***     50      0     61   if ($$table{'m'})
3714  ***      0      0      0   if $EVAL_ERROR
3732         100      1     41   if ($o->get('primary-key-only') and not exists $$src{'info'}{'keys'}{'PRIMARY'})
3735  ***     50      0      1   if $dst and $$dst{'dbh'}
3740         100     17     24   if ($dst and $o->get('check-columns'))
3744  ***     50      0     17   if (@not_in_src)
3746  ***      0      0      0   if $dst and $$dst{'dbh'}
3754         100      2     15   if (@not_in_dst)
3756  ***     50      2      0   if $dst and $$dst{'dbh'}
3768  ***     50      0     39   if ($o->get('check-slave-lag'))
3779  ***     50      0     39   if ($o->get('plugin'))
3781  ***      0      0      0   if $EVAL_ERROR
3802         100      1     35   $o->get('primary-key-only') ? :
             100      3     36   $o->get('columns') ? :
3813         100     36      3   if (not $o->get('no-ascend')) { }
3814  ***      0      0      0   $o->get('bulk-delete') ? :
      ***     50      0     33   $$src{'m'} ? :
             100      3     33   $o->get('no-delete') ? :
3842         100      1     38   $o->get('high-priority-select') ? :
      ***     50     36      0   $vp->version_ge($dbh, '4.0.9') ? :
             100     36      3   $$sel_stmt{'index'} ? :
3850         100      6     33   if ($o->get('safe-auto-increment') and $$sel_stmt{'index'} and scalar @{$$src{'info'}{'keys'}{$$sel_stmt{'index'}}{'cols'};} == 1 and $$src{'info'}{'is_autoinc'}{$$src{'info'}{'keys'}{$$sel_stmt{'index'}}{'cols'}[0]})
3863         100     36      3   if (not $o->get('no-ascend'))
3869         100      2     76   if ($o->get('for-update')) { }
             100      2     74   elsif ($o->get('share-lock')) { }
3878         100     34      5   if (not $bulk_del) { }
3886         100      1     33   $o->get('low-priority-delete') ? :
             100      1     33   $o->get('quick-delete') ? :
3891         100     33      1   if ($$src{'info'}{'keys'}{$$del_stmt{'index'}}{'is_unique'}) { }
3909  ***     50      0      5   $o->get('low-priority-delete') ? :
      ***     50      0      5   $o->get('quick-delete') ? :
             100      4      1   $o->get('bulk-delete-limit') ? :
3922         100     17     22   if ($dst) { }
3929         100      2     15   if ($o->get('bulk-insert')) { }
3936  ***     50      0      2   $o->get('low-priority-insert') ? :
      ***     50      0      2   $o->get('replace') ? :
      ***     50      0      2   $o->get('ignore') ? :
3947         100      2     13   $o->get('replace') ? :
             100      1     14   $o->get('low-priority-insert') ? :
             100      1     14   $o->get('delayed-insert') ? :
      ***     50      0     15   $o->get('ignore') ? :
3961         100     17     22   if ($o->get('dry-run'))
3962  ***     50     17      0   if (not $quiet)
3963         100      2     15   $o->get('no-delete') ? :
3969         100      7     10   if $dst and $$dst{'dbh'}
3976         100     10     12   if $dst
3982  ***     50      0     22   if ($o->get('skip-foreign-key-checks'))
3984  ***      0      0      0   if ($dst)
3993  ***     50     44      0   unless $table and $$table{'plugin'}
4010  ***     50      0     22   if $o->get('progress') and not $quiet
4012  ***     50      0     22   if $o->get('progress') and not $quiet
4024         100      1     21   if (not $row)
4027  ***     50      0      1   if $dst and $$dst{'dbh'}
4032         100      2     19   if ($archive_file)
4034  ***     50      0      2   unless $archive_fh = 'IO::File'->new($archive_file, '>>')
4036  ***     50      2      0   unless $o->get('buffer')
4037         100      1      1   if ($need_hdr)
4038  ***     50      0      1   unless print $archive_fh '', escape(\@sel_cols), "\n"
4045         100      2     19   if ($o->get('bulk-insert'))
4047  ***     50      0      2   unless $bulkins_file = 'File::Temp'->new('SUFFIX', 'mk-archiver')
4066  ***     50    281      0   if (not $$src{'plugin'} or trace('is_archivable', sub {
	$$src{'plugin'}->is_archivable('row', $row);
}
))
4076         100    122    159   if ($archive_fh or $bulkins_file)
4079         100      8    273   if ($archive_fh)
4081  ***     50      0      8   unless print $archive_fh $escaped_row, "\n"
4090         100    131    150   if ($dst and not $bulkins_file)
4092  ***     50      0    131   if ($$dst{'plugin'})
4107  ***     50      0    131   if ($success == $OUT_OF_RETRIES) { }
      ***     50      0    131   elsif ($success == $ROLLED_BACK) { }
4117         100     62    219   if (not $bulk_del)
4119  ***     50      0     62   if ($$src{'plugin'})
4124         100     58      4   if (not $o->get('no-delete'))
4130  ***     50      0     58   if ($success == $OUT_OF_RETRIES) { }
      ***     50      0     58   elsif ($success == $ROLLED_BACK) { }
4144         100    114    167   if ($bulkins_file)
4146  ***     50      0    114   unless print $bulkins_file $escaped_row, "\n"
4159         100    277      4   unless $commit_each
4162  ***     50      0    281   if (not $quiet and $o->get('progress') and $cnt % $o->get('progress') == 0)
4175  ***     50    281      0   if ($$get_sth{'Active'})
4178         100     71    210   if (not $row) { }
4184         100      6     65   if ($bulkins_file)
4185  ***     50      0      6   unless $bulkins_file->close
4188  ***     50      0      6   if ($$dst{'plugin'})
4211  ***     50      0      6   if ($success != $ALL_IS_WELL)
4217         100      9     62   if ($bulk_del)
4218  ***     50      0      9   if ($$src{'plugin'})
4226  ***     50      9      0   if (not $o->get('no-delete'))
4235  ***     50      0      9   if ($success != $ALL_IS_WELL)
4245         100      4     67   if $commit_each
4258         100     65      6   unless $txn_cnt
4260         100     51     20   $row ? :
4262         100      6     65   if ($o->get('bulk-insert'))
4263  ***     50      0      6   unless $bulkins_file = 'File::Temp'->new('SUFFIX', 'mk-archiver')
4272  ***     50      0    281   if ($lag_dbh)
4282  ***     50      0    281   if (my $sleep_time = $o->get('sleep'))
4283  ***      0      0      0   if $o->get('sleep-coef')
4295         100      2     19   if ($archive_file and $archive_fh)
4296  ***     50      0      2   unless close $archive_fh
4300  ***     50      0     21   if (not $quiet and $o->get('progress'))
4306  ***     50     42      0   unless $table and $$table{'plugin'}
4313         100      1     20   if ($oktorun and $o->get('analyze') || $o->get('optimize'))
4315  ***     50      0      1   $o->get('analyze') ? :
      ***     50      0      1   $o->get('local') ? :
4317  ***     50      1      0   if ($action =~ /s/i)
4322  ***     50      0      1   if ($action =~ /d/i and $dst)
4332  ***     50      0     21   if ($plugin)
4336         100      5     16   if (not $quiet and $o->get('statistics'))
4346         100      4      1   if $dst
4376         100      2     19   if ($o->get('why-quit'))
4377  ***     50      0      2   if ($retries < 0) { }
      ***     50      0      2   elsif ($o->get('run-time') and $now >= $end) { }
             100      1      1   elsif (-f $sentinel) { }
      ***     50      1      0   elsif ($o->get('statistics')) { }
4391  ***     50     21      0   if $get_sth
4393         100     10     11   if $dst and $$dst{'dbh'}
4413         100    295      7   if ($force or $txnsize and $txn_cnt and $cnt % $txnsize == 0)
4414  ***     50      0    295   if ($o->get('buffer') and $archive_fh)
4417  ***      0      0      0   unless $archive_fh->flush
4420         100    248     47   if ($dst)
4447  ***     50      0    204   if ($EVAL_ERROR)
4448  ***      0      0      0   if ($EVAL_ERROR =~ /Lock wait timeout exceeded|Deadlock found/) { }
4449  ***      0      0      0   if ($txnsize && $txnsize > 1 || $o->get('commit-each') && $o->get('limit') > 1 and $txn_cnt and !$can_retry || $EVAL_ERROR =~ /Deadlock/) { }
4475  ***     50      0    204   if ($success != $ALL_IS_WELL)
4477  ***      0      0      0   if ($retries >= 0) { }
4508         100    996      2   if defined $_
4510         100    996      2   defined $_ ? :
4526  ***     50      0     61   unless $vp->version_ge($dbh, '5.0.13')
4530  ***     50      0     61   unless $rows
4536  ***      0      0      0   defined $_ ? :


Conditions
----------

and 3 conditions

line  err      %     !l  l&&!r   l&&r   expr
----- --- ------ ------ ------ ------   ----
320          100   1376    903    301   $type and $type =~ /[HhAadzm]/
464   ***     33      0     43      0   @ARGV and $ARGV[0] eq '--config'
493   ***     33      0     43      0   exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'}
500   ***     33     43      0      0   @ARGV and $$self{'strict'}
614          100    750    368     86   $val and $$opt{'type'} eq 'm'
             100    750    307     61   $val and $$opt{'type'} eq 'd'
      ***     66    750    307      0   $val and $$opt{'type'} eq 'z'
      ***     66    749    308      0   defined $val and $$opt{'type'} eq 'h'
             100    749    261      4   defined $val and $$opt{'type'} eq 'a'
675   ***     33      0      0   4488   $long and exists $$self{'opts'}{$long}
683   ***     33      0      0    214   $long and exists $$self{'opts'}{$long}
697   ***     33      0      0      5   $long and exists $$self{'opts'}{$long}
813   ***      0      0      0      0   $$opt{'type'} and $$opt{'type'} eq 'm'
909   ***      0      0      0      0   $parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/
1010  ***     66      0     42  23016   defined($para = <$fh>) and not $para =~ /^=head1 SYNOPSIS/
1020  ***     33      0      0     42   $usage and $desc
1276  ***      0      0      0      0   $privs =~ /select/ && $privs =~ /insert/
      ***      0      0      0      0   $privs =~ /select/ && $privs =~ /insert/ && $privs =~ /update/
      ***      0      0      0      0   $privs =~ /select/ && $privs =~ /insert/ && $privs =~ /update/ && $can_delete
1314  ***     33     85      0      0   $$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000'
      ***     33     85      0      0   $$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000' and $engine =~ /HEAP|MEMORY/i
1345         100     10     29     46   $engine =~ /InnoDB/i and not $clustered_key
1347  ***      0      0      0      0   $$this_key{'is_unique'} and not $$this_key{'is_nullable'}
1371  ***      0      0      0      0   not $parent =~ /\./ and $$opts{'database'}
1534         100    251    729     38   not defined $final_props{$key} and defined $$prev{$key}
      ***     66    980      0     38   not defined $final_props{$key} and defined $$prev{$key} and $$opts{$key}{'copy'}
1667  ***     66     86      0     86   not $dbh and $tries--
1709  ***     33     86      0      0   not $dbh and $EVAL_ERROR
1954  ***      0      0      0      0   $db and not $db =~ /^`/
1955  ***      0      0      0      0   $tbl and not $tbl =~ /^`/
2096  ***      0      0      0      0   $type =~ /=/ and $end
2111         100    100     18     82   $type =~ /=/ && $end
2294  ***      0      0      0      0   $trgs and @$trgs
2624  ***      0      0      0      0   $PID_file and -f $PID_file
2685  ***      0      0      0      0   $$self{'PID_file'} and -f $$self{'PID_file'}
2771  ***      0      0      0      0   defined $master_thinks_i_am and $master_thinks_i_am != $id
2882  ***      0      0      0      0   $vp and not $vp->version_ge($dbh, '4.1.2')
2981  ***      0      0      0      0   $ss and %$ss
3000  ***      0      0      0      0   $ms and %$ms
3002  ***      0      0      0      0   $$ms{'file'} and $$ms{'position'}
3184  ***      0      0      0      0   not $self->slave_is_running($mslave_status) and not $self->slave_is_running($slave_status)
      ***      0      0      0      0   not $self->slave_is_running($mslave_status) and not $self->slave_is_running($slave_status) and $self->pos_cmp($master_pos, $slave_pos) == 0
3319  ***      0      0      0      0   $value && $value =~ /^(1|ON)$/
3324  ***      0      0      0      0   exists $$status{'file'} and exists $$status{'position'}
3394  ***      0      0      0      0   $type eq 'slave_sql' && $slave_sql
      ***      0      0      0      0   $type eq 'slave_io' && !$slave_sql
3464  ***      0      0      0      0   $$row[1] and $$row[1] ne 'OFF'
3587  ***     33      0      0      2   $src && $$src{'D'}
      ***     33      0      0      2   $src && $$src{'t'}
3608  ***     66     36      0     39   defined $$src{$arg} and defined $$dst{$arg}
             100     36     20     19   defined $$src{$arg} and defined $$dst{$arg} and $$src{$arg} ne $$dst{$arg}
3623  ***     66     37      5      0   $bulk_del and $limit < 2
3681         100     56      3      2   !$txnsize && !$commit_each
3682  ***     66      2     59      0   not defined $$table{'p'} and $o->get('ask-pass')
3701  ***     33      0      0     61   $can_retry && !$$table{'irot'}
3732         100     40      1      1   $o->get('primary-key-only') and not exists $$src{'info'}{'keys'}{'PRIMARY'}
3735  ***     33      1      0      0   $dst and $$dst{'dbh'}
3740         100     22      2     17   $dst and $o->get('check-columns')
3746  ***      0      0      0      0   $dst and $$dst{'dbh'}
3756  ***     33      0      0      2   $dst and $$dst{'dbh'}
3850         100      1      3     35   $o->get('safe-auto-increment') and $$sel_stmt{'index'}
      ***     66      4      0     35   $o->get('safe-auto-increment') and $$sel_stmt{'index'} and scalar @{$$src{'info'}{'keys'}{$$sel_stmt{'index'}}{'cols'};} == 1
             100      4     29      6   $o->get('safe-auto-increment') and $$sel_stmt{'index'} and scalar @{$$src{'info'}{'keys'}{$$sel_stmt{'index'}}{'cols'};} == 1 and $$src{'info'}{'is_autoinc'}{$$src{'info'}{'keys'}{$$sel_stmt{'index'}}{'cols'}[0]}
3969  ***     66     10      0      7   $dst and $$dst{'dbh'}
3993  ***     66     12     32      0   $table and $$table{'plugin'}
4010  ***     33     22      0      0   $o->get('progress') and not $quiet
4012  ***     33     22      0      0   $o->get('progress') and not $quiet
4027  ***     33      1      0      0   $dst and $$dst{'dbh'}
4033  ***     66      1      0      1   $o->get('header') && !-f($archive_file)
4056  ***     66     20      0    282   $row and $retries >= 0
      ***     66     20      0    282   $row and $retries >= 0 and !$o->get('run-time') || $now < $end
             100     20      1    281   $row and $retries >= 0 and !$o->get('run-time') || $now < $end and not -f $sentinel
      ***     66     21      0    281   $row and $retries >= 0 and !$o->get('run-time') || $now < $end and not -f $sentinel and $oktorun
4090         100     36    114    131   $dst and not $bulkins_file
4162  ***     33      0    281      0   not $quiet and $o->get('progress')
      ***     33    281      0      0   not $quiet and $o->get('progress') and $cnt % $o->get('progress') == 0
4295  ***     66     19      0      2   $archive_file and $archive_fh
4300  ***     33      0     21      0   not $quiet and $o->get('progress')
4306  ***     66     11     31      0   $table and $$table{'plugin'}
4313  ***     66      0     20      1   $oktorun and $o->get('analyze') || $o->get('optimize')
4322  ***     33      0      1      0   $action =~ /d/i and $dst
4336  ***     66      0     16      5   not $quiet and $o->get('statistics')
4377  ***     33      2      0      0   $o->get('run-time') and $now >= $end
4393  ***     66     11      0     10   $dst and $$dst{'dbh'}
4413         100    666      3    273   $txnsize and $txn_cnt
             100      5      2    271   $txnsize and $txn_cnt and $cnt % $txnsize == 0
4414  ***     33    295      0      0   $o->get('buffer') and $archive_fh
4442  ***     66    204      0    204   not $success and $retries >= 0
4449  ***      0      0      0      0   $txnsize && $txnsize > 1
      ***      0      0      0      0   $o->get('commit-each') && $o->get('limit') > 1
      ***      0      0      0      0   $txnsize && $txnsize > 1 || $o->get('commit-each') && $o->get('limit') > 1 and $txn_cnt
      ***      0      0      0      0   $txnsize && $txnsize > 1 || $o->get('commit-each') && $o->get('limit') > 1 and $txn_cnt and !$can_retry || $EVAL_ERROR =~ /Deadlock/
4531  ***     33      0     61      0   @$rows && $$rows[0]{'Value'} ne 'OFF'

or 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
45    ***     50      0     21   $ENV{'MKDEBUG'} || 0
59    ***     33     86      0   0
60    ***     50     86      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'} || '.'
120   ***     50      0     43   $$self{'file'} || '/home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver'
      ***     33      0     43   0
185   ***      0      0      0   $$self{'file'} || '/home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver'
      ***     33     86      0   0
309   ***     50   2580      0   $$opt{'group'} ||= 'default'
619   ***      0      0      0   $s || 's'
628   ***     50      0     86   $prefix || ''
658   ***      0      0      0   $val || ''
661   ***     50     47      0   $val || ''
717   ***      0      0      0   $$self{'usage'} || ''
723   ***      0      0      0   $$self{'description'} || $$self{'program_name'} || ''
735   ***     50      0     42   $$self{'file'} || '/home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver'
      ***     33      0     42   0
740   ***     33      0     42   0
741   ***     33      0     42   0
815   ***      0      0      0   $s ||= 's'
843   ***      0      0      0   $$opt{'type'} || ''
970   ***      0      0      0   $val || ''
984   ***      0      0      0   $pre || ''
1004  ***      0      0      0   $$self{'file'} || '/home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver'
      ***     33     42      0   0
1070  ***     50      0     21   $ENV{'MKDEBUG'} || 0
1290  ***     50    122      0   $engine || undef
1313  ***     50      0     85   $type || $special || 'BTREE'
1400  ***      0      0      0   $$tbl_struct{'engine'} || ''
1402  ***      0      0      0   $clustered_key ||= ''
1460  ***     50      0     21   $ENV{'MKDEBUG'} || 0
1490         100    619    129   $$opt{'copy'} || 0
1515         100     61     25   $prev ||= {}
1516  ***     50      0     86   $defaults ||= {}
1596  ***      0      0      0   $opts{$key}{'desc'} || '[No description]'
1609  ***     50      0     86   $self->prop('dbidriver') || ''
1613  ***      0      0      0   $$info{'D'} || ''
1619         100     61     25   $$info{'D'} || ''
1641  ***     50     86      0   $opts ||= {}
1746  ***      0      0      0   $$dbh{'mysql_hostinfo'} || ''
1762  ***      0      0      0   $level ||= 0
1763  ***      0      0      0   $$thing{'Type'} || 'undef'
      ***      0      0      0   $$thing{'Type'} || ''
      ***      0      0      0   $$thing{'Statement'} || ''
1818  ***     50      0     21   $ENV{'MKDEBUG'} || 0
1902  ***     50      0     21   $ENV{'MKDEBUG'} || 0
1980  ***     50      0     21   $ENV{'MKDEBUG'} || 0
2240  ***     50      0     21   $ENV{'MKDEBUG'} || 0
2504  ***      0      0      0   $$_[1] || ''
2548  ***     50      0     21   $ENV{'MKDEBUG'} || 0
2699  ***      0      0      0   $$self{'PID_owner'} || 0
2732  ***     50      0     21   $ENV{'MKDEBUG'} || 0
2750  ***      0      0      0   $level ||= 0
2808  ***      0      0      0   $$dsn{'P'} || 3306
2947  ***      0      0      0   $$slave_status{'slave_io_state'} || ''
3019  ***      0      0      0   $args{'timeout'} || 60
3311  ***      0      0      0   $$slave_status{'slave_sql_running'} || 'No'
3360  ***      0      0      0   $host || '[default]'
      ***      0      0      0   $port || 3306
3367  ***      0      0      0   lc $args{'type'} || 'all'
3373  ***      0      0      0   $$query{'Command'} || $$query{'command'} || ''
3377  ***      0      0      0   $$query{'User'} || $$query{'user'} || ''
3380  ***      0      0      0   $$query{'State'} || $$query{'state'} || ''
3516  ***     50      0     21   $ENV{'MKDEBUG'} || 0
3658  ***     66    696      5   0
3664  ***     66    696      5   0
3963  ***     50      0     17   $archive_file || ''
4006  ***     50      0     22   $o->get('run-time') || 0
4101  ***     33      0    131   0
4347         100     14      1   $statistics{$_} || 0
4357         100     26     14   $summary{$action}{'time'} ||= 0
4358         100     34      6   $summary{$action}{'count'} ||= 0

or 3 conditions

line  err      %      l  !l&&r !l&&!r   expr
----- --- ------ ------ ------ ------   ----
60    ***     33     86      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'}
      ***     33     86      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'}
614   ***     33      0      0   1057   $$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h'
             100     43      4   1010   $$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a'
723   ***      0      0      0      0   $$self{'description'} || $$self{'program_name'}
737   ***     33     42      0      0   not $$self{'description'} or not $$self{'usage'}
1164  ***     33     28      0      0   ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'}
      ***     33     28      0      0   ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'} or $$tbl{'keys'}{$a}{'is_nullable'} <=> $$tbl{'keys'}{$b}{'is_nullable'}
1243  ***      0      0      0      0   not $$row[0] or $$row[0] ne $tbl
1264  ***      0      0      0      0   $$row{'privileges'} || $$row{'Privileges'}
1313  ***     33      0      0     85   $type || $special
1481  ***     33      0      0    748   not $$opt{'key'} or not $$opt{'desc'}
1632  ***      0      0      0      0   $$dsn{'h'} ||= $$vars{'hostname'}{'Value'}
1633  ***      0      0      0      0   $$dsn{'S'} ||= $$vars{'socket'}{'Value'}
1634  ***      0      0      0      0   $$dsn{'P'} ||= $$vars{'port'}{'Value'}
1635  ***      0      0      0      0   $$dsn{'u'} ||= $user
1636  ***      0      0      0      0   $$dsn{'D'} ||= $db
1861  ***      0      0      0      0   $$vars{'Value'} || $$vars{'value'}
2345  ***     33     61      0      0   not $$self{'cache'} or not $$self{'tables'}{$db}{$tbl}
2384  ***      0      0      0      0   not $$self{'cache'} or not $$self{'columns'}{$db}{$tbl}
2414  ***      0      0      0      0   not $$self{'cache'} or not $$self{'triggers'}{$db}
2448  ***      0      0      0      0   not $$self{'cache'} or not $$self{'databases'}
      ***      0      0      0      0   not $$self{'cache'} or not $$self{'databases'} or $like
2467  ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_status'}{$db}
      ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_status'}{$db} or $like
2481  ***      0      0      0      0   $tbl{'type'} || $tbl{'comment'}
      ***      0      0      0      0   $tbl{'engine'} ||= $tbl{'type'} || $tbl{'comment'}
2493  ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_list'}{$db}
      ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_list'}{$db} or $like
2756  ***      0      0      0      0   $$args{'dbh'} || $dp->get_dbh($dp->get_cxn_params($dsn), {'AutoCommit', 1})
2771  ***      0      0      0      0   not defined $id or defined $master_thinks_i_am and $master_thinks_i_am != $id
      ***      0      0      0      0   not defined $id or defined $master_thinks_i_am and $master_thinks_i_am != $id or $$args{'server_ids_seen'}{$id}++
2784  ***      0      0      0      0   not defined $$args{'recurse'} or $level < $$args{'recurse'}
2954  ***      0      0      0      0   $master_log_name ne $slave_log_name or abs $master_log_num - $slave_log_num > 1
2975  ***      0      0      0      0   $$self{'sths'}{$dbh}{'SLAVE_STATUS'} ||= $dbh->prepare('SHOW SLAVE STATUS')
2994  ***      0      0      0      0   $$self{'sths'}{$dbh}{'MASTER_STATUS'} ||= $dbh->prepare('SHOW MASTER STATUS')
3020  ***      0      0      0      0   $args{'master_status'} || $self->get_master_status($master_dbh)
3049  ***      0      0      0      0   $$self{'sths'}{$dbh}{'STOP_SLAVE'} ||= $dbh->prepare('STOP SLAVE')
3064  ***      0      0      0      0   $$self{'sths'}{$dbh}{'START_SLAVE'} ||= $dbh->prepare('START SLAVE')
3138  ***      0      0      0      0   $self->slave_is_running($s1_status) or $self->slave_is_running($s2_status)
      ***      0      0      0      0   $self->slave_is_running($s1_status) or $self->slave_is_running($s2_status) or $self->pos_cmp($s1_pos, $s2_pos) != 0
3199  ***      0      0      0      0   $self->short_host($mslave_status) ne $self->short_host($slave_status) or $self->pos_cmp($mslave_pos, $slave_pos) != 0
3237  ***      0      0      0      0   $self->short_host($slave_status) ne $self->short_host($sib_dsn) or $self->pos_cmp($self->repl_posn($sib_master_stat), $slave_pos) != 0
3291  ***      0      0      0      0   $self->short_host($slave_status) ne $self->short_host($unc_dsn) or $self->pos_cmp($self->repl_posn($unc_master_stat), $slave_pos) != 0
3373  ***      0      0      0      0   $$query{'Command'} || $$query{'command'}
3377  ***      0      0      0      0   $$query{'User'} || $$query{'user'}
3380  ***      0      0      0      0   $$query{'State'} || $$query{'state'}
3407  ***      0      0      0      0   not defined $args{'check_known_ids'} or $args{'check_known_ids'}
3408  ***      0      0      0      0   $$query{'Id'} || $$query{'id'}
3629  ***     66      5      0     37   $bulk_del or $o->get('bulk-insert')
4056  ***     33    282      0      0   !$o->get('run-time') || $now < $end
4066  ***     33    281      0      0   not $$src{'plugin'} or trace('is_archivable', sub {
	$$src{'plugin'}->is_archivable('row', $row);
}
)
4076         100      8    114    159   $archive_fh or $bulkins_file
4205  ***     33      0      6      0   $ins_sth ||= $ins_row
4274  ***      0      0      0      0   not defined $lag or $lag > $o->get('max-lag')
4294         100     19      1      1   $txnsize || $commit_each
4313  ***     66      0      1     20   $o->get('analyze') || $o->get('optimize')
4314  ***     33      0      1      0   $o->get('analyze') || $o->get('optimize')
4413         100     24    271      7   $force or $txnsize and $txn_cnt and $cnt % $txnsize == 0
4449  ***      0      0      0      0   $txnsize && $txnsize > 1 || $o->get('commit-each') && $o->get('limit') > 1
      ***      0      0      0      0   !$can_retry || $EVAL_ERROR =~ /Deadlock/


Covered Subroutines
-------------------

Subroutine                      Count Location                                                   
------------------------------- ----- -----------------------------------------------------------
BEGIN                              21 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:1062
BEGIN                              21 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:1063
BEGIN                              21 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:1064
BEGIN                              21 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:1065
BEGIN                              21 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:1070
BEGIN                              21 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:1457
BEGIN                              21 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:1458
BEGIN                              21 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:1459
BEGIN                              21 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:1460
BEGIN                              21 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:1462
BEGIN                              21 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:1813
BEGIN                              21 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:1814
BEGIN                              21 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:1816
BEGIN                              21 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:1818
BEGIN                              21 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:1898
BEGIN                              21 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:1899
BEGIN                              21 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:1900
BEGIN                              21 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:1902
BEGIN                              21 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:1975
BEGIN                              21 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:1976
BEGIN                              21 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:1978
BEGIN                              21 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:1980
BEGIN                              21 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:2235
BEGIN                              21 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:2236
BEGIN                              21 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:2238
BEGIN                              21 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:2240
BEGIN                              21 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:23  
BEGIN                              21 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:24  
BEGIN                              21 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:2542
BEGIN                              21 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:2543
BEGIN                              21 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:2545
BEGIN                              21 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:2546
BEGIN                              21 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:2548
BEGIN                              21 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:2729
BEGIN                              21 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:2730
BEGIN                              21 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:2731
BEGIN                              21 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:2732
BEGIN                              21 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:2734
BEGIN                              21 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:2735
BEGIN                              21 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:3507
BEGIN                              21 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:3508
BEGIN                              21 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:3509
BEGIN                              21 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:3510
BEGIN                              21 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:3511
BEGIN                              21 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:3512
BEGIN                              21 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:3516
BEGIN                              21 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:41  
BEGIN                              21 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:42  
BEGIN                              21 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:43  
BEGIN                              21 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:44  
BEGIN                              21 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:45  
BEGIN                              21 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:47  
DSNParser                          43 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:174 
__ANON__                          559 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:134 
__ANON__                          701 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:3658
__ANON__                          262 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:3669
__ANON__                           22 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:4017
__ANON__                            8 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:4081
__ANON__                          131 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:4103
__ANON__                           58 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:4126
__ANON__                          114 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:4146
__ANON__                            6 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:4207
__ANON__                            9 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:4230
__ANON__                           71 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:4250
__ANON__                            1 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:4319
__ANON__                          248 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:4422
__ANON__                          295 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:4426
__ANON__                          206 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:488 
_check_opts                        43 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:531 
_get_participants                 387 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:388 
_parse_attribs                   2580 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:993 
_parse_specs                       43 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:273 
_parse_synopsis                    42 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:1003
_pod_to_specs                      86 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:184 
_read_config_file                 172 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:892 
_set_option                       206 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:434 
_use_db                            61 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:2332
_validate_type                   2580 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:604 
as_string                           9 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:1578
commit                            302 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:4411
do_with_retries                   204 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:4436
escape                            123 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:4507
find_best_index                    39 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:1176
generate_asc_stmt                  41 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:1993
generate_cmp_where                164 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:2056
generate_del_stmt                  39 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:2126
generate_ins_stmt                  17 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:2188
get                              4488 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:673 
get_create_table                   61 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:2344
get_cxn_params                     86 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:1606
get_dbh                            86 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:1640
get_defaults_files                 43 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:179 
get_engine                        122 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:1287
get_irot                           61 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:4525
get_keys                           61 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:1294
get_opts                           43 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:451 
get_specs                          43 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:119 
got                               214 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:681 
has                               836 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:689 
main                               43 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:3535
new                                42 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:1073
new                                64 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:1473
new                                21 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:1821
new                                21 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:1905
new                                39 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:1983
new                                42 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:2267
new                                86 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:52  
parse                              61 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:1083
parse                             147 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:1509
parse                             158 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:1826
parse_options                      61 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:1565
prop                              362 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:1500
quote                             721 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:1910
quote_val                           6 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:1918
save_error                          3 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:704 
set                                 5 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:695 
sort_indexes                       39 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:1157
split_unquote                      61 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:1929
ts                                 10 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:4515
usage_or_errors                    42 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:734 
version_ge                         97 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:1833

Uncovered Subroutines
---------------------

Subroutine                      Count Location                                                   
------------------------------- ----- -----------------------------------------------------------
DESTROY                             0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:2697
__ANON__                            0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:3717
__ANON__                            0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:3995
__ANON__                            0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:4068
__ANON__                            0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:4094
__ANON__                            0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:4097
__ANON__                            0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:4121
__ANON__                            0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:4190
__ANON__                            0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:4197
__ANON__                            0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:4220
__ANON__                            0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:4287
__ANON__                            0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:4308
__ANON__                            0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:4324
__ANON__                            0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:4417
__ANON__                            0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:4488
__ANON__                            0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:4491
__ANON__                            0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:4495
_d                                  0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:1038
_d                                  0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:1433
_d                                  0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:1790
_d                                  0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:1874
_d                                  0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:2212
_d                                  0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:2518
_d                                  0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:2705
_d                                  0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:3484
_d                                  0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:4535
_find_slaves_by_hosts               0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:2850
_find_slaves_by_processlist         0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:2830
_make_PID_file                      0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:2662
_parse_size                         0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:968 
_remove_PID_file                    0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:2684
catchup_to_master                   0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:3072
catchup_to_same_pos                 0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:3119
change_master_to                    0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:3148
check_PID_file                      0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:2621
check_table                         0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:1222
clone                               0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:945 
copy                                0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:1772
daemonize                           0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:2569
descr                               0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:721 
detach_slave                        0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:3300
disconnect                          0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:1755
dump                                0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:2275
errors                              0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:710 
fill_in_dsn                         0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:1628
find_possible_keys                  0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:1194
find_slave_hosts                    0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:2800
finish                              0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:4404
get_columns                         0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:2382
get_connected_slaves                0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:2877
get_databases                       0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:2447
get_defaults                        0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:424 
get_fks                             0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:1361
get_groups                          0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:429 
get_hostname                        0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:1745
get_master_dsn                      0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:2966
get_master_status                   0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:2992
get_replication_filters             0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:3429
get_slave_lag                       0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:3339
get_slave_status                    0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:2973
get_table_list                      0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:2492
get_table_status                    0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:2466
get_tmp_table                       0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:2402
get_triggers                        0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:2413
has_slave_updates                   0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:3315
innodb_version                      0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:1844
is_master_of                        0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:2928
is_replication_thread               0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:3364
join_quote                          0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:1947
literal_like                        0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:1940
make_PID_file                       0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:2652
make_sibling_of_master              0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:3159
make_slave_of_sibling               0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:3207
make_slave_of_uncle                 0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:3246
new                                 0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:2551
new                                 0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:2740
opts                                0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:400 
pos_cmp                             0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:3345
pos_to_string                       0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:3472
print_active_handles                0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:1761
print_errors                        0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:759 
print_usage                         0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:769 
prompt_noecho                       0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:857 
read_para_after                     0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:926 
recurse_to_slaves                   0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:2749
remove_auto_increment               0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:1390
remove_secondary_indexes            0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:1396
repl_posn                           0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:3323
reset_known_replication_threads     0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:3478
set_defaults                        0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:412 
short_host                          0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:3350
short_opts                          0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:406 
slave_is_running                    0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:3310
start_slave                         0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:3056
stop_slave                          0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:3048
usage                               0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:1589
usage                               0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:715 
wait_for_master                     0 /home/daniel/dev/maatkit/trunk/mk-archiver/mk-archiver:3013


